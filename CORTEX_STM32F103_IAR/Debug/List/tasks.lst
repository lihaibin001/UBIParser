###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.2.11947/W32 for ARM       15/Sep/2017  09:59:31
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\workspace\dr002\dr002_suming\v1_board\main_app\FreeRTOS\tasks.c
#    Command line =  
#        D:\workspace\dr002\dr002_suming\v1_board\main_app\FreeRTOS\tasks.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -lcN
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\List
#        --diag_suppress Pa050 -o
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\.\ -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Diag_Factory\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\common\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\power\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\SysMan\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Protocol\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\include\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\FreeRTOS\include\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\FreeRTOS\portable\IAR\ARM_CM3\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\drivers\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\GPS\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\GPRS\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Sensors\
#        -Ol --use_c++_inline --require_prototypes
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\List\tasks.lst
#    Object file  =  
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\Obj\tasks.o
#
###############################################################################

D:\workspace\dr002\dr002_suming\v1_board\main_app\FreeRTOS\tasks.c
      1          /*
      2              FreeRTOS V7.3.0 - Copyright (C) 2012 Real Time Engineers Ltd.
      3          
      4              FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
      5              http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              ***************************************************************************
      8               *                                                                       *
      9               *    FreeRTOS tutorial books are available in pdf and paperback.        *
     10               *    Complete, revised, and edited pdf reference manuals are also       *
     11               *    available.                                                         *
     12               *                                                                       *
     13               *    Purchasing FreeRTOS documentation will not only help you, by       *
     14               *    ensuring you get running as quickly as possible and with an        *
     15               *    in-depth knowledge of how to use FreeRTOS, it will also help       *
     16               *    the FreeRTOS project to continue with its mission of providing     *
     17               *    professional grade, cross platform, de facto standard solutions    *
     18               *    for microcontrollers - completely free of charge!                  *
     19               *                                                                       *
     20               *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
     21               *                                                                       *
     22               *    Thank you for using FreeRTOS, and thank you for your support!      *
     23               *                                                                       *
     24              ***************************************************************************
     25          
     26          
     27              This file is part of the FreeRTOS distribution.
     28          
     29              FreeRTOS is free software; you can redistribute it and/or modify it under
     30              the terms of the GNU General Public License (version 2) as published by the
     31              Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
     32              >>>NOTE<<< The modification to the GPL is included to allow you to
     33              distribute a combined work that includes FreeRTOS without being obliged to
     34              provide the source code for proprietary components outside of the FreeRTOS
     35              kernel.  FreeRTOS is distributed in the hope that it will be useful, but
     36              WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
     37              or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
     38              more details. You should have received a copy of the GNU General Public
     39              License and the FreeRTOS license exception along with FreeRTOS; if not it
     40              can be viewed here: http://www.freertos.org/a00114.html and also obtained
     41              by writing to Richard Barry, contact details for whom are available on the
     42              FreeRTOS WEB site.
     43          
     44              1 tab == 4 spaces!
     45          
     46              ***************************************************************************
     47               *                                                                       *
     48               *    Having a problem?  Start by reading the FAQ "My application does   *
     49               *    not run, what could be wrong?"                                     *
     50               *                                                                       *
     51               *    http://www.FreeRTOS.org/FAQHelp.html                               *
     52               *                                                                       *
     53              ***************************************************************************
     54          
     55          
     56              http://www.FreeRTOS.org - Documentation, training, latest versions, license
     57              and contact details.
     58          
     59              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     60              including FreeRTOS+Trace - an indispensable productivity tool.
     61          
     62              Real Time Engineers ltd license FreeRTOS to High Integrity Systems, who sell
     63              the code with commercial support, indemnification, and middleware, under
     64              the OpenRTOS brand: http://www.OpenRTOS.com.  High Integrity Systems also
     65              provide a safety engineered and independently SIL3 certified version under
     66              the SafeRTOS brand: http://www.SafeRTOS.com.
     67          */
     68          
     69          /* Standard includes. */
     70          #include <stdio.h>
     71          #include <stdlib.h>
     72          #include <string.h>
     73          
     74          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     75          all the API functions to use the MPU wrappers.  That should only be done when
     76          task.h is included from an application file. */
     77          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     78          
     79          /* FreeRTOS includes. */
     80          #include "FreeRTOS.h"
     81          #include "task.h"
     82          #include "timers.h"
     83          #include "StackMacros.h"
     84          
     85          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     86          
     87          /*
     88           * Defines the size, in words, of the stack allocated to the idle task.
     89           */
     90          #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
     91          
     92          /*
     93           * Task control block.  A task control block (TCB) is allocated for each task,
     94           * and stores task state information, including a pointer to the task's context
     95           * (the task's run time environment, including register values)
     96           */
     97          typedef struct tskTaskControlBlock
     98          {
     99          	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
    100          
    101          	#if ( portUSING_MPU_WRAPPERS == 1 )
    102          		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
    103          	#endif
    104          
    105          	xListItem				xGenericListItem;		/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
    106          	xListItem				xEventListItem;		/*< Used to reference a task from an event list. */
    107          	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
    108          	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
    109          	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */
    110          
    111          	#if ( portSTACK_GROWTH > 0 )
    112          		portSTACK_TYPE *pxEndOfStack;			/*< Points to the end of the stack on architectures where the stack grows up from low memory. */
    113          	#endif
    114          
    115          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
    116          		unsigned portBASE_TYPE uxCriticalNesting; /*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
    117          	#endif
    118          
    119          	#if ( configUSE_TRACE_FACILITY == 1 )
    120          		unsigned portBASE_TYPE	uxTCBNumber;	/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
    121          		unsigned portBASE_TYPE  uxTaskNumber;	/*< Stores a number specifically for use by third party trace code. */
    122          	#endif
    123          
    124          	#if ( configUSE_MUTEXES == 1 )
    125          		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
    126          	#endif
    127          
    128          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
    129          		pdTASK_HOOK_CODE pxTaskTag;
    130          	#endif
    131          
    132          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
    133          		unsigned long ulRunTimeCounter;			/*< Stores the amount of time the task has spent in the Running state. */
    134          	#endif
    135          
    136          } tskTCB;
    137          
    138          
    139          /*
    140           * Some kernel aware debuggers require the data the debugger needs access to to
    141           * be global, rather than file scope.
    142           */
    143          #ifdef portREMOVE_STATIC_QUALIFIER
    144          	#define static
    145          #endif
    146          
    147          /*lint -e956 */
    148          PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
    149          
    150          /* Lists for ready and blocked tasks. --------------------*/
    151          PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks. */
    152          PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
    153          PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
    154          PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list currently being used. */
    155          PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
    156          PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready queue when the scheduler is resumed. */
    157          
    158          #if ( INCLUDE_vTaskDelete == 1 )
    159          
    160          	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but the their memory not yet freed. */
    161          	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE ) 0U;
    162          
    163          #endif
    164          
    165          #if ( INCLUDE_vTaskSuspend == 1 )
    166          
    167          	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
    168          
    169          #endif
    170          
    171          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
    172          
    173          	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
    174          
    175          #endif
    176          
    177          /* File private variables. --------------------------------*/
    178          PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBASE_TYPE ) 0U;
    179          PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
    180          PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
    181          PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
    182          PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
    183          PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE_TYPE ) pdFALSE;
    184          PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE ) 0U;
    185          PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
    186          PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
    187          PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
    188          PRIVILEGED_DATA static volatile portTickType xNextTaskUnblockTime				= ( portTickType ) portMAX_DELAY;
    189          
    190          #if ( configGENERATE_RUN_TIME_STATS == 1 )
    191          
    192          	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
    193          	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
    194          	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList, unsigned long ulTotalRunTime ) PRIVILEGED_FUNCTION;
    195          
    196          #endif
    197          
    198          /* Debugging and trace facilities private variables and macros. ------------*/
    199          
    200          /*
    201           * The value used to fill the stack of a task when the task is created.  This
    202           * is used purely for checking the high water mark for tasks.
    203           */
    204          #define tskSTACK_FILL_BYTE	( 0xa5U )
    205          
    206          /*
    207           * Macros used by vListTask to indicate which state a task is in.
    208           */
    209          #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
    210          #define tskREADY_CHAR		( ( signed char ) 'R' )
    211          #define tskDELETED_CHAR		( ( signed char ) 'D' )
    212          #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
    213          
    214          /*-----------------------------------------------------------*/
    215          
    216          #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 0
    217          
    218          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
    219          	performed in a generic way that is not optimised to any particular
    220          	microcontroller architecture. */
    221          
    222          	/* uxTopReadyPriority holds the priority of the highest priority ready
    223          	state task. */
    224          	#define taskRECORD_READY_PRIORITY( uxPriority )																		\
    225          	{																													\
    226          		if( ( uxPriority ) > uxTopReadyPriority )																		\
    227          		{																												\
    228          			uxTopReadyPriority = ( uxPriority );																		\
    229          		}																												\
    230          	} /* taskRECORD_READY_PRIORITY */
    231          
    232          	/*-----------------------------------------------------------*/
    233          
    234          	#define taskSELECT_HIGHEST_PRIORITY_TASK()																			\
    235          	{																													\
    236          		/* Find the highest priority queue that contains ready tasks. */												\
    237          		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )										\
    238          		{																												\
    239          			configASSERT( uxTopReadyPriority );																			\
    240          			--uxTopReadyPriority;																						\
    241          		}																												\
    242          																														\
    243          		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of										\
    244          		the	same priority get an equal share of the processor time. */													\
    245          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );						\
    246          	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
    247          
    248          	/*-----------------------------------------------------------*/
    249          
    250          	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
    251          	they are only required when a port optimised method of task selection is
    252          	being used. */
    253          	#define taskRESET_READY_PRIORITY( uxPriority )
    254          	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    255          
    256          #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    257          
    258          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
    259          	performed in a way that is tailored to the particular microcontroller
    260          	architecture being used. */
    261          
    262          	/* A port optimised version is provided.  Call the port defined macros. */
    263          	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    264          
    265          	/*-----------------------------------------------------------*/
    266          
    267          	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
    268          	{																								\
    269          	unsigned portBASE_TYPE uxTopPriority;															\
    270          																									\
    271          		/* Find the highest priority queue that contains ready tasks. */							\
    272          		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
    273          		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
    274          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
    275          	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
    276          
    277          	/*-----------------------------------------------------------*/
    278          
    279          	/* A port optimised version is provided, call it only if the TCB being reset
    280          	is being referenced from a ready list.  If it is referenced from a delayed
    281          	or suspended list then it won't be in a ready list. */
    282          	#define taskRESET_READY_PRIORITY( uxPriority )													\
    283          	{																								\
    284          		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )				\
    285          		{																							\
    286          			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );						\
    287          		}																							\
    288          	}
    289          
    290          #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    291          
    292          /*
    293           * Place the task represented by pxTCB into the appropriate ready queue for
    294           * the task.  It is inserted at the end of the list.  One quirk of this is
    295           * that if the task being inserted is at the same priority as the currently
    296           * executing task, then it will only be rescheduled after the currently
    297           * executing task has been rescheduled.
    298           */
    299          #define prvAddTaskToReadyQueue( pxTCB )																				\
    300          	traceMOVED_TASK_TO_READY_STATE( pxTCB )																			\
    301          	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );																\
    302          	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) )
    303          /*-----------------------------------------------------------*/
    304          
    305          /*
    306           * Macro that looks at the list of tasks that are currently delayed to see if
    307           * any require waking.
    308           *
    309           * Tasks are stored in the queue in the order of their wake time - meaning
    310           * once one tasks has been found whose timer has not expired we need not look
    311           * any further down the list.
    312           */
    313          #define prvCheckDelayedTasks()															\
    314          {																						\
    315          portTickType xItemValue;																\
    316          																						\
    317          	/* Is the tick count greater than or equal to the wake time of the first			\
    318          	task referenced from the delayed tasks list? */										\
    319          	if( xTickCount >= xNextTaskUnblockTime )											\
    320          	{																					\
    321          		for( ;; )																		\
    322          		{																				\
    323          			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
    324          			{																			\
    325          				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
    326          				maximum possible value so it is extremely unlikely that the				\
    327          				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
    328          				time through. */														\
    329          				xNextTaskUnblockTime = portMAX_DELAY;									\
    330          				break;																	\
    331          			}																			\
    332          			else																		\
    333          			{																			\
    334          				/* The delayed list is not empty, get the value of the item at			\
    335          				the head of the delayed list.  This is the time at which the			\
    336          				task at the head of the delayed list should be removed from				\
    337          				the Blocked state. */													\
    338          				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
    339          				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
    340          																						\
    341          				if( xTickCount < xItemValue )											\
    342          				{																		\
    343          					/* It is not time to unblock this item yet, but the item			\
    344          					value is the time at which the task at the head of the				\
    345          					blocked list should be removed from the Blocked state -				\
    346          					so record the item value in xNextTaskUnblockTime. */				\
    347          					xNextTaskUnblockTime = xItemValue;									\
    348          					break;																\
    349          				}																		\
    350          																						\
    351          				/* It is time to remove the item from the Blocked state. */				\
    352          				uxListRemove( &( pxTCB->xGenericListItem ) );							\
    353          																						\
    354          				/* Is the task waiting on an event also? */								\
    355          				if( pxTCB->xEventListItem.pvContainer != NULL )							\
    356          				{																		\
    357          					uxListRemove( &( pxTCB->xEventListItem ) );							\
    358          				}																		\
    359          				prvAddTaskToReadyQueue( pxTCB );										\
    360          			}																			\
    361          		}																				\
    362          	}																					\
    363          }
    364          /*-----------------------------------------------------------*/
    365          
    366          /*
    367           * Several functions take an xTaskHandle parameter that can optionally be NULL,
    368           * where NULL is used to indicate that the handle of the currently executing
    369           * task should be used in place of the parameter.  This macro simply checks to
    370           * see if the parameter is NULL and returns a pointer to the appropriate TCB.
    371           */
    372          #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( tskTCB * ) ( pxHandle ) )
    373          
    374          /* Callback function prototypes. --------------------------*/
    375          extern void vApplicationStackOverflowHook( xTaskHandle pxTask, signed char *pcTaskName );
    376          extern void vApplicationTickHook( void );
    377          
    378          /* File private functions. --------------------------------*/
    379          
    380          /*
    381           * Utility to ready a TCB for a given task.  Mainly just copies the parameters
    382           * into the TCB structure.
    383           */
    384          static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth ) PRIVILEGED_FUNCTION;
    385          
    386          /*
    387           * Utility to ready all the lists used by the scheduler.  This is called
    388           * automatically upon the creation of the first task.
    389           */
    390          static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
    391          
    392          /*
    393           * The idle task, which as all tasks is implemented as a never ending loop.
    394           * The idle task is automatically created and added to the ready lists upon
    395           * creation of the first user task.
    396           *
    397           * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
    398           * language extensions.  The equivalent prototype for this function is:
    399           *
    400           * void prvIdleTask( void *pvParameters );
    401           *
    402           */
    403          static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
    404          
    405          /*
    406           * Utility to free all memory allocated by the scheduler to hold a TCB,
    407           * including the stack pointed to by the TCB.
    408           *
    409           * This does not free memory allocated by the task itself (i.e. memory
    410           * allocated by calls to pvPortMalloc from within the tasks application code).
    411           */
    412          #if ( INCLUDE_vTaskDelete == 1 )
    413          
    414          	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
    415          
    416          #endif
    417          
    418          /*
    419           * Used only by the idle task.  This checks to see if anything has been placed
    420           * in the list of tasks waiting to be deleted.  If so the task is cleaned up
    421           * and its TCB deleted.
    422           */
    423          static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
    424          
    425          /*
    426           * The currently executing task is entering the Blocked state.  Add the task to
    427           * either the current or the overflow delayed task list.
    428           */
    429          static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
    430          
    431          /*
    432           * Allocates memory from the heap for a TCB and associated stack.  Checks the
    433           * allocation was successful.
    434           */
    435          static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer ) PRIVILEGED_FUNCTION;
    436          
    437          /*
    438           * Called from vTaskList.  vListTasks details all the tasks currently under
    439           * control of the scheduler.  The tasks may be in one of a number of lists.
    440           * prvListTaskWithinSingleList accepts a list and details the tasks from
    441           * within just that list.
    442           *
    443           * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
    444           * NORMAL APPLICATION CODE.
    445           */
    446          #if ( configUSE_TRACE_FACILITY == 1 )
    447          
    448          	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus ) PRIVILEGED_FUNCTION;
    449          
    450          #endif
    451          
    452          /*
    453           * When a task is created, the stack of the task is filled with a known value.
    454           * This function determines the 'high water mark' of the task stack by
    455           * determining how much of the stack remains at the original preset value.
    456           */
    457          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
    458          
    459          	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_FUNCTION;
    460          
    461          #endif
    462          
    463          /*
    464           * Return the amount of time, in ticks, that will pass before the kernel will
    465           * next move a task from the Blocked state to the Running state.
    466           *
    467           * This conditional compilation should use inequality to 0, not equality to 1.
    468           * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
    469           * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
    470           * set to a value other than 1.
    471           */
    472          #if ( configUSE_TICKLESS_IDLE != 0 )
    473          
    474          	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
    475          
    476          #endif
    477          
    478          /*lint +e956 */
    479          
    480          
    481          
    482          /*-----------------------------------------------------------
    483           * TASK CREATION API documented in task.h
    484           *----------------------------------------------------------*/
    485          
    486          signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
    487          {
    488          signed portBASE_TYPE xReturn;
    489          tskTCB * pxNewTCB;
    490          
    491          	configASSERT( pxTaskCode );
    492          	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
    493          
    494          	/* Allocate the memory required by the TCB and stack for the new task,
    495          	checking that the allocation was successful. */
    496          	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    497          
    498          	if( pxNewTCB != NULL )
    499          	{
    500          		portSTACK_TYPE *pxTopOfStack;
    501          
    502          		#if( portUSING_MPU_WRAPPERS == 1 )
    503          			/* Should the task be created in privileged mode? */
    504          			portBASE_TYPE xRunPrivileged;
    505          			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
    506          			{
    507          				xRunPrivileged = pdTRUE;
    508          			}
    509          			else
    510          			{
    511          				xRunPrivileged = pdFALSE;
    512          			}
    513          			uxPriority &= ~portPRIVILEGE_BIT;
    514          		#endif /* portUSING_MPU_WRAPPERS == 1 */
    515          
    516          		/* Calculate the top of stack address.  This depends on whether the
    517          		stack grows from high memory to low (as per the 80x86) or visa versa.
    518          		portSTACK_GROWTH is used to make the result positive or negative as
    519          		required by the port. */
    520          		#if( portSTACK_GROWTH < 0 )
    521          		{
    522          			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    523          			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
    524          
    525          			/* Check the alignment of the calculated top of stack is correct. */
    526          			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    527          		}
    528          		#else
    529          		{
    530          			pxTopOfStack = pxNewTCB->pxStack;
    531          
    532          			/* Check the alignment of the stack buffer is correct. */
    533          			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    534          
    535          			/* If we want to use stack checking on architectures that use
    536          			a positive stack growth direction then we also need to store the
    537          			other extreme of the stack space. */
    538          			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    539          		}
    540          		#endif
    541          
    542          		/* Setup the newly allocated TCB with the initial state of the task. */
    543          		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    544          
    545          		/* Initialize the TCB stack to look as if the task was already running,
    546          		but had been interrupted by the scheduler.  The return address is set
    547          		to the start of the task function. Once the stack has been initialised
    548          		the	top of stack variable is updated. */
    549          		#if( portUSING_MPU_WRAPPERS == 1 )
    550          		{
    551          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
    552          		}
    553          		#else
    554          		{
    555          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    556          		}
    557          		#endif
    558          
    559          		/* Check the alignment of the initialised stack. */
    560          		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    561          
    562          		if( ( void * ) pxCreatedTask != NULL )
    563          		{
    564          			/* Pass the TCB out - in an anonymous way.  The calling function/
    565          			task can use this as a handle to delete the task later if
    566          			required.*/
    567          			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    568          		}
    569          
    570          		/* We are going to manipulate the task queues to add this task to a
    571          		ready list, so must make sure no interrupts occur. */
    572          		taskENTER_CRITICAL();
    573          		{
    574          			uxCurrentNumberOfTasks++;
    575          			if( pxCurrentTCB == NULL )
    576          			{
    577          				/* There are no other tasks, or all the other tasks are in
    578          				the suspended state - make this the current task. */
    579          				pxCurrentTCB =  pxNewTCB;
    580          
    581          				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    582          				{
    583          					/* This is the first task to be created so do the preliminary
    584          					initialisation required.  We will not recover if this call
    585          					fails, but we will report the failure. */
    586          					prvInitialiseTaskLists();
    587          				}
    588          			}
    589          			else
    590          			{
    591          				/* If the scheduler is not already running, make this task the
    592          				current task if it is the highest priority task to be created
    593          				so far. */
    594          				if( xSchedulerRunning == pdFALSE )
    595          				{
    596          					if( pxCurrentTCB->uxPriority <= uxPriority )
    597          					{
    598          						pxCurrentTCB = pxNewTCB;
    599          					}
    600          				}
    601          			}
    602          
    603          			/* Remember the top priority to make context switching faster.  Use
    604          			the priority in pxNewTCB as this has been capped to a valid value. */
    605          			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    606          			{
    607          				uxTopUsedPriority = pxNewTCB->uxPriority;
    608          			}
    609          
    610          			#if ( configUSE_TRACE_FACILITY == 1 )
    611          			{
    612          				/* Add a counter into the TCB for tracing only. */
    613          				pxNewTCB->uxTCBNumber = uxTaskNumber;
    614          			}
    615          			#endif
    616          			uxTaskNumber++;
    617          
    618          			prvAddTaskToReadyQueue( pxNewTCB );
    619          
    620          			xReturn = pdPASS;
    621          			portSETUP_TCB( pxNewTCB );
    622          			traceTASK_CREATE( pxNewTCB );
    623          		}
    624          		taskEXIT_CRITICAL();
    625          	}
    626          	else
    627          	{
    628          		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    629          		traceTASK_CREATE_FAILED();
    630          	}
    631          
    632          	if( xReturn == pdPASS )
    633          	{
    634          		if( xSchedulerRunning != pdFALSE )
    635          		{
    636          			/* If the created task is of a higher priority than the current task
    637          			then it should run now. */
    638          			if( pxCurrentTCB->uxPriority < uxPriority )
    639          			{
    640          				portYIELD_WITHIN_API();
    641          			}
    642          		}
    643          	}
    644          
    645          	return xReturn;
    646          }
    647          /*-----------------------------------------------------------*/
    648          
    649          #if ( INCLUDE_vTaskDelete == 1 )
    650          
    651          	void vTaskDelete( xTaskHandle pxTaskToDelete )
    652          	{
    653          	tskTCB *pxTCB;
    654          
    655          		taskENTER_CRITICAL();
    656          		{
    657          			/* Ensure a yield is performed if the current task is being
    658          			deleted. */
    659          			if( pxTaskToDelete == pxCurrentTCB )
    660          			{
    661          				pxTaskToDelete = NULL;
    662          			}
    663          
    664          			/* If null is passed in here then we are deleting ourselves. */
    665          			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    666          
    667          			/* Remove task from the ready list and place in the	termination list.
    668          			This will stop the task from be scheduled.  The idle task will check
    669          			the termination list and free up any memory allocated by the
    670          			scheduler for the TCB and stack. */
    671          			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    672          			{
    673          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
    674          			}
    675          
    676          			/* Is the task waiting on an event also? */
    677          			if( pxTCB->xEventListItem.pvContainer != NULL )
    678          			{
    679          				uxListRemove( &( pxTCB->xEventListItem ) );
    680          			}
    681          
    682          			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    683          
    684          			/* Increment the ucTasksDeleted variable so the idle task knows
    685          			there is a task that has been deleted and that it should therefore
    686          			check the xTasksWaitingTermination list. */
    687          			++uxTasksDeleted;
    688          
    689          			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
    690          			can detect that the task lists need re-generating. */
    691          			uxTaskNumber++;
    692          
    693          			traceTASK_DELETE( pxTCB );
    694          		}
    695          		taskEXIT_CRITICAL();
    696          
    697          		/* Force a reschedule if we have just deleted the current task. */
    698          		if( xSchedulerRunning != pdFALSE )
    699          		{
    700          			if( ( void * ) pxTaskToDelete == NULL )
    701          			{
    702          				portYIELD_WITHIN_API();
    703          			}
    704          		}
    705          	}
    706          
    707          #endif
    708          
    709          
    710          
    711          
    712          
    713          
    714          /*-----------------------------------------------------------
    715           * TASK CONTROL API documented in task.h
    716           *----------------------------------------------------------*/
    717          
    718          #if ( INCLUDE_vTaskDelayUntil == 1 )
    719          
    720          	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
    721          	{
    722          	portTickType xTimeToWake;
    723          	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    724          
    725          		configASSERT( pxPreviousWakeTime );
    726          		configASSERT( ( xTimeIncrement > 0U ) );
    727          
    728          		vTaskSuspendAll();
    729          		{
    730          			/* Generate the tick time at which the task wants to wake. */
    731          			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    732          
    733          			if( xTickCount < *pxPreviousWakeTime )
    734          			{
    735          				/* The tick count has overflowed since this function was
    736          				lasted called.  In this case the only time we should ever
    737          				actually delay is if the wake time has also	overflowed,
    738          				and the wake time is greater than the tick time.  When this
    739          				is the case it is as if neither time had overflowed. */
    740          				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    741          				{
    742          					xShouldDelay = pdTRUE;
    743          				}
    744          			}
    745          			else
    746          			{
    747          				/* The tick time has not overflowed.  In this case we will
    748          				delay if either the wake time has overflowed, and/or the
    749          				tick time is less than the wake time. */
    750          				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    751          				{
    752          					xShouldDelay = pdTRUE;
    753          				}
    754          			}
    755          
    756          			/* Update the wake time ready for the next call. */
    757          			*pxPreviousWakeTime = xTimeToWake;
    758          
    759          			if( xShouldDelay != pdFALSE )
    760          			{
    761          				traceTASK_DELAY_UNTIL();
    762          
    763          				/* We must remove ourselves from the ready list before adding
    764          				ourselves to the blocked list as the same list item is used for
    765          				both lists. */
    766          				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    767          				{
    768          					/* The current task must be in a ready list, so there is
    769          					no need to check, and the port reset macro can be called
    770          					directly. */
    771          					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    772          				}
    773          
    774          				prvAddCurrentTaskToDelayedList( xTimeToWake );
    775          			}
    776          		}
    777          		xAlreadyYielded = xTaskResumeAll();
    778          
    779          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    780          		have put ourselves to sleep. */
    781          		if( xAlreadyYielded == pdFALSE )
    782          		{
    783          			portYIELD_WITHIN_API();
    784          		}
    785          	}
    786          
    787          #endif
    788          /*-----------------------------------------------------------*/
    789          
    790          #if ( INCLUDE_vTaskDelay == 1 )
    791          
    792          	void vTaskDelay( portTickType xTicksToDelay )
    793          	{
    794          	portTickType xTimeToWake;
    795          	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    796          
    797          		/* A delay time of zero just forces a reschedule. */
    798          		if( xTicksToDelay > ( portTickType ) 0U )
    799          		{
    800          			vTaskSuspendAll();
    801          			{
    802          				traceTASK_DELAY();
    803          
    804          				/* A task that is removed from the event list while the
    805          				scheduler is suspended will not get placed in the ready
    806          				list or removed from the blocked list until the scheduler
    807          				is resumed.
    808          
    809          				This task cannot be in an event list as it is the currently
    810          				executing task. */
    811          
    812          				/* Calculate the time to wake - this may overflow but this is
    813          				not a problem. */
    814          				xTimeToWake = xTickCount + xTicksToDelay;
    815          
    816          				/* We must remove ourselves from the ready list before adding
    817          				ourselves to the blocked list as the same list item is used for
    818          				both lists. */
    819          				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    820          				{
    821          					/* The current task must be in a ready list, so there is
    822          					no need to check, and the port reset macro can be called
    823          					directly. */
    824          					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    825          				}
    826          				prvAddCurrentTaskToDelayedList( xTimeToWake );
    827          			}
    828          			xAlreadyYielded = xTaskResumeAll();
    829          		}
    830          
    831          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    832          		have put ourselves to sleep. */
    833          		if( xAlreadyYielded == pdFALSE )
    834          		{
    835          			portYIELD_WITHIN_API();
    836          		}
    837          	}
    838          
    839          #endif
    840          /*-----------------------------------------------------------*/
    841          
    842          #if ( INCLUDE_eTaskStateGet == 1 )
    843          
    844          	eTaskState eTaskStateGet( xTaskHandle pxTask )
    845          	{
    846          	eTaskState eReturn;
    847          	xList *pxStateList;
    848          	tskTCB *pxTCB;
    849          
    850          		pxTCB = ( tskTCB * ) pxTask;
    851          
    852          		if( pxTCB == pxCurrentTCB )
    853          		{
    854          			/* The task calling this function is querying its own state. */
    855          			eReturn = eRunning;
    856          		}
    857          		else
    858          		{
    859          			taskENTER_CRITICAL();
    860          			{
    861          				pxStateList = ( xList * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
    862          			}
    863          			taskEXIT_CRITICAL();
    864          
    865          			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
    866          			{
    867          				/* The task being queried is referenced from one of the Blocked
    868          				lists. */
    869          				eReturn = eBlocked;
    870          			}
    871          
    872          			#if ( INCLUDE_vTaskSuspend == 1 )
    873          				else if( pxStateList == &xSuspendedTaskList )
    874          				{
    875          					/* The task being queried is referenced from the suspended
    876          					list. */
    877          					eReturn = eSuspended;
    878          				}
    879          			#endif
    880          
    881          			#if ( INCLUDE_vTaskDelete == 1 )
    882          				else if( pxStateList == &xTasksWaitingTermination )
    883          				{
    884          					/* The task being queried is referenced from the deleted
    885          					tasks list. */
    886          					eReturn = eDeleted;
    887          				}
    888          			#endif
    889          
    890          			else
    891          			{
    892          				/* If the task is not in any other state, it must be in the
    893          				Ready (including pending ready) state. */
    894          				eReturn = eReady;
    895          			}
    896          		}
    897          
    898          		return eReturn;
    899          	}
    900          
    901          #endif
    902          /*-----------------------------------------------------------*/
    903          
    904          #if ( INCLUDE_uxTaskPriorityGet == 1 )
    905          
    906          	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
    907          	{
    908          	tskTCB *pxTCB;
    909          	unsigned portBASE_TYPE uxReturn;
    910          
    911          		taskENTER_CRITICAL();
    912          		{
    913          			/* If null is passed in here then we are changing the
    914          			priority of the calling function. */
    915          			pxTCB = prvGetTCBFromHandle( pxTask );
    916          			uxReturn = pxTCB->uxPriority;
    917          		}
    918          		taskEXIT_CRITICAL();
    919          
    920          		return uxReturn;
    921          	}
    922          
    923          #endif
    924          /*-----------------------------------------------------------*/
    925          
    926          #if ( INCLUDE_vTaskPrioritySet == 1 )
    927          
    928          	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
    929          	{
    930          	tskTCB *pxTCB;
    931          	unsigned portBASE_TYPE uxCurrentPriority, uxPriorityUsedOnEntry;
    932          	portBASE_TYPE xYieldRequired = pdFALSE;
    933          
    934          		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
    935          
    936          		/* Ensure the new priority is valid. */
    937          		if( uxNewPriority >= configMAX_PRIORITIES )
    938          		{
    939          			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    940          		}
    941          
    942          		taskENTER_CRITICAL();
    943          		{
    944          			if( pxTask == pxCurrentTCB )
    945          			{
    946          				pxTask = NULL;
    947          			}
    948          
    949          			/* If null is passed in here then we are changing the
    950          			priority of the calling function. */
    951          			pxTCB = prvGetTCBFromHandle( pxTask );
    952          
    953          			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
    954          
    955          			#if ( configUSE_MUTEXES == 1 )
    956          			{
    957          				uxCurrentPriority = pxTCB->uxBasePriority;
    958          			}
    959          			#else
    960          			{
    961          				uxCurrentPriority = pxTCB->uxPriority;
    962          			}
    963          			#endif
    964          
    965          			if( uxCurrentPriority != uxNewPriority )
    966          			{
    967          				/* The priority change may have readied a task of higher
    968          				priority than the calling task. */
    969          				if( uxNewPriority > uxCurrentPriority )
    970          				{
    971          					if( pxTask != NULL )
    972          					{
    973          						/* The priority of another task is being raised.  If we
    974          						were raising the priority of the currently running task
    975          						there would be no need to switch as it must have already
    976          						been the highest priority task. */
    977          						xYieldRequired = pdTRUE;
    978          					}
    979          				}
    980          				else if( pxTask == NULL )
    981          				{
    982          					/* Setting our own priority down means there may now be another
    983          					task of higher priority that is ready to execute. */
    984          					xYieldRequired = pdTRUE;
    985          				}
    986          
    987          				/* Remember the ready list the task might be referenced from
    988          				before its uxPriority member is changed so the
    989          				taskRESET_READY_PRIORITY() macro can function correctly. */
    990          				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    991          
    992          				#if ( configUSE_MUTEXES == 1 )
    993          				{
    994          					/* Only change the priority being used if the task is not
    995          					currently using an inherited priority. */
    996          					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    997          					{
    998          						pxTCB->uxPriority = uxNewPriority;
    999          					}
   1000          
   1001          					/* The base priority gets set whatever. */
   1002          					pxTCB->uxBasePriority = uxNewPriority;
   1003          				}
   1004          				#else
   1005          				{
   1006          					pxTCB->uxPriority = uxNewPriority;
   1007          				}
   1008          				#endif
   1009          
   1010          				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
   1011          
   1012          				/* If the task is in the blocked or suspended list we need do
   1013          				nothing more than change it's priority variable. However, if
   1014          				the task is in a ready list it needs to be removed and placed
   1015          				in the queue appropriate to its new priority. */
   1016          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
   1017          				{
   1018          					/* The task is currently in its ready list - remove before adding
   1019          					it to it's new ready list.  As we are in a critical section we
   1020          					can do this even if the scheduler is suspended. */
   1021          					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
   1022          					{
   1023          						taskRESET_READY_PRIORITY( uxPriorityUsedOnEntry );
   1024          					}
   1025          					prvAddTaskToReadyQueue( pxTCB );
   1026          				}
   1027          
   1028          				if( xYieldRequired == pdTRUE )
   1029          				{
   1030          					portYIELD_WITHIN_API();
   1031          				}
   1032          			}
   1033          		}
   1034          		taskEXIT_CRITICAL();
   1035          
   1036          		/* Remove compiler warning about unused parameter when the port
   1037          		optimised task selection is not being used. */
   1038          		( void ) uxPriorityUsedOnEntry;
   1039          	}
   1040          
   1041          #endif
   1042          /*-----------------------------------------------------------*/
   1043          
   1044          #if ( INCLUDE_vTaskSuspend == 1 )
   1045          
   1046          	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
   1047          	{
   1048          	tskTCB *pxTCB;
   1049          
   1050          		taskENTER_CRITICAL();
   1051          		{
   1052          			/* Ensure a yield is performed if the current task is being
   1053          			suspended. */
   1054          			if( pxTaskToSuspend == pxCurrentTCB )
   1055          			{
   1056          				pxTaskToSuspend = NULL;
   1057          			}
   1058          
   1059          			/* If null is passed in here then we are suspending ourselves. */
   1060          			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
   1061          
   1062          			traceTASK_SUSPEND( pxTCB );
   1063          
   1064          			/* Remove task from the ready/delayed list and place in the	suspended list. */
   1065          			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
   1066          			{
   1067          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1068          			}
   1069          
   1070          			/* Is the task waiting on an event also? */
   1071          			if( pxTCB->xEventListItem.pvContainer != NULL )
   1072          			{
   1073          				uxListRemove( &( pxTCB->xEventListItem ) );
   1074          			}
   1075          
   1076          			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
   1077          		}
   1078          		taskEXIT_CRITICAL();
   1079          
   1080          		if( ( void * ) pxTaskToSuspend == NULL )
   1081          		{
   1082          			if( xSchedulerRunning != pdFALSE )
   1083          			{
   1084          				/* We have just suspended the current task. */
   1085          				portYIELD_WITHIN_API();
   1086          			}
   1087          			else
   1088          			{
   1089          				/* The scheduler is not running, but the task that was pointed
   1090          				to by pxCurrentTCB has just been suspended and pxCurrentTCB
   1091          				must be adjusted to point to a different task. */
   1092          				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
   1093          				{
   1094          					/* No other tasks are ready, so set pxCurrentTCB back to
   1095          					NULL so when the next task is created pxCurrentTCB will
   1096          					be set to point to it no matter what its relative priority
   1097          					is. */
   1098          					pxCurrentTCB = NULL;
   1099          				}
   1100          				else
   1101          				{
   1102          					vTaskSwitchContext();
   1103          				}
   1104          			}
   1105          		}
   1106          	}
   1107          
   1108          #endif
   1109          /*-----------------------------------------------------------*/
   1110          
   1111          #if ( INCLUDE_vTaskSuspend == 1 )
   1112          
   1113          	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
   1114          	{
   1115          	portBASE_TYPE xReturn = pdFALSE;
   1116          	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
   1117          
   1118          		/* It does not make sense to check if the calling task is suspended. */
   1119          		configASSERT( xTask );
   1120          
   1121          		/* Is the task we are attempting to resume actually in the
   1122          		suspended list? */
   1123          		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
   1124          		{
   1125          			/* Has the task already been resumed from within an ISR? */
   1126          			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
   1127          			{
   1128          				/* Is it in the suspended list because it is in the
   1129          				Suspended state?  It is possible to be in the suspended
   1130          				list because it is blocked on a task with no timeout
   1131          				specified. */
   1132          				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
   1133          				{
   1134          					xReturn = pdTRUE;
   1135          				}
   1136          			}
   1137          		}
   1138          
   1139          		return xReturn;
   1140          	}
   1141          
   1142          #endif
   1143          /*-----------------------------------------------------------*/
   1144          
   1145          #if ( INCLUDE_vTaskSuspend == 1 )
   1146          
   1147          	void vTaskResume( xTaskHandle pxTaskToResume )
   1148          	{
   1149          	tskTCB *pxTCB;
   1150          
   1151          		/* It does not make sense to resume the calling task. */
   1152          		configASSERT( pxTaskToResume );
   1153          
   1154          		/* Remove the task from whichever list it is currently in, and place
   1155          		it in the ready list. */
   1156          		pxTCB = ( tskTCB * ) pxTaskToResume;
   1157          
   1158          		/* The parameter cannot be NULL as it is impossible to resume the
   1159          		currently executing task. */
   1160          		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
   1161          		{
   1162          			taskENTER_CRITICAL();
   1163          			{
   1164          				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   1165          				{
   1166          					traceTASK_RESUME( pxTCB );
   1167          
   1168          					/* As we are in a critical section we can access the ready
   1169          					lists even if the scheduler is suspended. */
   1170          					uxListRemove(  &( pxTCB->xGenericListItem ) );
   1171          					prvAddTaskToReadyQueue( pxTCB );
   1172          
   1173          					/* We may have just resumed a higher priority task. */
   1174          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1175          					{
   1176          						/* This yield may not cause the task just resumed to run, but
   1177          						will leave the lists in the correct state for the next yield. */
   1178          						portYIELD_WITHIN_API();
   1179          					}
   1180          				}
   1181          			}
   1182          			taskEXIT_CRITICAL();
   1183          		}
   1184          	}
   1185          
   1186          #endif
   1187          
   1188          /*-----------------------------------------------------------*/
   1189          
   1190          #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
   1191          
   1192          	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
   1193          	{
   1194          	portBASE_TYPE xYieldRequired = pdFALSE;
   1195          	tskTCB *pxTCB;
   1196          	unsigned portBASE_TYPE uxSavedInterruptStatus;
   1197          
   1198          		configASSERT( pxTaskToResume );
   1199          
   1200          		pxTCB = ( tskTCB * ) pxTaskToResume;
   1201          
   1202          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   1203          		{
   1204          			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   1205          			{
   1206          				traceTASK_RESUME_FROM_ISR( pxTCB );
   1207          
   1208          				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   1209          				{
   1210          					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
   1211          					uxListRemove(  &( pxTCB->xGenericListItem ) );
   1212          					prvAddTaskToReadyQueue( pxTCB );
   1213          				}
   1214          				else
   1215          				{
   1216          					/* We cannot access the delayed or ready lists, so will hold this
   1217          					task pending until the scheduler is resumed, at which point a
   1218          					yield will be performed if necessary. */
   1219          					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   1220          				}
   1221          			}
   1222          		}
   1223          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   1224          
   1225          		return xYieldRequired;
   1226          	}
   1227          
   1228          #endif
   1229          
   1230          
   1231          
   1232          
   1233          /*-----------------------------------------------------------
   1234           * PUBLIC SCHEDULER CONTROL documented in task.h
   1235           *----------------------------------------------------------*/
   1236          
   1237          
   1238          void vTaskStartScheduler( void )
   1239          {
   1240          portBASE_TYPE xReturn;
   1241          
   1242          	/* Add the idle task at the lowest priority. */
   1243          	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   1244          	{
   1245          		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
   1246          		be returned by the xTaskGetIdleTaskHandle() function. */
   1247          		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
   1248          	}
   1249          	#else
   1250          	{
   1251          		/* Create the idle task without storing its handle. */
   1252          		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
   1253          	}
   1254          	#endif
   1255          
   1256          	#if ( configUSE_TIMERS == 1 )
   1257          	{
   1258          		if( xReturn == pdPASS )
   1259          		{
   1260          			xReturn = xTimerCreateTimerTask();
   1261          		}
   1262          	}
   1263          	#endif
   1264          
   1265          	if( xReturn == pdPASS )
   1266          	{
   1267          		/* Interrupts are turned off here, to ensure a tick does not occur
   1268          		before or during the call to xPortStartScheduler().  The stacks of
   1269          		the created tasks contain a status word with interrupts switched on
   1270          		so interrupts will automatically get re-enabled when the first task
   1271          		starts to run.
   1272          
   1273          		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
   1274          		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
   1275          		portDISABLE_INTERRUPTS();
   1276          
   1277          		xSchedulerRunning = pdTRUE;
   1278          		xTickCount = ( portTickType ) 0U;
   1279          
   1280          		/* If configGENERATE_RUN_TIME_STATS is defined then the following
   1281          		macro must be defined to configure the timer/counter used to generate
   1282          		the run time counter time base. */
   1283          		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   1284          
   1285          		/* Setting up the timer tick is hardware specific and thus in the
   1286          		portable interface. */
   1287          		if( xPortStartScheduler() != pdFALSE )
   1288          		{
   1289          			/* Should not reach here as if the scheduler is running the
   1290          			function will not return. */
   1291          		}
   1292          		else
   1293          		{
   1294          			/* Should only reach here if a task calls xTaskEndScheduler(). */
   1295          		}
   1296          	}
   1297          
   1298          	/* This line will only be reached if the kernel could not be started. */
   1299          	configASSERT( xReturn );
   1300          }
   1301          /*-----------------------------------------------------------*/
   1302          
   1303          void vTaskEndScheduler( void )
   1304          {
   1305          	/* Stop the scheduler interrupts and call the portable scheduler end
   1306          	routine so the original ISRs can be restored if necessary.  The port
   1307          	layer must ensure interrupts enable	bit is left in the correct state. */
   1308          	portDISABLE_INTERRUPTS();
   1309          	xSchedulerRunning = pdFALSE;
   1310          	vPortEndScheduler();
   1311          }
   1312          /*----------------------------------------------------------*/
   1313          
   1314          void vTaskSuspendAll( void )
   1315          {
   1316          	/* A critical section is not required as the variable is of type
   1317          	portBASE_TYPE. */
   1318          	++uxSchedulerSuspended;
   1319          }
   1320          /*----------------------------------------------------------*/
   1321          
   1322          #if ( configUSE_TICKLESS_IDLE != 0 )
   1323          
   1324          	portTickType prvGetExpectedIdleTime( void )
   1325          	{
   1326          	portTickType xReturn;
   1327          	
   1328          		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
   1329          		{
   1330          			xReturn = 0;
   1331          		}
   1332          		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
   1333          		{
   1334          			/* There are other idle priority tasks in the ready state.  If
   1335          			time slicing is used then the very next tick interrupt must be
   1336          			processed. */
   1337          			xReturn = 0;
   1338          		}
   1339          		else
   1340          		{
   1341          			xReturn = xNextTaskUnblockTime - xTickCount;
   1342          		}
   1343          	
   1344          		return xReturn;
   1345          	}
   1346          
   1347          #endif /* configUSE_TICKLESS_IDLE != 0  */
   1348          /*----------------------------------------------------------*/
   1349          
   1350          signed portBASE_TYPE xTaskResumeAll( void )
   1351          {
   1352          register tskTCB *pxTCB;
   1353          signed portBASE_TYPE xAlreadyYielded = pdFALSE;
   1354          
   1355          	/* If uxSchedulerSuspended is zero then this function does not match a
   1356          	previous call to vTaskSuspendAll(). */
   1357          	configASSERT( uxSchedulerSuspended );
   1358          
   1359          	/* It is possible that an ISR caused a task to be removed from an event
   1360          	list while the scheduler was suspended.  If this was the case then the
   1361          	removed task will have been added to the xPendingReadyList.  Once the
   1362          	scheduler has been resumed it is safe to move all the pending ready
   1363          	tasks from this list into their appropriate ready list. */
   1364          	taskENTER_CRITICAL();
   1365          	{
   1366          		--uxSchedulerSuspended;
   1367          
   1368          		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   1369          		{
   1370          			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
   1371          			{
   1372          				portBASE_TYPE xYieldRequired = pdFALSE;
   1373          
   1374          				/* Move any readied tasks from the pending list into the
   1375          				appropriate ready list. */
   1376          				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
   1377          				{
   1378          					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
   1379          					uxListRemove( &( pxTCB->xEventListItem ) );
   1380          					uxListRemove( &( pxTCB->xGenericListItem ) );
   1381          					prvAddTaskToReadyQueue( pxTCB );
   1382          
   1383          					/* If we have moved a task that has a priority higher than
   1384          					the current task then we should yield. */
   1385          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1386          					{
   1387          						xYieldRequired = pdTRUE;
   1388          					}
   1389          				}
   1390          
   1391          				/* If any ticks occurred while the scheduler was suspended then
   1392          				they should be processed now.  This ensures the tick count does not
   1393          				slip, and that any delayed tasks are resumed at the correct time. */
   1394          				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
   1395          				{
   1396          					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
   1397          					{
   1398          						vTaskIncrementTick();
   1399          						--uxMissedTicks;
   1400          					}
   1401          
   1402          					/* As we have processed some ticks it is appropriate to yield
   1403          					to ensure the highest priority task that is ready to run is
   1404          					the task actually running. */
   1405          					#if configUSE_PREEMPTION == 1
   1406          					{
   1407          						xYieldRequired = pdTRUE;
   1408          					}
   1409          					#endif
   1410          				}
   1411          
   1412          				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
   1413          				{
   1414          					xAlreadyYielded = pdTRUE;
   1415          					xMissedYield = pdFALSE;
   1416          					portYIELD_WITHIN_API();
   1417          				}
   1418          			}
   1419          		}
   1420          	}
   1421          	taskEXIT_CRITICAL();
   1422          
   1423          	return xAlreadyYielded;
   1424          }
   1425          
   1426          
   1427          
   1428          
   1429          
   1430          
   1431          /*-----------------------------------------------------------
   1432           * PUBLIC TASK UTILITIES documented in task.h
   1433           *----------------------------------------------------------*/
   1434          
   1435          
   1436          
   1437          portTickType xTaskGetTickCount( void )
   1438          {
   1439          portTickType xTicks;
   1440          
   1441          	/* Critical section required if running on a 16 bit processor. */
   1442          	taskENTER_CRITICAL();
   1443          	{
   1444          		xTicks = xTickCount;
   1445          	}
   1446          	taskEXIT_CRITICAL();
   1447          
   1448          	return xTicks;
   1449          }
   1450          /*-----------------------------------------------------------*/
   1451          
   1452          portTickType xTaskGetTickCountFromISR( void )
   1453          {
   1454          portTickType xReturn;
   1455          unsigned portBASE_TYPE uxSavedInterruptStatus;
   1456          
   1457          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   1458          	xReturn = xTickCount;
   1459          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   1460          
   1461          	return xReturn;
   1462          }
   1463          /*-----------------------------------------------------------*/
   1464          
   1465          unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
   1466          {
   1467          	/* A critical section is not required because the variables are of type
   1468          	portBASE_TYPE. */
   1469          	return uxCurrentNumberOfTasks;
   1470          }
   1471          /*-----------------------------------------------------------*/
   1472          
   1473          #if ( INCLUDE_pcTaskGetTaskName == 1 )
   1474          
   1475          	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
   1476          	{
   1477          	tskTCB *pxTCB;
   1478          
   1479          		/* If null is passed in here then the name of the calling task is being queried. */
   1480          		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   1481          		configASSERT( pxTCB );
   1482          		return &( pxTCB->pcTaskName[ 0 ] );
   1483          	}
   1484          
   1485          #endif
   1486          /*-----------------------------------------------------------*/
   1487          
   1488          #if ( configUSE_TRACE_FACILITY == 1 )
   1489          
   1490          	void vTaskList( signed char *pcWriteBuffer )
   1491          	{
   1492          	unsigned portBASE_TYPE uxQueue;
   1493          
   1494          		/* This is a VERY costly function that should be used for debug only.
   1495          		It leaves interrupts disabled for a LONG time. */
   1496          
   1497          		vTaskSuspendAll();
   1498          		{
   1499          			/* Run through all the lists that could potentially contain a TCB and
   1500          			report the task name, state and stack high water mark. */
   1501          
   1502          			*pcWriteBuffer = ( signed char ) 0x00;
   1503          			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
   1504          
   1505          			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
   1506          
   1507          			do
   1508          			{
   1509          				uxQueue--;
   1510          
   1511          				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
   1512          				{
   1513          					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
   1514          				}
   1515          			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
   1516          
   1517          			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
   1518          			{
   1519          				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
   1520          			}
   1521          
   1522          			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
   1523          			{
   1524          				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
   1525          			}
   1526          
   1527          			#if( INCLUDE_vTaskDelete == 1 )
   1528          			{
   1529          				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
   1530          				{
   1531          					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
   1532          				}
   1533          			}
   1534          			#endif
   1535          
   1536          			#if ( INCLUDE_vTaskSuspend == 1 )
   1537          			{
   1538          				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
   1539          				{
   1540          					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
   1541          				}
   1542          			}
   1543          			#endif
   1544          		}
   1545          		xTaskResumeAll();
   1546          	}
   1547          
   1548          #endif
   1549          /*----------------------------------------------------------*/
   1550          
   1551          #if ( configGENERATE_RUN_TIME_STATS == 1 )
   1552          
   1553          	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
   1554          	{
   1555          	unsigned portBASE_TYPE uxQueue;
   1556          	unsigned long ulTotalRunTime;
   1557          
   1558          		/* This is a VERY costly function that should be used for debug only.
   1559          		It leaves interrupts disabled for a LONG time. */
   1560          
   1561          		vTaskSuspendAll();
   1562          		{
   1563          			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   1564          				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
   1565          			#else
   1566          				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   1567          			#endif
   1568          
   1569          			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
   1570          			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
   1571          			ulTotalRunTime /= 100UL;
   1572          
   1573          			/* Run through all the lists that could potentially contain a TCB,
   1574          			generating a table of run timer percentages in the provided
   1575          			buffer. */
   1576          
   1577          			*pcWriteBuffer = ( signed char ) 0x00;
   1578          			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
   1579          
   1580          			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
   1581          
   1582          			do
   1583          			{
   1584          				uxQueue--;
   1585          
   1586          				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
   1587          				{
   1588          					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), ulTotalRunTime );
   1589          				}
   1590          			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
   1591          
   1592          			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
   1593          			{
   1594          				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRunTime );
   1595          			}
   1596          
   1597          			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
   1598          			{
   1599          				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ulTotalRunTime );
   1600          			}
   1601          
   1602          			#if ( INCLUDE_vTaskDelete == 1 )
   1603          			{
   1604          				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
   1605          				{
   1606          					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTime );
   1607          				}
   1608          			}
   1609          			#endif
   1610          
   1611          			#if ( INCLUDE_vTaskSuspend == 1 )
   1612          			{
   1613          				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
   1614          				{
   1615          					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime );
   1616          				}
   1617          			}
   1618          			#endif
   1619          		}
   1620          		xTaskResumeAll();
   1621          	}
   1622          
   1623          #endif
   1624          /*----------------------------------------------------------*/
   1625          
   1626          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   1627          
   1628          	xTaskHandle xTaskGetIdleTaskHandle( void )
   1629          	{
   1630          		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
   1631          		started, then xIdleTaskHandle will be NULL. */
   1632          		configASSERT( ( xIdleTaskHandle != NULL ) );
   1633          		return xIdleTaskHandle;
   1634          	}
   1635          
   1636          #endif
   1637          /*----------------------------------------------------------*/
   1638          
   1639          /* This conditional compilation should use inequality to 0, not equality to 1.
   1640          This is to ensure vTaskStepTick() is available when user defined low power mode	
   1641          implementations require configUSE_TICKLESS_IDLE to be set to a value other than
   1642          1. */
   1643          #if ( configUSE_TICKLESS_IDLE != 0 )
   1644          
   1645          	void vTaskStepTick( portTickType xTicksToJump )
   1646          	{
   1647          		configASSERT( xTicksToJump <= xNextTaskUnblockTime );
   1648          		xTickCount += xTicksToJump;
   1649          	}
   1650          
   1651          #endif
   1652          
   1653          /*-----------------------------------------------------------
   1654           * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
   1655           * documented in task.h
   1656           *----------------------------------------------------------*/
   1657          
   1658          void vTaskIncrementTick( void )
   1659          {
   1660          tskTCB * pxTCB;
   1661          
   1662          	/* Called by the portable layer each time a tick interrupt occurs.
   1663          	Increments the tick then checks to see if the new tick value will cause any
   1664          	tasks to be unblocked. */
   1665          	traceTASK_INCREMENT_TICK( xTickCount );
   1666          	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   1667          	{
   1668          		++xTickCount;
   1669          		if( xTickCount == ( portTickType ) 0U )
   1670          		{
   1671          			xList *pxTemp;
   1672          
   1673          			/* Tick count has overflowed so we need to swap the delay lists.
   1674          			If there are any items in pxDelayedTaskList here then there is
   1675          			an error! */
   1676          			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
   1677          
   1678          			pxTemp = pxDelayedTaskList;
   1679          			pxDelayedTaskList = pxOverflowDelayedTaskList;
   1680          			pxOverflowDelayedTaskList = pxTemp;
   1681          			xNumOfOverflows++;
   1682          
   1683          			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   1684          			{
   1685          				/* The new current delayed list is empty.  Set
   1686          				xNextTaskUnblockTime to the maximum possible value so it is
   1687          				extremely unlikely that the
   1688          				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
   1689          				there is an item in the delayed list. */
   1690          				xNextTaskUnblockTime = portMAX_DELAY;
   1691          			}
   1692          			else
   1693          			{
   1694          				/* The new current delayed list is not empty, get the value of
   1695          				the item at the head of the delayed list.  This is the time at
   1696          				which the task at the head of the delayed list should be removed
   1697          				from the Blocked state. */
   1698          				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   1699          				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
   1700          			}
   1701          		}
   1702          
   1703          		/* See if this tick has made a timeout expire. */
   1704          		prvCheckDelayedTasks();
   1705          	}
   1706          	else
   1707          	{
   1708          		++uxMissedTicks;
   1709          
   1710          		/* The tick hook gets called at regular intervals, even if the
   1711          		scheduler is locked. */
   1712          		#if ( configUSE_TICK_HOOK == 1 )
   1713          		{
   1714          			vApplicationTickHook();
   1715          		}
   1716          		#endif
   1717          	}
   1718          
   1719          	#if ( configUSE_TICK_HOOK == 1 )
   1720          	{
   1721          		/* Guard against the tick hook being called when the missed tick
   1722          		count is being unwound (when the scheduler is being unlocked. */
   1723          		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
   1724          		{
   1725          			vApplicationTickHook();
   1726          		}
   1727          	}
   1728          	#endif
   1729          }
   1730          /*-----------------------------------------------------------*/
   1731          
   1732          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   1733          
   1734          	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
   1735          	{
   1736          	tskTCB *xTCB;
   1737          
   1738          		/* If xTask is NULL then we are setting our own task hook. */
   1739          		if( xTask == NULL )
   1740          		{
   1741          			xTCB = ( tskTCB * ) pxCurrentTCB;
   1742          		}
   1743          		else
   1744          		{
   1745          			xTCB = ( tskTCB * ) xTask;
   1746          		}
   1747          
   1748          		/* Save the hook function in the TCB.  A critical section is required as
   1749          		the value can be accessed from an interrupt. */
   1750          		taskENTER_CRITICAL();
   1751          			xTCB->pxTaskTag = pxHookFunction;
   1752          		taskEXIT_CRITICAL();
   1753          	}
   1754          
   1755          #endif
   1756          /*-----------------------------------------------------------*/
   1757          
   1758          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   1759          
   1760          	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
   1761          	{
   1762          	tskTCB *xTCB;
   1763          	pdTASK_HOOK_CODE xReturn;
   1764          
   1765          		/* If xTask is NULL then we are setting our own task hook. */
   1766          		if( xTask == NULL )
   1767          		{
   1768          			xTCB = ( tskTCB * ) pxCurrentTCB;
   1769          		}
   1770          		else
   1771          		{
   1772          			xTCB = ( tskTCB * ) xTask;
   1773          		}
   1774          
   1775          		/* Save the hook function in the TCB.  A critical section is required as
   1776          		the value can be accessed from an interrupt. */
   1777          		taskENTER_CRITICAL();
   1778          			xReturn = xTCB->pxTaskTag;
   1779          		taskEXIT_CRITICAL();
   1780          
   1781          		return xReturn;
   1782          	}
   1783          
   1784          #endif
   1785          /*-----------------------------------------------------------*/
   1786          
   1787          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   1788          
   1789          	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
   1790          	{
   1791          	tskTCB *xTCB;
   1792          	portBASE_TYPE xReturn;
   1793          
   1794          		/* If xTask is NULL then we are calling our own task hook. */
   1795          		if( xTask == NULL )
   1796          		{
   1797          			xTCB = ( tskTCB * ) pxCurrentTCB;
   1798          		}
   1799          		else
   1800          		{
   1801          			xTCB = ( tskTCB * ) xTask;
   1802          		}
   1803          
   1804          		if( xTCB->pxTaskTag != NULL )
   1805          		{
   1806          			xReturn = xTCB->pxTaskTag( pvParameter );
   1807          		}
   1808          		else
   1809          		{
   1810          			xReturn = pdFAIL;
   1811          		}
   1812          
   1813          		return xReturn;
   1814          	}
   1815          
   1816          #endif
   1817          /*-----------------------------------------------------------*/
   1818          
   1819          void vTaskSwitchContext( void )
   1820          {
   1821          	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
   1822          	{
   1823          		/* The scheduler is currently suspended - do not allow a context
   1824          		switch. */
   1825          		xMissedYield = pdTRUE;
   1826          	}
   1827          	else
   1828          	{
   1829          		traceTASK_SWITCHED_OUT();
   1830          
   1831          		#if ( configGENERATE_RUN_TIME_STATS == 1 )
   1832          		{
   1833          			unsigned long ulTempCounter;
   1834          
   1835          				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   1836          					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
   1837          				#else
   1838          					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
   1839          				#endif
   1840          
   1841          				/* Add the amount of time the task has been running to the accumulated
   1842          				time so far.  The time the task started running was stored in
   1843          				ulTaskSwitchedInTime.  Note that there is no overflow protection here
   1844          				so count values are only valid until the timer overflows.  Generally
   1845          				this will be about 1 hour assuming a 1uS timer increment. */
   1846          				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
   1847          				ulTaskSwitchedInTime = ulTempCounter;
   1848          		}
   1849          		#endif
   1850          
   1851          		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
   1852          		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
   1853          
   1854          		taskSELECT_HIGHEST_PRIORITY_TASK();
   1855          
   1856          		traceTASK_SWITCHED_IN();
   1857          	}
   1858          }
   1859          /*-----------------------------------------------------------*/
   1860          
   1861          void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
   1862          {
   1863          portTickType xTimeToWake;
   1864          
   1865          	configASSERT( pxEventList );
   1866          
   1867          	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
   1868          	SCHEDULER SUSPENDED. */
   1869          
   1870          	/* Place the event list item of the TCB in the appropriate event list.
   1871          	This is placed in the list in priority order so the highest priority task
   1872          	is the first to be woken by the event. */
   1873          	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
   1874          
   1875          	/* We must remove ourselves from the ready list before adding ourselves
   1876          	to the blocked list as the same list item is used for both lists.  We have
   1877          	exclusive access to the ready lists as the scheduler is locked. */
   1878          	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
   1879          	{
   1880          		/* The current task must be in a ready list, so there is no need to
   1881          		check, and the port reset macro can be called directly. */
   1882          		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   1883          	}
   1884          
   1885          	#if ( INCLUDE_vTaskSuspend == 1 )
   1886          	{
   1887          		if( xTicksToWait == portMAX_DELAY )
   1888          		{
   1889          			/* Add ourselves to the suspended task list instead of a delayed task
   1890          			list to ensure we are not woken by a timing event.  We will block
   1891          			indefinitely. */
   1892          			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   1893          		}
   1894          		else
   1895          		{
   1896          			/* Calculate the time at which the task should be woken if the event does
   1897          			not occur.  This may overflow but this doesn't matter. */
   1898          			xTimeToWake = xTickCount + xTicksToWait;
   1899          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   1900          		}
   1901          	}
   1902          	#else
   1903          	{
   1904          			/* Calculate the time at which the task should be woken if the event does
   1905          			not occur.  This may overflow but this doesn't matter. */
   1906          			xTimeToWake = xTickCount + xTicksToWait;
   1907          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   1908          	}
   1909          	#endif
   1910          }
   1911          /*-----------------------------------------------------------*/
   1912          
   1913          #if configUSE_TIMERS == 1
   1914          
   1915          	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
   1916          	{
   1917          	portTickType xTimeToWake;
   1918          
   1919          		configASSERT( pxEventList );
   1920          
   1921          		/* This function should not be called by application code hence the
   1922          		'Restricted' in its name.  It is not part of the public API.  It is
   1923          		designed for use by kernel code, and has special calling requirements -
   1924          		it should be called from a critical section. */
   1925          
   1926          
   1927          		/* Place the event list item of the TCB in the appropriate event list.
   1928          		In this case it is assume that this is the only task that is going to
   1929          		be waiting on this event list, so the faster vListInsertEnd() function
   1930          		can be used in place of vListInsert. */
   1931          		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
   1932          
   1933          		/* We must remove this task from the ready list before adding it to the
   1934          		blocked list as the same list item is used for both lists.  This
   1935          		function is called form a critical section. */
   1936          		if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
   1937          		{
   1938          			/* The current task must be in a ready list, so there is no need to
   1939          			check, and the port reset macro can be called directly. */
   1940          			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   1941          		}
   1942          
   1943          		/* Calculate the time at which the task should be woken if the event does
   1944          		not occur.  This may overflow but this doesn't matter. */
   1945          		xTimeToWake = xTickCount + xTicksToWait;
   1946          		
   1947          		traceTASK_DELAY_UNTIL();
   1948          		prvAddCurrentTaskToDelayedList( xTimeToWake );
   1949          	}
   1950          
   1951          #endif /* configUSE_TIMERS */
   1952          /*-----------------------------------------------------------*/
   1953          
   1954          signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
   1955          {
   1956          tskTCB *pxUnblockedTCB;
   1957          portBASE_TYPE xReturn;
   1958          
   1959          	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
   1960          	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
   1961          
   1962          	/* The event list is sorted in priority order, so we can remove the
   1963          	first in the list, remove the TCB from the delayed list, and add
   1964          	it to the ready list.
   1965          
   1966          	If an event is for a queue that is locked then this function will never
   1967          	get called - the lock count on the queue will get modified instead.  This
   1968          	means we can always expect exclusive access to the event list here.
   1969          
   1970          	This function assumes that a check has already been made to ensure that
   1971          	pxEventList is not empty. */
   1972          	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   1973          	configASSERT( pxUnblockedTCB );
   1974          	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   1975          
   1976          	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   1977          	{
   1978          		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   1979          		prvAddTaskToReadyQueue( pxUnblockedTCB );
   1980          	}
   1981          	else
   1982          	{
   1983          		/* We cannot access the delayed or ready lists, so will hold this
   1984          		task pending until the scheduler is resumed. */
   1985          		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   1986          	}
   1987          
   1988          	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
   1989          	{
   1990          		/* Return true if the task removed from the event list has
   1991          		a higher priority than the calling task.  This allows
   1992          		the calling task to know if it should force a context
   1993          		switch now. */
   1994          		xReturn = pdTRUE;
   1995          	}
   1996          	else
   1997          	{
   1998          		xReturn = pdFALSE;
   1999          	}
   2000          
   2001          	return xReturn;
   2002          }
   2003          /*-----------------------------------------------------------*/
   2004          
   2005          void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
   2006          {
   2007          	configASSERT( pxTimeOut );
   2008          	pxTimeOut->xOverflowCount = xNumOfOverflows;
   2009          	pxTimeOut->xTimeOnEntering = xTickCount;
   2010          }
   2011          /*-----------------------------------------------------------*/
   2012          
   2013          portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
   2014          {
   2015          portBASE_TYPE xReturn;
   2016          
   2017          	configASSERT( pxTimeOut );
   2018          	configASSERT( pxTicksToWait );
   2019          
   2020          	taskENTER_CRITICAL();
   2021          	{
   2022          		#if ( INCLUDE_vTaskSuspend == 1 )
   2023          			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
   2024          			the maximum block time then the task should block indefinitely, and
   2025          			therefore never time out. */
   2026          			if( *pxTicksToWait == portMAX_DELAY )
   2027          			{
   2028          				xReturn = pdFALSE;
   2029          			}
   2030          			else /* We are not blocking indefinitely, perform the checks below. */
   2031          		#endif
   2032          
   2033          		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
   2034          		{
   2035          			/* The tick count is greater than the time at which vTaskSetTimeout()
   2036          			was called, but has also overflowed since vTaskSetTimeOut() was called.
   2037          			It must have wrapped all the way around and gone past us again. This
   2038          			passed since vTaskSetTimeout() was called. */
   2039          			xReturn = pdTRUE;
   2040          		}
   2041          		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
   2042          		{
   2043          			/* Not a genuine timeout. Adjust parameters for time remaining. */
   2044          			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
   2045          			vTaskSetTimeOutState( pxTimeOut );
   2046          			xReturn = pdFALSE;
   2047          		}
   2048          		else
   2049          		{
   2050          			xReturn = pdTRUE;
   2051          		}
   2052          	}
   2053          	taskEXIT_CRITICAL();
   2054          
   2055          	return xReturn;
   2056          }
   2057          /*-----------------------------------------------------------*/
   2058          
   2059          void vTaskMissedYield( void )
   2060          {
   2061          	xMissedYield = pdTRUE;
   2062          }
   2063          /*-----------------------------------------------------------*/
   2064          
   2065          #if ( configUSE_TRACE_FACILITY == 1 )
   2066          	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
   2067          	{
   2068          	unsigned portBASE_TYPE uxReturn;
   2069          	tskTCB *pxTCB;
   2070          
   2071          		if( xTask != NULL )
   2072          		{
   2073          			pxTCB = ( tskTCB * ) xTask;
   2074          			uxReturn = pxTCB->uxTaskNumber;
   2075          		}
   2076          		else
   2077          		{
   2078          			uxReturn = 0U;
   2079          		}
   2080          
   2081          		return uxReturn;
   2082          	}
   2083          #endif
   2084          /*-----------------------------------------------------------*/
   2085          
   2086          #if ( configUSE_TRACE_FACILITY == 1 )
   2087          	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
   2088          	{
   2089          	tskTCB *pxTCB;
   2090          
   2091          		if( xTask != NULL )
   2092          		{
   2093          			pxTCB = ( tskTCB * ) xTask;
   2094          			pxTCB->uxTaskNumber = uxHandle;
   2095          		}
   2096          	}
   2097          #endif
   2098          
   2099          
   2100          /*
   2101           * -----------------------------------------------------------
   2102           * The Idle task.
   2103           * ----------------------------------------------------------
   2104           *
   2105           * The portTASK_FUNCTION() macro is used to allow port/compiler specific
   2106           * language extensions.  The equivalent prototype for this function is:
   2107           *
   2108           * void prvIdleTask( void *pvParameters );
   2109           *
   2110           */
   2111          static portTASK_FUNCTION( prvIdleTask, pvParameters )
   2112          {
   2113          	/* Stop warnings. */
   2114          	( void ) pvParameters;
   2115          
   2116          	for( ;; )
   2117          	{
   2118          		/* See if any tasks have been deleted. */
   2119          		prvCheckTasksWaitingTermination();
   2120          
   2121          		#if ( configUSE_PREEMPTION == 0 )
   2122          		{
   2123          			/* If we are not using preemption we keep forcing a task switch to
   2124          			see if any other task has become available.  If we are using
   2125          			preemption we don't need to do this as any task becoming available
   2126          			will automatically get the processor anyway. */
   2127          			taskYIELD();
   2128          		}
   2129          		#endif
   2130          
   2131          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
   2132          		{
   2133          			/* When using preemption tasks of equal priority will be
   2134          			timesliced.  If a task that is sharing the idle priority is ready
   2135          			to run then the idle task should yield before the end of the
   2136          			timeslice.
   2137          
   2138          			A critical region is not required here as we are just reading from
   2139          			the list, and an occasional incorrect value will not matter.  If
   2140          			the ready list at the idle priority contains more than one task
   2141          			then a task other than the idle task is ready to execute. */
   2142          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
   2143          			{
   2144          				taskYIELD();
   2145          			}
   2146          		}
   2147          		#endif
   2148          
   2149          		#if ( configUSE_IDLE_HOOK == 1 )
   2150          		{
   2151          			extern void vApplicationIdleHook( void );
   2152          
   2153          			/* Call the user defined function from within the idle task.  This
   2154          			allows the application designer to add background functionality
   2155          			without the overhead of a separate task.
   2156          			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
   2157          			CALL A FUNCTION THAT MIGHT BLOCK. */
   2158          			vApplicationIdleHook();
   2159          		}
   2160          		#endif
   2161          
   2162          		/* This conditional compilation should use inequality to 0, not equality
   2163          		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
   2164          		user defined low power mode	implementations require
   2165          		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
   2166          		#if ( configUSE_TICKLESS_IDLE != 0 )
   2167          		{
   2168          		portTickType xExpectedIdleTime;
   2169          		/* If the expected idle time is 1 then the idle time would end at
   2170          		the end of the current time slice.  The idle time must be at least
   2171          		2 to ensure any pended ticks between this point and the tick being
   2172          		stopped can be legitimately stepped over when the tick suppression
   2173          		routines returns. */
   2174          		const portTickType xMinimumExpectedIdleTime = ( portTickType ) 2;
   2175          
   2176          			/* It is not desirable to suspend then resume the scheduler on
   2177          			each iteration of the idle task.  Therefore, a preliminary
   2178          			test of the expected idle time is performed without the
   2179          			scheduler suspended.  The result here is not necessarily
   2180          			valid. */
   2181          			xExpectedIdleTime = prvGetExpectedIdleTime();
   2182          
   2183          			if( xExpectedIdleTime >= xMinimumExpectedIdleTime )
   2184          			{
   2185          				vTaskSuspendAll();
   2186          				{
   2187          					/* Now the scheduler is suspended, the expected idle
   2188          					time can be sampled again, and this time its value can
   2189          					be used. */
   2190          					configASSERT( xNextTaskUnblockTime >= xTickCount );
   2191          					xExpectedIdleTime = prvGetExpectedIdleTime();
   2192          
   2193          					if( xExpectedIdleTime >= xMinimumExpectedIdleTime )
   2194          					{
   2195          						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
   2196          					}
   2197          				}
   2198          				xTaskResumeAll();
   2199          			}
   2200          		}
   2201          		#endif
   2202          	}
   2203          } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
   2204          
   2205          
   2206          
   2207          
   2208          
   2209          
   2210          
   2211          /*-----------------------------------------------------------
   2212           * File private functions documented at the top of the file.
   2213           *----------------------------------------------------------*/
   2214          
   2215          
   2216          
   2217          static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
   2218          {
   2219          	/* Store the function name in the TCB. */
   2220          	#if configMAX_TASK_NAME_LEN > 1
   2221          	{
   2222          		/* Don't bring strncpy into the build unnecessarily. */
   2223          		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
   2224          	}
   2225          	#endif
   2226          	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
   2227          
   2228          	/* This is used as an array index so must ensure it's not too large.  First
   2229          	remove the privilege bit if one is present. */
   2230          	if( uxPriority >= configMAX_PRIORITIES )
   2231          	{
   2232          		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
   2233          	}
   2234          
   2235          	pxTCB->uxPriority = uxPriority;
   2236          	#if ( configUSE_MUTEXES == 1 )
   2237          	{
   2238          		pxTCB->uxBasePriority = uxPriority;
   2239          	}
   2240          	#endif
   2241          
   2242          	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
   2243          	vListInitialiseItem( &( pxTCB->xEventListItem ) );
   2244          
   2245          	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
   2246          	back to	the containing TCB from a generic item in a list. */
   2247          	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
   2248          
   2249          	/* Event lists are always in priority order. */
   2250          	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
   2251          	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
   2252          
   2253          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
   2254          	{
   2255          		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
   2256          	}
   2257          	#endif
   2258          
   2259          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2260          	{
   2261          		pxTCB->pxTaskTag = NULL;
   2262          	}
   2263          	#endif
   2264          
   2265          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2266          	{
   2267          		pxTCB->ulRunTimeCounter = 0UL;
   2268          	}
   2269          	#endif
   2270          
   2271          	#if ( portUSING_MPU_WRAPPERS == 1 )
   2272          	{
   2273          		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
   2274          	}
   2275          	#else
   2276          	{
   2277          		( void ) xRegions;
   2278          		( void ) usStackDepth;
   2279          	}
   2280          	#endif
   2281          }
   2282          /*-----------------------------------------------------------*/
   2283          
   2284          #if ( portUSING_MPU_WRAPPERS == 1 )
   2285          
   2286          	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
   2287          	{
   2288          	tskTCB *pxTCB;
   2289          
   2290          		if( xTaskToModify == pxCurrentTCB )
   2291          		{
   2292          			xTaskToModify = NULL;
   2293          		}
   2294          
   2295          		/* If null is passed in here then we are deleting ourselves. */
   2296          		pxTCB = prvGetTCBFromHandle( xTaskToModify );
   2297          
   2298                  vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
   2299          	}
   2300          	/*-----------------------------------------------------------*/
   2301          #endif
   2302          
   2303          static void prvInitialiseTaskLists( void )
   2304          {
   2305          unsigned portBASE_TYPE uxPriority;
   2306          
   2307          	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
   2308          	{
   2309          		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
   2310          	}
   2311          
   2312          	vListInitialise( ( xList * ) &xDelayedTaskList1 );
   2313          	vListInitialise( ( xList * ) &xDelayedTaskList2 );
   2314          	vListInitialise( ( xList * ) &xPendingReadyList );
   2315          
   2316          	#if ( INCLUDE_vTaskDelete == 1 )
   2317          	{
   2318          		vListInitialise( ( xList * ) &xTasksWaitingTermination );
   2319          	}
   2320          	#endif
   2321          
   2322          	#if ( INCLUDE_vTaskSuspend == 1 )
   2323          	{
   2324          		vListInitialise( ( xList * ) &xSuspendedTaskList );
   2325          	}
   2326          	#endif
   2327          
   2328          	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
   2329          	using list2. */
   2330          	pxDelayedTaskList = &xDelayedTaskList1;
   2331          	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   2332          }
   2333          /*-----------------------------------------------------------*/
   2334          
   2335          static void prvCheckTasksWaitingTermination( void )
   2336          {
   2337          	#if ( INCLUDE_vTaskDelete == 1 )
   2338          	{
   2339          		portBASE_TYPE xListIsEmpty;
   2340          
   2341          		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
   2342          		too often in the idle task. */
   2343          		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
   2344          		{
   2345          			vTaskSuspendAll();
   2346          				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   2347          			xTaskResumeAll();
   2348          
   2349          			if( xListIsEmpty == pdFALSE )
   2350          			{
   2351          				tskTCB *pxTCB;
   2352          
   2353          				taskENTER_CRITICAL();
   2354          				{
   2355          					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
   2356          					uxListRemove( &( pxTCB->xGenericListItem ) );
   2357          					--uxCurrentNumberOfTasks;
   2358          					--uxTasksDeleted;
   2359          				}
   2360          				taskEXIT_CRITICAL();
   2361          
   2362          				prvDeleteTCB( pxTCB );
   2363          			}
   2364          		}
   2365          	}
   2366          	#endif
   2367          }
   2368          /*-----------------------------------------------------------*/
   2369          
   2370          static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
   2371          {
   2372          	/* The list item will be inserted in wake time order. */
   2373          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   2374          
   2375          	if( xTimeToWake < xTickCount )
   2376          	{
   2377          		/* Wake time has overflowed.  Place this item in the overflow list. */
   2378          		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   2379          	}
   2380          	else
   2381          	{
   2382          		/* The wake time has not overflowed, so we can use the current block list. */
   2383          		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
   2384          
   2385          		/* If the task entering the blocked state was placed at the head of the
   2386          		list of blocked tasks then xNextTaskUnblockTime needs to be updated
   2387          		too. */
   2388          		if( xTimeToWake < xNextTaskUnblockTime )
   2389          		{
   2390          			xNextTaskUnblockTime = xTimeToWake;
   2391          		}
   2392          	}
   2393          }
   2394          /*-----------------------------------------------------------*/
   2395          
   2396          static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
   2397          {
   2398          tskTCB *pxNewTCB;
   2399          
   2400          	/* Allocate space for the TCB.  Where the memory comes from depends on
   2401          	the implementation of the port malloc function. */
   2402          	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
   2403          
   2404          	if( pxNewTCB != NULL )
   2405          	{
   2406          		/* Allocate space for the stack used by the task being created.
   2407          		The base of the stack memory stored in the TCB so the task can
   2408          		be deleted later if required. */
   2409          		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
   2410          
   2411          		if( pxNewTCB->pxStack == NULL )
   2412          		{
   2413          			/* Could not allocate the stack.  Delete the allocated TCB. */
   2414          			vPortFree( pxNewTCB );
   2415          			pxNewTCB = NULL;
   2416          		}
   2417          		else
   2418          		{
   2419          			/* Just to help debugging. */
   2420          			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
   2421          		}
   2422          	}
   2423          
   2424          	return pxNewTCB;
   2425          }
   2426          /*-----------------------------------------------------------*/
   2427          
   2428          #if ( configUSE_TRACE_FACILITY == 1 )
   2429          
   2430          	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
   2431          	{
   2432          	volatile tskTCB *pxNextTCB, *pxFirstTCB;
   2433          	unsigned short usStackRemaining;
   2434          	PRIVILEGED_DATA static char pcStatusString[ configMAX_TASK_NAME_LEN + 30 ];
   2435          
   2436          		/* Write the details of all the TCB's in pxList into the buffer. */
   2437          		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   2438          		do
   2439          		{
   2440          			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   2441          			#if ( portSTACK_GROWTH > 0 )
   2442          			{
   2443          				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
   2444          			}
   2445          			#else
   2446          			{
   2447          				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
   2448          			}
   2449          			#endif
   2450          
   2451          			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, ( unsigned int ) usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
   2452          			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
   2453          
   2454          		} while( pxNextTCB != pxFirstTCB );
   2455          	}
   2456          
   2457          #endif
   2458          /*-----------------------------------------------------------*/
   2459          
   2460          #if ( configGENERATE_RUN_TIME_STATS == 1 )
   2461          
   2462          	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList, unsigned long ulTotalRunTime )
   2463          	{
   2464          	volatile tskTCB *pxNextTCB, *pxFirstTCB;
   2465          	unsigned long ulStatsAsPercentage;
   2466          
   2467          		/* Write the run time stats of all the TCB's in pxList into the buffer. */
   2468          		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   2469          		do
   2470          		{
   2471          			/* Get next TCB in from the list. */
   2472          			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   2473          
   2474          			/* Divide by zero check. */
   2475          			if( ulTotalRunTime > 0UL )
   2476          			{
   2477          				/* Has the task run at all? */
   2478          				if( pxNextTCB->ulRunTimeCounter == 0UL )
   2479          				{
   2480          					/* The task has used no CPU time at all. */
   2481          					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
   2482          				}
   2483          				else
   2484          				{
   2485          					/* What percentage of the total run time has the task used?
   2486          					This will always be rounded down to the nearest integer.
   2487          					ulTotalRunTime has already been divided by 100. */
   2488          					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
   2489          
   2490          					if( ulStatsAsPercentage > 0UL )
   2491          					{
   2492          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   2493          						{
   2494          							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTCB->ulRunTimeCounter, ulStatsAsPercentage );
   2495          						}
   2496          						#else
   2497          						{
   2498          							/* sizeof( int ) == sizeof( long ) so a smaller
   2499          							printf() library can be used. */
   2500          							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned int ) pxNextTCB->ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
   2501          						}
   2502          						#endif
   2503          					}
   2504          					else
   2505          					{
   2506          						/* If the percentage is zero here then the task has
   2507          						consumed less than 1% of the total run time. */
   2508          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   2509          						{
   2510          							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB->ulRunTimeCounter );
   2511          						}
   2512          						#else
   2513          						{
   2514          							/* sizeof( int ) == sizeof( long ) so a smaller
   2515          							printf() library can be used. */
   2516          							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned int ) pxNextTCB->ulRunTimeCounter );
   2517          						}
   2518          						#endif
   2519          					}
   2520          				}
   2521          
   2522          				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
   2523          			}
   2524          
   2525          		} while( pxNextTCB != pxFirstTCB );
   2526          	}
   2527          
   2528          #endif
   2529          /*-----------------------------------------------------------*/
   2530          
   2531          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   2532          
   2533          	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
   2534          	{
   2535          	register unsigned short usCount = 0U;
   2536          
   2537          		while( *pucStackByte == tskSTACK_FILL_BYTE )
   2538          		{
   2539          			pucStackByte -= portSTACK_GROWTH;
   2540          			usCount++;
   2541          		}
   2542          
   2543          		usCount /= sizeof( portSTACK_TYPE );
   2544          
   2545          		return usCount;
   2546          	}
   2547          
   2548          #endif
   2549          /*-----------------------------------------------------------*/
   2550          
   2551          #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
   2552          
   2553          	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
   2554          	{
   2555          	tskTCB *pxTCB;
   2556          	unsigned char *pcEndOfStack;
   2557          	unsigned portBASE_TYPE uxReturn;
   2558          
   2559          		pxTCB = prvGetTCBFromHandle( xTask );
   2560          
   2561          		#if portSTACK_GROWTH < 0
   2562          		{
   2563          			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
   2564          		}
   2565          		#else
   2566          		{
   2567          			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
   2568          		}
   2569          		#endif
   2570          
   2571          		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
   2572          
   2573          		return uxReturn;
   2574          	}
   2575          
   2576          #endif
   2577          /*-----------------------------------------------------------*/
   2578          
   2579          #if ( INCLUDE_vTaskDelete == 1 )
   2580          
   2581          	static void prvDeleteTCB( tskTCB *pxTCB )
   2582          	{
   2583          		/* This call is required specifically for the TriCore port.  It must be
   2584          		above the vPortFree() calls.  The call is also used by ports/demos that
   2585          		want to allocate and clean RAM statically. */
   2586          		portCLEAN_UP_TCB( pxTCB );
   2587          
   2588          		/* Free up the memory allocated by the scheduler for the task.  It is up to
   2589          		the task to free any memory allocated at the application level. */
   2590          		vPortFreeAligned( pxTCB->pxStack );
   2591          		vPortFree( pxTCB );
   2592          	}
   2593          
   2594          #endif
   2595          
   2596          
   2597          /*-----------------------------------------------------------*/
   2598          
   2599          #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
   2600          
   2601          	xTaskHandle xTaskGetCurrentTaskHandle( void )
   2602          	{
   2603          	xTaskHandle xReturn;
   2604          
   2605          		/* A critical section is not required as this is not called from
   2606          		an interrupt and the current TCB will always be the same for any
   2607          		individual execution thread. */
   2608          		xReturn = pxCurrentTCB;
   2609          
   2610          		return xReturn;
   2611          	}
   2612          
   2613          #endif
   2614          
   2615          /*-----------------------------------------------------------*/
   2616          
   2617          #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   2618          
   2619          	portBASE_TYPE xTaskGetSchedulerState( void )
   2620          	{
   2621          	portBASE_TYPE xReturn;
   2622          
   2623          		if( xSchedulerRunning == pdFALSE )
   2624          		{
   2625          			xReturn = taskSCHEDULER_NOT_STARTED;
   2626          		}
   2627          		else
   2628          		{
   2629          			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
   2630          			{
   2631          				xReturn = taskSCHEDULER_RUNNING;
   2632          			}
   2633          			else
   2634          			{
   2635          				xReturn = taskSCHEDULER_SUSPENDED;
   2636          			}
   2637          		}
   2638          
   2639          		return xReturn;
   2640          	}
   2641          
   2642          #endif
   2643          /*-----------------------------------------------------------*/
   2644          
   2645          #if ( configUSE_MUTEXES == 1 )
   2646          
   2647          	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
   2648          	{
   2649          	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
   2650          
   2651          		/* If the mutex was given back by an interrupt while the queue was
   2652          		locked then the mutex holder might now be NULL. */
   2653          		if( pxMutexHolder != NULL )
   2654          		{
   2655          			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   2656          			{
   2657          				/* Adjust the mutex holder state to account for its new priority. */
   2658          				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
   2659          
   2660          				/* If the task being modified is in the ready state it will need to
   2661          				be moved into a new list. */
   2662          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   2663          				{
   2664          					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
   2665          					{
   2666          						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   2667          					}
   2668          
   2669          					/* Inherit the priority before being moved into the new list. */
   2670          					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   2671          					prvAddTaskToReadyQueue( pxTCB );
   2672          				}
   2673          				else
   2674          				{
   2675          					/* Just inherit the priority. */
   2676          					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   2677          				}
   2678          
   2679          				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
   2680          			}
   2681          		}
   2682          	}
   2683          
   2684          #endif
   2685          /*-----------------------------------------------------------*/
   2686          
   2687          #if ( configUSE_MUTEXES == 1 )
   2688          
   2689          	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
   2690          	{
   2691          	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
   2692          
   2693          		if( pxMutexHolder != NULL )
   2694          		{
   2695          			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   2696          			{
   2697          				/* We must be the running task to be able to give the mutex back.
   2698          				Remove ourselves from the ready list we currently appear in. */
   2699          				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
   2700          				{
   2701          					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   2702          				}
   2703          
   2704          				/* Disinherit the priority before adding the task into the new
   2705          				ready list. */
   2706          				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
   2707          				pxTCB->uxPriority = pxTCB->uxBasePriority;
   2708          				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
   2709          				prvAddTaskToReadyQueue( pxTCB );
   2710          			}
   2711          		}
   2712          	}
   2713          
   2714          #endif
   2715          /*-----------------------------------------------------------*/
   2716          
   2717          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   2718          
   2719          	void vTaskEnterCritical( void )
   2720          	{
   2721          		portDISABLE_INTERRUPTS();
   2722          
   2723          		if( xSchedulerRunning != pdFALSE )
   2724          		{
   2725          			( pxCurrentTCB->uxCriticalNesting )++;
   2726          		}
   2727          	}
   2728          
   2729          #endif
   2730          /*-----------------------------------------------------------*/
   2731          
   2732          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   2733          
   2734          	void vTaskExitCritical( void )
   2735          	{
   2736          		if( xSchedulerRunning != pdFALSE )
   2737          		{
   2738          			if( pxCurrentTCB->uxCriticalNesting > 0U )
   2739          			{
   2740          				( pxCurrentTCB->uxCriticalNesting )--;
   2741          
   2742          				if( pxCurrentTCB->uxCriticalNesting == 0U )
   2743          				{
   2744          					portENABLE_INTERRUPTS();
   2745          				}
   2746          			}
   2747          		}
   2748          	}
   2749          
   2750          #endif
   2751          /*-----------------------------------------------------------*/
   2752          
   2753          
   2754          
   2755          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   prvAddCurrentTaskToDelayedList
         8   -> vListInsert
      16   prvAllocateTCBAndStack
        16   -> __aeabi_memset
        16   -> pvPortMalloc
        16   -> vPortFree
       8   prvCheckTasksWaitingTermination
         8   -> prvDeleteTCB
         8   -> uxListRemove
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
         8   -> vTaskSuspendAll
         8   -> xTaskResumeAll
       8   prvDeleteTCB
         8   -> vPortFree
       8   prvIdleTask
         8   -> prvCheckTasksWaitingTermination
         8   -> vApplicationIdleHook
         8   -> vPortYieldFromISR
      16   prvInitialiseTCBVariables
        16   -> strncpy
        16   -> vListInitialiseItem
       8   prvInitialiseTaskLists
         8   -> vListInitialise
       0   uxTaskGetNumberOfTasks
       8   uxTaskPriorityGet
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   vTaskDelay
         8   -> prvAddCurrentTaskToDelayedList
         8   -> uxListRemove
         8   -> vPortYieldFromISR
         8   -> vTaskSuspendAll
         8   -> xTaskResumeAll
      16   vTaskDelayUntil
        16   -> prvAddCurrentTaskToDelayedList
        16   -> uxListRemove
        16   -> vPortYieldFromISR
        16   -> vTaskSuspendAll
        16   -> xTaskResumeAll
      16   vTaskDelete
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortYieldFromISR
       8   vTaskEndScheduler
         8   -> ulPortSetInterruptMask
         8   -> vPortEndScheduler
       8   vTaskIncrementTick
         8   -> uxListRemove
         8   -> vApplicationTickHook
         8   -> vListInsertEnd
       0   vTaskMissedYield
       8   vTaskPlaceOnEventList
         8   -> prvAddCurrentTaskToDelayedList
         8   -> uxListRemove
         8   -> vListInsert
         8   -> vListInsertEnd
       8   vTaskPriorityDisinherit
         8   -> uxListRemove
         8   -> vListInsertEnd
       8   vTaskPriorityInherit
         8   -> uxListRemove
         8   -> vListInsertEnd
      24   vTaskPrioritySet
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vPortYieldFromISR
       8   vTaskResume
         8   -> uxListRemove
         8   -> vListInsertEnd
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
         8   -> vPortYieldFromISR
         8   -> xTaskIsTaskSuspended
       0   vTaskSetTimeOutState
      24   vTaskStartScheduler
        24   -> ulPortSetInterruptMask
        24   -> xPortStartScheduler
        24   -> xTaskGenericCreate
      16   vTaskSuspend
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortYieldFromISR
        16   -> vTaskSwitchContext
       0   vTaskSuspendAll
       8   vTaskSwitchContext
         8   -> memcmp
         8   -> vApplicationStackOverflowHook
      16   xTaskCheckForTimeOut
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vTaskSetTimeOutState
      40   xTaskGenericCreate
        40   -> prvAllocateTCBAndStack
        40   -> prvInitialiseTCBVariables
        40   -> prvInitialiseTaskLists
        40   -> pxPortInitialiseStack
        40   -> vListInsertEnd
        40   -> vPortEnterCritical
        40   -> vPortExitCritical
        40   -> vPortYieldFromISR
       0   xTaskGetCurrentTaskHandle
       8   xTaskGetTickCount
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   xTaskGetTickCountFromISR
         8   -> ulPortSetInterruptMask
         8   -> vPortClearInterruptMask
       0   xTaskIsTaskSuspended
       8   xTaskRemoveFromEventList
         8   -> uxListRemove
         8   -> vListInsertEnd
      16   xTaskResumeAll
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortYieldFromISR
        16   -> vTaskIncrementTick
      16   xTaskResumeFromISR
        16   -> ulPortSetInterruptMask
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortClearInterruptMask
        16   -> xTaskIsTaskSuspended


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_10
       4  ??DataTable29_11
       4  ??DataTable29_12
       4  ??DataTable29_13
       4  ??DataTable29_14
       4  ??DataTable29_15
       4  ??DataTable29_16
       4  ??DataTable29_17
       4  ??DataTable29_18
       4  ??DataTable29_19
       4  ??DataTable29_2
       4  ??DataTable29_20
       4  ??DataTable29_21
       4  ??DataTable29_22
       4  ??DataTable29_3
       4  ??DataTable29_4
       4  ??DataTable29_5
       4  ??DataTable29_6
       4  ??DataTable29_7
       4  ??DataTable29_8
       4  ??DataTable29_9
       8  ?_0
      62  prvAddCurrentTaskToDelayedList
      70  prvAllocateTCBAndStack
      86  prvCheckTasksWaitingTermination
      18  prvDeleteTCB
      16  prvIdleTask
      58  prvInitialiseTCBVariables
      70  prvInitialiseTaskLists
       4  pxCurrentTCB
       4  pxDelayedTaskList
       4  pxOverflowDelayedTaskList
     100  pxReadyTasksLists
      20  ucExpectedStackBytes
       4  uxCurrentNumberOfTasks
       4  uxMissedTicks
       4  uxSchedulerSuspended
       8  uxTaskGetNumberOfTasks
       4  uxTaskNumber
      30  uxTaskPriorityGet
       4  uxTasksDeleted
       4  uxTopReadyPriority
       4  uxTopUsedPriority
      54  vTaskDelay
     104  vTaskDelayUntil
     116  vTaskDelete
      20  vTaskEndScheduler
     280  vTaskIncrementTick
       8  vTaskMissedYield
      64  vTaskPlaceOnEventList
      68  vTaskPriorityDisinherit
     106  vTaskPriorityInherit
     162  vTaskPrioritySet
     100  vTaskResume
      14  vTaskSetTimeOutState
      68  vTaskStartScheduler
     120  vTaskSuspend
      16  vTaskSuspendAll
     190  vTaskSwitchContext
      20  xDelayedTaskList1
      20  xDelayedTaskList2
       4  xMissedYield
       4  xNextTaskUnblockTime
       4  xNumOfOverflows
      20  xPendingReadyList
       4  xSchedulerRunning
      20  xSuspendedTaskList
      94  xTaskCheckForTimeOut
     292  xTaskGenericCreate
       6  xTaskGetCurrentTaskHandle
      20  xTaskGetTickCount
      20  xTaskGetTickCountFromISR
      34  xTaskIsTaskSuspended
      92  xTaskRemoveFromEventList
     208  xTaskResumeAll
     120  xTaskResumeFromISR
      20  xTasksWaitingTermination
       4  xTickCount

 
   256 bytes in section .bss
     4 bytes in section .data
    28 bytes in section .rodata
 2 886 bytes in section .text
 
 2 886 bytes of CODE  memory
    28 bytes of CONST memory
   260 bytes of DATA  memory

Errors: none
Warnings: none
