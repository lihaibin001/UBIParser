###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.2.11947/W32 for ARM       15/Sep/2017  09:59:28
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\workspace\dr002\dr002_suming\v1_board\main_app\Arch\stm32f1\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_adc.c
#    Command line =  
#        D:\workspace\dr002\dr002_suming\v1_board\main_app\Arch\stm32f1\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_adc.c
#        -D VECT_TAB_FLASH -D IAR_ARM_CM3 -lcN
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\List
#        --diag_suppress Pa050 -o
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\.\ -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Diag_Factory\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\common\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\power\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\SysMan\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Protocol\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\include\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\FreeRTOS\include\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\FreeRTOS\portable\IAR\ARM_CM3\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\drivers\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\GPS\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\GPRS\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Sensors\
#        -Ol --use_c++_inline --require_prototypes
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\List\stm32f10x_adc.lst
#    Object file  =  
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\Obj\stm32f10x_adc.o
#
###############################################################################

D:\workspace\dr002\dr002_suming\v1_board\main_app\Arch\stm32f1\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_adc.c
      4            * @author  MCD Application Team
      5            * @version V3.5.0
      6            * @date    11-March-2011
      7            * @brief   This file provides all the ADC firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm32f10x_adc.h"
     24          #include "stm32f10x_rcc.h"
     25          #include "delay.h"
     26          
     27          /** @addtogroup STM32F10x_StdPeriph_Driver
     28            * @{
     29            */
     30          
     31          /** @defgroup ADC 
     32            * @brief ADC driver modules
     33            * @{
     34            */
     35          
     36          /** @defgroup ADC_Private_TypesDefinitions
     37            * @{
     38            */
     39          
     40          /**
     41            * @}
     42            */
     43          
     44          /** @defgroup ADC_Private_Defines
     45            * @{
     46            */
     47          
     48          /* ADC DISCNUM mask */
     49          #define CR1_DISCNUM_Reset           ((uint32_t)0xFFFF1FFF)
     50          
     51          /* ADC DISCEN mask */
     52          #define CR1_DISCEN_Set              ((uint32_t)0x00000800)
     53          #define CR1_DISCEN_Reset            ((uint32_t)0xFFFFF7FF)
     54          
     55          /* ADC JAUTO mask */
     56          #define CR1_JAUTO_Set               ((uint32_t)0x00000400)
     57          #define CR1_JAUTO_Reset             ((uint32_t)0xFFFFFBFF)
     58          
     59          /* ADC JDISCEN mask */
     60          #define CR1_JDISCEN_Set             ((uint32_t)0x00001000)
     61          #define CR1_JDISCEN_Reset           ((uint32_t)0xFFFFEFFF)
     62          
     63          /* ADC AWDCH mask */
     64          #define CR1_AWDCH_Reset             ((uint32_t)0xFFFFFFE0)
     65          
     66          /* ADC Analog watchdog enable mode mask */
     67          #define CR1_AWDMode_Reset           ((uint32_t)0xFF3FFDFF)
     68          
     69          /* CR1 register Mask */
     70          #define CR1_CLEAR_Mask              ((uint32_t)0xFFF0FEFF)
     71          
     72          /* ADC ADON mask */
     73          #define CR2_ADON_Set                ((uint32_t)0x00000001)
     74          #define CR2_ADON_Reset              ((uint32_t)0xFFFFFFFE)
     75          
     76          /* ADC DMA mask */
     77          #define CR2_DMA_Set                 ((uint32_t)0x00000100)
     78          #define CR2_DMA_Reset               ((uint32_t)0xFFFFFEFF)
     79          
     80          /* ADC RSTCAL mask */
     81          #define CR2_RSTCAL_Set              ((uint32_t)0x00000008)
     82          
     83          /* ADC CAL mask */
     84          #define CR2_CAL_Set                 ((uint32_t)0x00000004)
     85          
     86          /* ADC SWSTART mask */
     87          #define CR2_SWSTART_Set             ((uint32_t)0x00400000)
     88          
     89          /* ADC EXTTRIG mask */
     90          #define CR2_EXTTRIG_Set             ((uint32_t)0x00100000)
     91          #define CR2_EXTTRIG_Reset           ((uint32_t)0xFFEFFFFF)
     92          
     93          /* ADC Software start mask */
     94          #define CR2_EXTTRIG_SWSTART_Set     ((uint32_t)0x00500000)
     95          #define CR2_EXTTRIG_SWSTART_Reset   ((uint32_t)0xFFAFFFFF)
     96          
     97          /* ADC JEXTSEL mask */
     98          #define CR2_JEXTSEL_Reset           ((uint32_t)0xFFFF8FFF)
     99          
    100          /* ADC JEXTTRIG mask */
    101          #define CR2_JEXTTRIG_Set            ((uint32_t)0x00008000)
    102          #define CR2_JEXTTRIG_Reset          ((uint32_t)0xFFFF7FFF)
    103          
    104          /* ADC JSWSTART mask */
    105          #define CR2_JSWSTART_Set            ((uint32_t)0x00200000)
    106          
    107          /* ADC injected software start mask */
    108          #define CR2_JEXTTRIG_JSWSTART_Set   ((uint32_t)0x00208000)
    109          #define CR2_JEXTTRIG_JSWSTART_Reset ((uint32_t)0xFFDF7FFF)
    110          
    111          /* ADC TSPD mask */
    112          #define CR2_TSVREFE_Set             ((uint32_t)0x00800000)
    113          #define CR2_TSVREFE_Reset           ((uint32_t)0xFF7FFFFF)
    114          
    115          /* CR2 register Mask */
    116          #define CR2_CLEAR_Mask              ((uint32_t)0xFFF1F7FD)
    117          
    118          /* ADC SQx mask */
    119          #define SQR3_SQ_Set                 ((uint32_t)0x0000001F)
    120          #define SQR2_SQ_Set                 ((uint32_t)0x0000001F)
    121          #define SQR1_SQ_Set                 ((uint32_t)0x0000001F)
    122          
    123          /* SQR1 register Mask */
    124          #define SQR1_CLEAR_Mask             ((uint32_t)0xFF0FFFFF)
    125          
    126          /* ADC JSQx mask */
    127          #define JSQR_JSQ_Set                ((uint32_t)0x0000001F)
    128          
    129          /* ADC JL mask */
    130          #define JSQR_JL_Set                 ((uint32_t)0x00300000)
    131          #define JSQR_JL_Reset               ((uint32_t)0xFFCFFFFF)
    132          
    133          /* ADC SMPx mask */
    134          #define SMPR1_SMP_Set               ((uint32_t)0x00000007)
    135          #define SMPR2_SMP_Set               ((uint32_t)0x00000007)
    136          
    137          /* ADC JDRx registers offset */
    138          #define JDR_Offset                  ((uint8_t)0x28)
    139          
    140          /* ADC1 DR register base address */
    141          #define DR_ADDRESS                  ((uint32_t)0x4001244C)
    142          
    143          
    144          #define ADC1_DR_Address ((u32)0x40012400+0x4c)
    145          /**
    146            * @}
    147            */
    148          
    149          /** @defgroup ADC_Private_Macros
    150            * @{
    151            */
    152          
    153          /**
    154            * @}
    155            */
    156          
    157          /** @defgroup ADC_Private_Variables
    158            * @{
    159            */
    160          //static bool ad_initialized = false;
    161          static bool ad_1_initialized = false;
    162          static bool ad_9_initialized = false;
    163          static bool ad_13_initialized = false;
    164          //static uint16_t ADC_ConvertedValue;
    165          static uint16_t adc_initialized_channel=ADC_Channel_0;
    166          
    167          /**
    168            * @}
    169            */
    170          
    171          /** @defgroup ADC_Private_FunctionPrototypes
    172            * @{
    173            */
    174          
    175          /**
    176            * @}
    177            */
    178          
    179          /** @defgroup ADC_Private_Functions
    180            * @{
    181            */
    182          /**********************************************************************
    183           * Description: Initialize A/D operation
    184           *  Parameters: 
    185           *     Returns: 16 bit A/D count 
    186           *********************************************************************/
    187          static void ad_1_initialize(void)
    188          {
    189          //	ADC_InitTypeDef  ADC_InitStructure;
    190          //	GPIO_InitTypeDef GPIO_InitStructure;
    191          ////	DMA_InitTypeDef DMA_InitStructure;
    192          //	/* Enable ADC1 clocks */
    193          //	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    194          //	/* Enable DMA clock */
    195          ////	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    196          
    197          //	GPIO_InitStructure.GPIO_Pin  =GPIO_Pin_1;
    198          //	GPIO_InitStructure.GPIO_Mode =GPIO_Mode_AIN;
    199          //	GPIO_Init(GPIOA,&GPIO_InitStructure);
    200          
    201          //	ADC_InitStructure.ADC_Mode              = ADC_Mode_Independent;  //
    202          //	ADC_InitStructure.ADC_ScanConvMode      =DISABLE;      //
    203          //	ADC_InitStructure.ADC_ContinuousConvMode =ENABLE;      //
    204          //	ADC_InitStructure.ADC_ExternalTrigConv  = ADC_ExternalTrigConv_None; //
    205          //	ADC_InitStructure.ADC_DataAlign         =ADC_DataAlign_Left;   //
    206          //	ADC_InitStructure.ADC_NbrOfChannel      =1;       //Scan channel number
    207          //	ADC_Init(ADC1,&ADC_InitStructure);
    208          //	// config the ADC clock
    209          //	RCC_ADCCLKConfig(RCC_PCLK2_Div8);
    210          //	/* ADC1 regular channel1 configuration */
    211          
    212          	ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 1, ADC_SampleTime_55Cycles5);
    213          
    214          //	/* Enable ADC1 */
    215          //	ADC_Cmd(ADC1, ENABLE);
    216          //	ADC_ResetCalibration(ADC1);
    217          //	/* Check the end of ADC1 reset calibration register */
    218          //	while(ADC_GetResetCalibrationStatus(ADC1));
    219          //	/* Start ADC1 calibaration */
    220          //	ADC_StartCalibration(ADC1);
    221          //	/* Check the end of ADC1 calibration */
    222          //	while(ADC_GetCalibrationStatus(ADC1));
    223          	/* Start ADC1 Software Conversion */ 
    224          	ADC_SoftwareStartConvCmd(ADC1, ENABLE);
    225          
    226          	ad_1_initialized = true;
    227              adc_initialized_channel=ADC_Channel_1;
    228          }
    229          
    230          /**********************************************************************
    231           * Description: Initialize A/D operation
    232           *  Parameters: 
    233           *     Returns: 16 bit A/D count 
    234           *********************************************************************/
    235          static void ad_9_initialize(void)
    236          {
    237          	ADC_InitTypeDef  ADC_InitStructure;
    238          	GPIO_InitTypeDef GPIO_InitStructure;
    239          //	DMA_InitTypeDef DMA_InitStructure;
    240          	/* Enable ADC1 clocks */
    241          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    242          	/* Enable DMA clock */
    243          //	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    244          
    245          	GPIO_InitStructure.GPIO_Pin  =GPIO_Pin_1;
    246          	GPIO_InitStructure.GPIO_Mode =GPIO_Mode_AIN;
    247          	GPIO_Init(GPIOB,&GPIO_InitStructure);
    248          
    249          /*	GPIO_InitStructure.GPIO_Pin  =GPIO_Pin_1;
    250          	GPIO_InitStructure.GPIO_Mode =GPIO_Mode_AIN;
    251          	GPIO_Init(GPIOA,&GPIO_InitStructure);*/
    252          
    253          	ADC_InitStructure.ADC_Mode              = ADC_Mode_Independent;  //
    254          	ADC_InitStructure.ADC_ScanConvMode      =DISABLE;      //
    255          	ADC_InitStructure.ADC_ContinuousConvMode =ENABLE;      //
    256          	ADC_InitStructure.ADC_ExternalTrigConv  = ADC_ExternalTrigConv_None; //
    257          	ADC_InitStructure.ADC_DataAlign         =ADC_DataAlign_Left;   //
    258          	ADC_InitStructure.ADC_NbrOfChannel      =1;       //Scan channel number
    259          	ADC_Init(ADC1,&ADC_InitStructure);
    260          	// config the ADC clock
    261          	RCC_ADCCLKConfig(RCC_PCLK2_Div8);
    262          	/* ADC1 regular channel1 configuration */ 
    263          	ADC_RegularChannelConfig(ADC1, ADC_Channel_9, 1, ADC_SampleTime_55Cycles5);	
    264          
    265          	/* Enable ADC1 */
    266          	ADC_Cmd(ADC1, ENABLE);
    267          	ADC_ResetCalibration(ADC1);
    268          	/* Check the end of ADC1 reset calibration register */
    269          	while(ADC_GetResetCalibrationStatus(ADC1));
    270          	/* Start ADC1 calibaration */
    271          	ADC_StartCalibration(ADC1);
    272          	/* Check the end of ADC1 calibration */
    273          	while(ADC_GetCalibrationStatus(ADC1));
    274          	/* Start ADC1 Software Conversion */ 
    275          	ADC_SoftwareStartConvCmd(ADC1, ENABLE);
    276          
    277          	ad_9_initialized = true;
    278          }
    279          
    280          
    281          /**********************************************************************
    282           * Description: Initialize A/D operation
    283           *  Parameters: 
    284           *     Returns: 16 bit A/D count 
    285           *********************************************************************/
    286          static void ad_13_initialize(void)
    287          {
    288          //	ADC_InitTypeDef  ADC_InitStructure;
    289          //	GPIO_InitTypeDef GPIO_InitStructure;
    290          ////	DMA_InitTypeDef DMA_InitStructure;
    291          //	/* Enable ADC1 clocks */
    292          //	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    293          //	/* Enable DMA clock */
    294          ////	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    295          
    296          //	GPIO_InitStructure.GPIO_Pin  =GPIO_Pin_3;
    297          //	GPIO_InitStructure.GPIO_Mode =GPIO_Mode_AIN;
    298          //	GPIO_Init(GPIOC,&GPIO_InitStructure);
    299          
    300          //	ADC_InitStructure.ADC_Mode              = ADC_Mode_Independent;  //
    301          //	ADC_InitStructure.ADC_ScanConvMode      =DISABLE;      //
    302          //	ADC_InitStructure.ADC_ContinuousConvMode =ENABLE;      //
    303          //	ADC_InitStructure.ADC_ExternalTrigConv  = ADC_ExternalTrigConv_None; //
    304          //	ADC_InitStructure.ADC_DataAlign         =ADC_DataAlign_Left;   //
    305          //	ADC_InitStructure.ADC_NbrOfChannel      =1;       //Scan channel number
    306          //	ADC_Init(ADC1,&ADC_InitStructure);
    307          //	// config the ADC clock
    308          //	RCC_ADCCLKConfig(RCC_PCLK2_Div8);
    309          	
    310              /* ADC1 regular channel13 configuration */ 
    311          	ADC_RegularChannelConfig(ADC1, ADC_Channel_13, 1, ADC_SampleTime_55Cycles5);	
    312          
    313          //	/* Enable ADC1 */
    314          //	ADC_Cmd(ADC1, ENABLE);
    315          //	ADC_ResetCalibration(ADC1);
    316          //	/* Check the end of ADC1 reset calibration register */
    317          //	while(ADC_GetResetCalibrationStatus(ADC1));
    318          //	/* Start ADC1 calibaration */
    319          //	ADC_StartCalibration(ADC1);
    320          //	/* Check the end of ADC1 calibration */
    321          //	while(ADC_GetCalibrationStatus(ADC1));
    322          	/* Start ADC1 Software Conversion */ 
    323          	ADC_SoftwareStartConvCmd(ADC1, ENABLE);
    324          
    325          	ad_13_initialized = true;
    326              adc_initialized_channel=ADC_Channel_13;
    327          }
    328          
    329          /**********************************************************************
    330           * Description: AD_Read 
    331           *  Parameters: Channel to read 
    332           *              pointer to 16 bit left justified count
    333           *     Returns: E_OK if conversion is successful
    334           *********************************************************************/
    335          uint16_t AD_Read(uint_fast8_t channel)
    336          {	
    337              uint16_t counts;
    338          
    339          #if 0
    340              if (channel != adc_initialized_channel)
    341              {
    342                  switch(channel)
    343                  {
    344                      case ADC_Channel_1:
    345                          ad_1_initialize();
    346                          uDelay(2000);//delay 2ms
    347                          break;
    348                      case ADC_Channel_13:
    349                          ad_13_initialize();
    350                          uDelay(2000);//delay 2ms
    351                          break;
    352                      default:
    353                          break;
    354                  }
    355              }
    356              counts = ADC_GetConversionValue(ADC1);         /* read appropriate results   */
    357              return (counts);
    358          #endif
    359          
    360          #if 1
    361              if (channel==ADC_Channel_13)
    362              {
    363                  if (!ad_13_initialized)
    364                  {
    365                      ad_13_initialize();
    366                      uDelay(100);//delay 0.5ms
    367                      ad_1_initialized = false;
    368                  }
    369                  counts = ADC_GetConversionValue(ADC1);         /* read appropriate results   */
    370                  return (counts);
    371              }
    372              else if (channel==ADC_Channel_1)
    373              {
    374                  if (!ad_1_initialized)
    375                  {
    376                      ad_1_initialize();
    377                      uDelay(100);//delay 0.5ms
    378                      ad_13_initialized = false;
    379                  }
    380                  counts = ADC_GetConversionValue(ADC1);         /* read appropriate results   */
    381                  return (counts);
    382              }
    383              else
    384              {
    385                  return 0;
    386              }
    387          #endif
    388          }
    389          /**
    390            * @brief  Deinitializes the ADCx peripheral registers to their default reset values.
    391            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    392            * @retval None
    393            */
    394          void ADC_DeInit(ADC_TypeDef* ADCx)
    395          {
    396            /* Check the parameters */
    397            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    398            
    399            if (ADCx == ADC1)
    400            {
    401              /* Enable ADC1 reset state */
    402              RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
    403              /* Release ADC1 from reset state */
    404              RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
    405            }
    406          }
    407          
    408          /**
    409            * @brief  Initializes the ADCx peripheral according to the specified parameters
    410            *         in the ADC_InitStruct.
    411            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    412            * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
    413            *         the configuration information for the specified ADC peripheral.
    414            * @retval None
    415            */
    416          void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
    417          {
    418            uint32_t tmpreg1 = 0;
    419            uint8_t tmpreg2 = 0;
    420            /* Check the parameters */
    421            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    422            assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
    423            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
    424            assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));
    425            assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));   
    426            assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
    427            assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
    428          
    429            /*---------------------------- ADCx CR1 Configuration -----------------*/
    430            /* Get the ADCx CR1 value */
    431            tmpreg1 = ADCx->CR1;
    432            /* Clear DUALMOD and SCAN bits */
    433            tmpreg1 &= CR1_CLEAR_Mask;
    434            /* Configure ADCx: Dual mode and scan conversion mode */
    435            /* Set DUALMOD bits according to ADC_Mode value */
    436            /* Set SCAN bit according to ADC_ScanConvMode value */
    437            tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
    438            /* Write to ADCx CR1 */
    439            ADCx->CR1 = tmpreg1;
    440          
    441            /*---------------------------- ADCx CR2 Configuration -----------------*/
    442            /* Get the ADCx CR2 value */
    443            tmpreg1 = ADCx->CR2;
    444            /* Clear CONT, ALIGN and EXTSEL bits */
    445            tmpreg1 &= CR2_CLEAR_Mask;
    446            /* Configure ADCx: external trigger event and continuous conversion mode */
    447            /* Set ALIGN bit according to ADC_DataAlign value */
    448            /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
    449            /* Set CONT bit according to ADC_ContinuousConvMode value */
    450            tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
    451                      ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
    452            /* Write to ADCx CR2 */
    453            ADCx->CR2 = tmpreg1;
    454          
    455            /*---------------------------- ADCx SQR1 Configuration -----------------*/
    456            /* Get the ADCx SQR1 value */
    457            tmpreg1 = ADCx->SQR1;
    458            /* Clear L bits */
    459            tmpreg1 &= SQR1_CLEAR_Mask;
    460            /* Configure ADCx: regular channel sequence length */
    461            /* Set L bits according to ADC_NbrOfChannel value */
    462            tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
    463            tmpreg1 |= (uint32_t)tmpreg2 << 20;
    464            /* Write to ADCx SQR1 */
    465            ADCx->SQR1 = tmpreg1;
    466          }
    467          
    468          /**
    469            * @brief  Fills each ADC_InitStruct member with its default value.
    470            * @param  ADC_InitStruct : pointer to an ADC_InitTypeDef structure which will be initialized.
    471            * @retval None
    472            */
    473          void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
    474          {
    475            /* Reset ADC init structure parameters values */
    476            /* Initialize the ADC_Mode member */
    477            ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
    478            /* initialize the ADC_ScanConvMode member */
    479            ADC_InitStruct->ADC_ScanConvMode = DISABLE;
    480            /* Initialize the ADC_ContinuousConvMode member */
    481            ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
    482            /* Initialize the ADC_ExternalTrigConv member */
    483            ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
    484            /* Initialize the ADC_DataAlign member */
    485            ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
    486            /* Initialize the ADC_NbrOfChannel member */
    487            ADC_InitStruct->ADC_NbrOfChannel = 1;
    488          }
    489          
    490          /**
    491            * @brief  Enables or disables the specified ADC peripheral.
    492            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    493            * @param  NewState: new state of the ADCx peripheral.
    494            *   This parameter can be: ENABLE or DISABLE.
    495            * @retval None
    496            */
    497          void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    498          {
    499            /* Check the parameters */
    500            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    501            assert_param(IS_FUNCTIONAL_STATE(NewState));
    502            if (NewState != DISABLE)
    503            {
    504              /* Set the ADON bit to wake up the ADC from power down mode */
    505              ADCx->CR2 |= CR2_ADON_Set;
    506            }
    507            else
    508            {
    509              /* Disable the selected ADC peripheral */
    510              ADCx->CR2 &= CR2_ADON_Reset;
    511            }
    512          }
    513          
    514          /**
    515            * @brief  Enables or disables the specified ADC DMA request.
    516            * @param  ADCx: where x can be 1 or 3 to select the ADC peripheral.
    517            *   Note: ADC2 hasn't a DMA capability.
    518            * @param  NewState: new state of the selected ADC DMA transfer.
    519            *   This parameter can be: ENABLE or DISABLE.
    520            * @retval None
    521            */
    522          void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    523          {
    524            /* Check the parameters */
    525            assert_param(IS_ADC_DMA_PERIPH(ADCx));
    526            assert_param(IS_FUNCTIONAL_STATE(NewState));
    527            if (NewState != DISABLE)
    528            {
    529              /* Enable the selected ADC DMA request */
    530              ADCx->CR2 |= CR2_DMA_Set;
    531            }
    532            else
    533            {
    534              /* Disable the selected ADC DMA request */
    535              ADCx->CR2 &= CR2_DMA_Reset;
    536            }
    537          }
    538          
    539          /**
    540            * @brief  Enables or disables the specified ADC interrupts.
    541            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    542            * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled. 
    543            *   This parameter can be any combination of the following values:
    544            *     @arg ADC_IT_EOC: End of conversion interrupt mask
    545            *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
    546            *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
    547            * @param  NewState: new state of the specified ADC interrupts.
    548            *   This parameter can be: ENABLE or DISABLE.
    549            * @retval None
    550            */
    551          void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)
    552          {
    553            uint8_t itmask = 0;
    554            /* Check the parameters */
    555            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    556            assert_param(IS_FUNCTIONAL_STATE(NewState));
    557            assert_param(IS_ADC_IT(ADC_IT));
    558            /* Get the ADC IT index */
    559            itmask = (uint8_t)ADC_IT;
    560            if (NewState != DISABLE)
    561            {
    562              /* Enable the selected ADC interrupts */
    563              ADCx->CR1 |= itmask;
    564            }
    565            else
    566            {
    567              /* Disable the selected ADC interrupts */
    568              ADCx->CR1 &= (~(uint32_t)itmask);
    569            }
    570          }
    571          
    572          /**
    573            * @brief  Resets the selected ADC calibration registers.
    574            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    575            * @retval None
    576            */
    577          void ADC_ResetCalibration(ADC_TypeDef* ADCx)
    578          {
    579            /* Check the parameters */
    580            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    581            /* Resets the selected ADC calibration registers */  
    582            ADCx->CR2 |= CR2_RSTCAL_Set;
    583          }
    584          
    585          /**
    586            * @brief  Gets the selected ADC reset calibration registers status.
    587            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    588            * @retval The new state of ADC reset calibration registers (SET or RESET).
    589            */
    590          FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
    591          {
    592            FlagStatus bitstatus = RESET;
    593            /* Check the parameters */
    594            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    595            /* Check the status of RSTCAL bit */
    596            if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
    597            {
    598              /* RSTCAL bit is set */
    599              bitstatus = SET;
    600            }
    601            else
    602            {
    603              /* RSTCAL bit is reset */
    604              bitstatus = RESET;
    605            }
    606            /* Return the RSTCAL bit status */
    607            return  bitstatus;
    608          }
    609          
    610          /**
    611            * @brief  Starts the selected ADC calibration process.
    612            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    613            * @retval None
    614            */
    615          void ADC_StartCalibration(ADC_TypeDef* ADCx)
    616          {
    617            /* Check the parameters */
    618            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    619            /* Enable the selected ADC calibration process */  
    620            ADCx->CR2 |= CR2_CAL_Set;
    621          }
    622          
    623          /**
    624            * @brief  Gets the selected ADC calibration status.
    625            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    626            * @retval The new state of ADC calibration (SET or RESET).
    627            */
    628          FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
    629          {
    630            FlagStatus bitstatus = RESET;
    631            /* Check the parameters */
    632            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    633            /* Check the status of CAL bit */
    634            if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
    635            {
    636              /* CAL bit is set: calibration on going */
    637              bitstatus = SET;
    638            }
    639            else
    640            {
    641              /* CAL bit is reset: end of calibration */
    642              bitstatus = RESET;
    643            }
    644            /* Return the CAL bit status */
    645            return  bitstatus;
    646          }
    647          
    648          /**
    649            * @brief  Enables or disables the selected ADC software start conversion .
    650            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    651            * @param  NewState: new state of the selected ADC software start conversion.
    652            *   This parameter can be: ENABLE or DISABLE.
    653            * @retval None
    654            */
    655          void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    656          {
    657            /* Check the parameters */
    658            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    659            assert_param(IS_FUNCTIONAL_STATE(NewState));
    660            if (NewState != DISABLE)
    661            {
    662              /* Enable the selected ADC conversion on external event and start the selected
    663                 ADC conversion */
    664              ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
    665            }
    666            else
    667            {
    668              /* Disable the selected ADC conversion on external event and stop the selected
    669                 ADC conversion */
    670              ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
    671            }
    672          }
    673          
    674          /**
    675            * @brief  Gets the selected ADC Software start conversion Status.
    676            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    677            * @retval The new state of ADC software start conversion (SET or RESET).
    678            */
    679          FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
    680          {
    681            FlagStatus bitstatus = RESET;
    682            /* Check the parameters */
    683            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    684            /* Check the status of SWSTART bit */
    685            if ((ADCx->CR2 & CR2_SWSTART_Set) != (uint32_t)RESET)
    686            {
    687              /* SWSTART bit is set */
    688              bitstatus = SET;
    689            }
    690            else
    691            {
    692              /* SWSTART bit is reset */
    693              bitstatus = RESET;
    694            }
    695            /* Return the SWSTART bit status */
    696            return  bitstatus;
    697          }
    698          
    699          /**
    700            * @brief  Configures the discontinuous mode for the selected ADC regular
    701            *         group channel.
    702            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    703            * @param  Number: specifies the discontinuous mode regular channel
    704            *         count value. This number must be between 1 and 8.
    705            * @retval None
    706            */
    707          void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
    708          {
    709            uint32_t tmpreg1 = 0;
    710            uint32_t tmpreg2 = 0;
    711            /* Check the parameters */
    712            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    713            assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
    714            /* Get the old register value */
    715            tmpreg1 = ADCx->CR1;
    716            /* Clear the old discontinuous mode channel count */
    717            tmpreg1 &= CR1_DISCNUM_Reset;
    718            /* Set the discontinuous mode channel count */
    719            tmpreg2 = Number - 1;
    720            tmpreg1 |= tmpreg2 << 13;
    721            /* Store the new register value */
    722            ADCx->CR1 = tmpreg1;
    723          }
    724          
    725          /**
    726            * @brief  Enables or disables the discontinuous mode on regular group
    727            *         channel for the specified ADC
    728            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    729            * @param  NewState: new state of the selected ADC discontinuous mode
    730            *         on regular group channel.
    731            *         This parameter can be: ENABLE or DISABLE.
    732            * @retval None
    733            */
    734          void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    735          {
    736            /* Check the parameters */
    737            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    738            assert_param(IS_FUNCTIONAL_STATE(NewState));
    739            if (NewState != DISABLE)
    740            {
    741              /* Enable the selected ADC regular discontinuous mode */
    742              ADCx->CR1 |= CR1_DISCEN_Set;
    743            }
    744            else
    745            {
    746              /* Disable the selected ADC regular discontinuous mode */
    747              ADCx->CR1 &= CR1_DISCEN_Reset;
    748            }
    749          }
    750          
    751          /**
    752            * @brief  Configures for the selected ADC regular channel its corresponding
    753            *         rank in the sequencer and its sample time.
    754            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    755            * @param  ADC_Channel: the ADC channel to configure. 
    756            *   This parameter can be one of the following values:
    757            *     @arg ADC_Channel_0: ADC Channel0 selected
    758            *     @arg ADC_Channel_1: ADC Channel1 selected
    759            *     @arg ADC_Channel_2: ADC Channel2 selected
    760            *     @arg ADC_Channel_3: ADC Channel3 selected
    761            *     @arg ADC_Channel_4: ADC Channel4 selected
    762            *     @arg ADC_Channel_5: ADC Channel5 selected
    763            *     @arg ADC_Channel_6: ADC Channel6 selected
    764            *     @arg ADC_Channel_7: ADC Channel7 selected
    765            *     @arg ADC_Channel_8: ADC Channel8 selected
    766            *     @arg ADC_Channel_9: ADC Channel9 selected
    767            *     @arg ADC_Channel_10: ADC Channel10 selected
    768            *     @arg ADC_Channel_11: ADC Channel11 selected
    769            *     @arg ADC_Channel_12: ADC Channel12 selected
    770            *     @arg ADC_Channel_13: ADC Channel13 selected
    771            *     @arg ADC_Channel_14: ADC Channel14 selected
    772            *     @arg ADC_Channel_15: ADC Channel15 selected
    773            *     @arg ADC_Channel_16: ADC Channel16 selected
    774            *     @arg ADC_Channel_17: ADC Channel17 selected
    775            * @param  Rank: The rank in the regular group sequencer. This parameter must be between 1 to 16.
    776            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
    777            *   This parameter can be one of the following values:
    778            *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
    779            *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
    780            *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
    781            *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
    782            *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
    783            *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
    784            *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
    785            *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
    786            * @retval None
    787            */
    788          void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
    789          {
    790            uint32_t tmpreg1 = 0, tmpreg2 = 0;
    791            /* Check the parameters */
    792            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    793            assert_param(IS_ADC_CHANNEL(ADC_Channel));
    794            assert_param(IS_ADC_REGULAR_RANK(Rank));
    795            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
    796            /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
    797            if (ADC_Channel > ADC_Channel_9)
    798            {
    799              /* Get the old register value */
    800              tmpreg1 = ADCx->SMPR1;
    801              /* Calculate the mask to clear */
    802              tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
    803              /* Clear the old channel sample time */
    804              tmpreg1 &= ~tmpreg2;
    805              /* Calculate the mask to set */
    806              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
    807              /* Set the new channel sample time */
    808              tmpreg1 |= tmpreg2;
    809              /* Store the new register value */
    810              ADCx->SMPR1 = tmpreg1;
    811            }
    812            else /* ADC_Channel include in ADC_Channel_[0..9] */
    813            {
    814              /* Get the old register value */
    815              tmpreg1 = ADCx->SMPR2;
    816              /* Calculate the mask to clear */
    817              tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
    818              /* Clear the old channel sample time */
    819              tmpreg1 &= ~tmpreg2;
    820              /* Calculate the mask to set */
    821              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
    822              /* Set the new channel sample time */
    823              tmpreg1 |= tmpreg2;
    824              /* Store the new register value */
    825              ADCx->SMPR2 = tmpreg1;
    826            }
    827            /* For Rank 1 to 6 */
    828            if (Rank < 7)
    829            {
    830              /* Get the old register value */
    831              tmpreg1 = ADCx->SQR3;
    832              /* Calculate the mask to clear */
    833              tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
    834              /* Clear the old SQx bits for the selected rank */
    835              tmpreg1 &= ~tmpreg2;
    836              /* Calculate the mask to set */
    837              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
    838              /* Set the SQx bits for the selected rank */
    839              tmpreg1 |= tmpreg2;
    840              /* Store the new register value */
    841              ADCx->SQR3 = tmpreg1;
    842            }
    843            /* For Rank 7 to 12 */
    844            else if (Rank < 13)
    845            {
    846              /* Get the old register value */
    847              tmpreg1 = ADCx->SQR2;
    848              /* Calculate the mask to clear */
    849              tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
    850              /* Clear the old SQx bits for the selected rank */
    851              tmpreg1 &= ~tmpreg2;
    852              /* Calculate the mask to set */
    853              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
    854              /* Set the SQx bits for the selected rank */
    855              tmpreg1 |= tmpreg2;
    856              /* Store the new register value */
    857              ADCx->SQR2 = tmpreg1;
    858            }
    859            /* For Rank 13 to 16 */
    860            else
    861            {
    862              /* Get the old register value */
    863              tmpreg1 = ADCx->SQR1;
    864              /* Calculate the mask to clear */
    865              tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
    866              /* Clear the old SQx bits for the selected rank */
    867              tmpreg1 &= ~tmpreg2;
    868              /* Calculate the mask to set */
    869              tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
    870              /* Set the SQx bits for the selected rank */
    871              tmpreg1 |= tmpreg2;
    872              /* Store the new register value */
    873              ADCx->SQR1 = tmpreg1;
    874            }
    875          }
    876          
    877          /**
    878            * @brief  Enables or disables the ADCx conversion through external trigger.
    879            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    880            * @param  NewState: new state of the selected ADC external trigger start of conversion.
    881            *   This parameter can be: ENABLE or DISABLE.
    882            * @retval None
    883            */
    884          void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    885          {
    886            /* Check the parameters */
    887            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    888            assert_param(IS_FUNCTIONAL_STATE(NewState));
    889            if (NewState != DISABLE)
    890            {
    891              /* Enable the selected ADC conversion on external event */
    892              ADCx->CR2 |= CR2_EXTTRIG_Set;
    893            }
    894            else
    895            {
    896              /* Disable the selected ADC conversion on external event */
    897              ADCx->CR2 &= CR2_EXTTRIG_Reset;
    898            }
    899          }
    900          
    901          /**
    902            * @brief  Returns the last ADCx conversion result data for regular channel.
    903            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    904            * @retval The Data conversion value.
    905            */
    906          uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
    907          {
    908            /* Check the parameters */
    909            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    910            /* Return the selected ADC conversion value */
    911            return (uint16_t) ADCx->DR;
    912          }
    913          
    914          /**
    915            * @brief  Returns the last ADC1 and ADC2 conversion result data in dual mode.
    916            * @retval The Data conversion value.
    917            */
    918          uint32_t ADC_GetDualModeConversionValue(void)
    919          {
    920            /* Return the dual mode conversion value */
    921            return (*(__IO uint32_t *) DR_ADDRESS);
    922          }
    923          
    924          /**
    925            * @brief  Enables or disables the selected ADC automatic injected group
    926            *         conversion after regular one.
    927            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    928            * @param  NewState: new state of the selected ADC auto injected conversion
    929            *   This parameter can be: ENABLE or DISABLE.
    930            * @retval None
    931            */
    932          void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    933          {
    934            /* Check the parameters */
    935            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    936            assert_param(IS_FUNCTIONAL_STATE(NewState));
    937            if (NewState != DISABLE)
    938            {
    939              /* Enable the selected ADC automatic injected group conversion */
    940              ADCx->CR1 |= CR1_JAUTO_Set;
    941            }
    942            else
    943            {
    944              /* Disable the selected ADC automatic injected group conversion */
    945              ADCx->CR1 &= CR1_JAUTO_Reset;
    946            }
    947          }
    948          
    949          /**
    950            * @brief  Enables or disables the discontinuous mode for injected group
    951            *         channel for the specified ADC
    952            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    953            * @param  NewState: new state of the selected ADC discontinuous mode
    954            *         on injected group channel.
    955            *   This parameter can be: ENABLE or DISABLE.
    956            * @retval None
    957            */
    958          void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
    959          {
    960            /* Check the parameters */
    961            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    962            assert_param(IS_FUNCTIONAL_STATE(NewState));
    963            if (NewState != DISABLE)
    964            {
    965              /* Enable the selected ADC injected discontinuous mode */
    966              ADCx->CR1 |= CR1_JDISCEN_Set;
    967            }
    968            else
    969            {
    970              /* Disable the selected ADC injected discontinuous mode */
    971              ADCx->CR1 &= CR1_JDISCEN_Reset;
    972            }
    973          }
    974          
    975          /**
    976            * @brief  Configures the ADCx external trigger for injected channels conversion.
    977            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    978            * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected conversion. 
    979            *   This parameter can be one of the following values:
    980            *     @arg ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event selected (for ADC1, ADC2 and ADC3)
    981            *     @arg ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture compare4 selected (for ADC1, ADC2 and ADC3)
    982            *     @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected (for ADC1 and ADC2)
    983            *     @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected (for ADC1 and ADC2)
    984            *     @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected (for ADC1 and ADC2)
    985            *     @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected (for ADC1 and ADC2)
    986            *     @arg ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4: External interrupt line 15 or Timer8
    987            *                                                       capture compare4 event selected (for ADC1 and ADC2)                       
    988            *     @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected (for ADC3 only)
    989            *     @arg ADC_ExternalTrigInjecConv_T8_CC2: Timer8 capture compare2 selected (for ADC3 only)                         
    990            *     @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected (for ADC3 only)
    991            *     @arg ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event selected (for ADC3 only)                         
    992            *     @arg ADC_ExternalTrigInjecConv_T5_CC4: Timer5 capture compare4 selected (for ADC3 only)                        
    993            *     @arg ADC_ExternalTrigInjecConv_None: Injected conversion started by software and not
    994            *                                          by external trigger (for ADC1, ADC2 and ADC3)
    995            * @retval None
    996            */
    997          void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
    998          {
    999            uint32_t tmpreg = 0;
   1000            /* Check the parameters */
   1001            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1002            assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
   1003            /* Get the old register value */
   1004            tmpreg = ADCx->CR2;
   1005            /* Clear the old external event selection for injected group */
   1006            tmpreg &= CR2_JEXTSEL_Reset;
   1007            /* Set the external event selection for injected group */
   1008            tmpreg |= ADC_ExternalTrigInjecConv;
   1009            /* Store the new register value */
   1010            ADCx->CR2 = tmpreg;
   1011          }
   1012          
   1013          /**
   1014            * @brief  Enables or disables the ADCx injected channels conversion through
   1015            *         external trigger
   1016            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1017            * @param  NewState: new state of the selected ADC external trigger start of
   1018            *         injected conversion.
   1019            *   This parameter can be: ENABLE or DISABLE.
   1020            * @retval None
   1021            */
   1022          void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1023          {
   1024            /* Check the parameters */
   1025            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1026            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1027            if (NewState != DISABLE)
   1028            {
   1029              /* Enable the selected ADC external event selection for injected group */
   1030              ADCx->CR2 |= CR2_JEXTTRIG_Set;
   1031            }
   1032            else
   1033            {
   1034              /* Disable the selected ADC external event selection for injected group */
   1035              ADCx->CR2 &= CR2_JEXTTRIG_Reset;
   1036            }
   1037          }
   1038          
   1039          /**
   1040            * @brief  Enables or disables the selected ADC start of the injected 
   1041            *         channels conversion.
   1042            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1043            * @param  NewState: new state of the selected ADC software start injected conversion.
   1044            *   This parameter can be: ENABLE or DISABLE.
   1045            * @retval None
   1046            */
   1047          void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
   1048          {
   1049            /* Check the parameters */
   1050            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1051            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1052            if (NewState != DISABLE)
   1053            {
   1054              /* Enable the selected ADC conversion for injected group on external event and start the selected
   1055                 ADC injected conversion */
   1056              ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
   1057            }
   1058            else
   1059            {
   1060              /* Disable the selected ADC conversion on external event for injected group and stop the selected
   1061                 ADC injected conversion */
   1062              ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
   1063            }
   1064          }
   1065          
   1066          /**
   1067            * @brief  Gets the selected ADC Software start injected conversion Status.
   1068            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1069            * @retval The new state of ADC software start injected conversion (SET or RESET).
   1070            */
   1071          FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
   1072          {
   1073            FlagStatus bitstatus = RESET;
   1074            /* Check the parameters */
   1075            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1076            /* Check the status of JSWSTART bit */
   1077            if ((ADCx->CR2 & CR2_JSWSTART_Set) != (uint32_t)RESET)
   1078            {
   1079              /* JSWSTART bit is set */
   1080              bitstatus = SET;
   1081            }
   1082            else
   1083            {
   1084              /* JSWSTART bit is reset */
   1085              bitstatus = RESET;
   1086            }
   1087            /* Return the JSWSTART bit status */
   1088            return  bitstatus;
   1089          }
   1090          
   1091          /**
   1092            * @brief  Configures for the selected ADC injected channel its corresponding
   1093            *         rank in the sequencer and its sample time.
   1094            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1095            * @param  ADC_Channel: the ADC channel to configure. 
   1096            *   This parameter can be one of the following values:
   1097            *     @arg ADC_Channel_0: ADC Channel0 selected
   1098            *     @arg ADC_Channel_1: ADC Channel1 selected
   1099            *     @arg ADC_Channel_2: ADC Channel2 selected
   1100            *     @arg ADC_Channel_3: ADC Channel3 selected
   1101            *     @arg ADC_Channel_4: ADC Channel4 selected
   1102            *     @arg ADC_Channel_5: ADC Channel5 selected
   1103            *     @arg ADC_Channel_6: ADC Channel6 selected
   1104            *     @arg ADC_Channel_7: ADC Channel7 selected
   1105            *     @arg ADC_Channel_8: ADC Channel8 selected
   1106            *     @arg ADC_Channel_9: ADC Channel9 selected
   1107            *     @arg ADC_Channel_10: ADC Channel10 selected
   1108            *     @arg ADC_Channel_11: ADC Channel11 selected
   1109            *     @arg ADC_Channel_12: ADC Channel12 selected
   1110            *     @arg ADC_Channel_13: ADC Channel13 selected
   1111            *     @arg ADC_Channel_14: ADC Channel14 selected
   1112            *     @arg ADC_Channel_15: ADC Channel15 selected
   1113            *     @arg ADC_Channel_16: ADC Channel16 selected
   1114            *     @arg ADC_Channel_17: ADC Channel17 selected
   1115            * @param  Rank: The rank in the injected group sequencer. This parameter must be between 1 and 4.
   1116            * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
   1117            *   This parameter can be one of the following values:
   1118            *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
   1119            *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
   1120            *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
   1121            *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
   1122            *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
   1123            *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
   1124            *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
   1125            *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
   1126            * @retval None
   1127            */
   1128          void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
   1129          {
   1130            uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
   1131            /* Check the parameters */
   1132            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1133            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   1134            assert_param(IS_ADC_INJECTED_RANK(Rank));
   1135            assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
   1136            /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
   1137            if (ADC_Channel > ADC_Channel_9)
   1138            {
   1139              /* Get the old register value */
   1140              tmpreg1 = ADCx->SMPR1;
   1141              /* Calculate the mask to clear */
   1142              tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
   1143              /* Clear the old channel sample time */
   1144              tmpreg1 &= ~tmpreg2;
   1145              /* Calculate the mask to set */
   1146              tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
   1147              /* Set the new channel sample time */
   1148              tmpreg1 |= tmpreg2;
   1149              /* Store the new register value */
   1150              ADCx->SMPR1 = tmpreg1;
   1151            }
   1152            else /* ADC_Channel include in ADC_Channel_[0..9] */
   1153            {
   1154              /* Get the old register value */
   1155              tmpreg1 = ADCx->SMPR2;
   1156              /* Calculate the mask to clear */
   1157              tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
   1158              /* Clear the old channel sample time */
   1159              tmpreg1 &= ~tmpreg2;
   1160              /* Calculate the mask to set */
   1161              tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
   1162              /* Set the new channel sample time */
   1163              tmpreg1 |= tmpreg2;
   1164              /* Store the new register value */
   1165              ADCx->SMPR2 = tmpreg1;
   1166            }
   1167            /* Rank configuration */
   1168            /* Get the old register value */
   1169            tmpreg1 = ADCx->JSQR;
   1170            /* Get JL value: Number = JL+1 */
   1171            tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
   1172            /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
   1173            tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   1174            /* Clear the old JSQx bits for the selected rank */
   1175            tmpreg1 &= ~tmpreg2;
   1176            /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
   1177            tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
   1178            /* Set the JSQx bits for the selected rank */
   1179            tmpreg1 |= tmpreg2;
   1180            /* Store the new register value */
   1181            ADCx->JSQR = tmpreg1;
   1182          }
   1183          
   1184          /**
   1185            * @brief  Configures the sequencer length for injected channels
   1186            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1187            * @param  Length: The sequencer length. 
   1188            *   This parameter must be a number between 1 to 4.
   1189            * @retval None
   1190            */
   1191          void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
   1192          {
   1193            uint32_t tmpreg1 = 0;
   1194            uint32_t tmpreg2 = 0;
   1195            /* Check the parameters */
   1196            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1197            assert_param(IS_ADC_INJECTED_LENGTH(Length));
   1198            
   1199            /* Get the old register value */
   1200            tmpreg1 = ADCx->JSQR;
   1201            /* Clear the old injected sequnence lenght JL bits */
   1202            tmpreg1 &= JSQR_JL_Reset;
   1203            /* Set the injected sequnence lenght JL bits */
   1204            tmpreg2 = Length - 1; 
   1205            tmpreg1 |= tmpreg2 << 20;
   1206            /* Store the new register value */
   1207            ADCx->JSQR = tmpreg1;
   1208          }
   1209          
   1210          /**
   1211            * @brief  Set the injected channels conversion value offset
   1212            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1213            * @param  ADC_InjectedChannel: the ADC injected channel to set its offset. 
   1214            *   This parameter can be one of the following values:
   1215            *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1216            *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1217            *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1218            *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1219            * @param  Offset: the offset value for the selected ADC injected channel
   1220            *   This parameter must be a 12bit value.
   1221            * @retval None
   1222            */
   1223          void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
   1224          {
   1225            __IO uint32_t tmp = 0;
   1226            
   1227            /* Check the parameters */
   1228            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1229            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1230            assert_param(IS_ADC_OFFSET(Offset));  
   1231            
   1232            tmp = (uint32_t)ADCx;
   1233            tmp += ADC_InjectedChannel;
   1234            
   1235            /* Set the selected injected channel data offset */
   1236            *(__IO uint32_t *) tmp = (uint32_t)Offset;
   1237          }
   1238          
   1239          /**
   1240            * @brief  Returns the ADC injected channel conversion result
   1241            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1242            * @param  ADC_InjectedChannel: the converted ADC injected channel.
   1243            *   This parameter can be one of the following values:
   1244            *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
   1245            *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
   1246            *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
   1247            *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
   1248            * @retval The Data conversion value.
   1249            */
   1250          uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
   1251          {
   1252            __IO uint32_t tmp = 0;
   1253            
   1254            /* Check the parameters */
   1255            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1256            assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
   1257          
   1258            tmp = (uint32_t)ADCx;
   1259            tmp += ADC_InjectedChannel + JDR_Offset;
   1260            
   1261            /* Returns the selected injected channel conversion data value */
   1262            return (uint16_t) (*(__IO uint32_t*)  tmp);   
   1263          }
   1264          
   1265          /**
   1266            * @brief  Enables or disables the analog watchdog on single/all regular
   1267            *         or injected channels
   1268            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1269            * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
   1270            *   This parameter can be one of the following values:
   1271            *     @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single regular channel
   1272            *     @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single injected channel
   1273            *     @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a single regular or injected channel
   1274            *     @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on  all regular channel
   1275            *     @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on  all injected channel
   1276            *     @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels
   1277            *     @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
   1278            * @retval None	  
   1279            */
   1280          void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
   1281          {
   1282            uint32_t tmpreg = 0;
   1283            /* Check the parameters */
   1284            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1285            assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
   1286            /* Get the old register value */
   1287            tmpreg = ADCx->CR1;
   1288            /* Clear AWDEN, AWDENJ and AWDSGL bits */
   1289            tmpreg &= CR1_AWDMode_Reset;
   1290            /* Set the analog watchdog enable mode */
   1291            tmpreg |= ADC_AnalogWatchdog;
   1292            /* Store the new register value */
   1293            ADCx->CR1 = tmpreg;
   1294          }
   1295          
   1296          /**
   1297            * @brief  Configures the high and low thresholds of the analog watchdog.
   1298            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1299            * @param  HighThreshold: the ADC analog watchdog High threshold value.
   1300            *   This parameter must be a 12bit value.
   1301            * @param  LowThreshold: the ADC analog watchdog Low threshold value.
   1302            *   This parameter must be a 12bit value.
   1303            * @retval None
   1304            */
   1305          void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
   1306                                                  uint16_t LowThreshold)
   1307          {
   1308            /* Check the parameters */
   1309            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1310            assert_param(IS_ADC_THRESHOLD(HighThreshold));
   1311            assert_param(IS_ADC_THRESHOLD(LowThreshold));
   1312            /* Set the ADCx high threshold */
   1313            ADCx->HTR = HighThreshold;
   1314            /* Set the ADCx low threshold */
   1315            ADCx->LTR = LowThreshold;
   1316          }
   1317          
   1318          /**
   1319            * @brief  Configures the analog watchdog guarded single channel
   1320            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1321            * @param  ADC_Channel: the ADC channel to configure for the analog watchdog. 
   1322            *   This parameter can be one of the following values:
   1323            *     @arg ADC_Channel_0: ADC Channel0 selected
   1324            *     @arg ADC_Channel_1: ADC Channel1 selected
   1325            *     @arg ADC_Channel_2: ADC Channel2 selected
   1326            *     @arg ADC_Channel_3: ADC Channel3 selected
   1327            *     @arg ADC_Channel_4: ADC Channel4 selected
   1328            *     @arg ADC_Channel_5: ADC Channel5 selected
   1329            *     @arg ADC_Channel_6: ADC Channel6 selected
   1330            *     @arg ADC_Channel_7: ADC Channel7 selected
   1331            *     @arg ADC_Channel_8: ADC Channel8 selected
   1332            *     @arg ADC_Channel_9: ADC Channel9 selected
   1333            *     @arg ADC_Channel_10: ADC Channel10 selected
   1334            *     @arg ADC_Channel_11: ADC Channel11 selected
   1335            *     @arg ADC_Channel_12: ADC Channel12 selected
   1336            *     @arg ADC_Channel_13: ADC Channel13 selected
   1337            *     @arg ADC_Channel_14: ADC Channel14 selected
   1338            *     @arg ADC_Channel_15: ADC Channel15 selected
   1339            *     @arg ADC_Channel_16: ADC Channel16 selected
   1340            *     @arg ADC_Channel_17: ADC Channel17 selected
   1341            * @retval None
   1342            */
   1343          void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
   1344          {
   1345            uint32_t tmpreg = 0;
   1346            /* Check the parameters */
   1347            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1348            assert_param(IS_ADC_CHANNEL(ADC_Channel));
   1349            /* Get the old register value */
   1350            tmpreg = ADCx->CR1;
   1351            /* Clear the Analog watchdog channel select bits */
   1352            tmpreg &= CR1_AWDCH_Reset;
   1353            /* Set the Analog watchdog channel */
   1354            tmpreg |= ADC_Channel;
   1355            /* Store the new register value */
   1356            ADCx->CR1 = tmpreg;
   1357          }
   1358          
   1359          /**
   1360            * @brief  Enables or disables the temperature sensor and Vrefint channel.
   1361            * @param  NewState: new state of the temperature sensor.
   1362            *   This parameter can be: ENABLE or DISABLE.
   1363            * @retval None
   1364            */
   1365          void ADC_TempSensorVrefintCmd(FunctionalState NewState)
   1366          {
   1367            /* Check the parameters */
   1368            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1369            if (NewState != DISABLE)
   1370            {
   1371              /* Enable the temperature sensor and Vrefint channel*/
   1372              ADC1->CR2 |= CR2_TSVREFE_Set;
   1373            }
   1374            else
   1375            {
   1376              /* Disable the temperature sensor and Vrefint channel*/
   1377              ADC1->CR2 &= CR2_TSVREFE_Reset;
   1378            }
   1379          }
   1380          
   1381          /**
   1382            * @brief  Checks whether the specified ADC flag is set or not.
   1383            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1384            * @param  ADC_FLAG: specifies the flag to check. 
   1385            *   This parameter can be one of the following values:
   1386            *     @arg ADC_FLAG_AWD: Analog watchdog flag
   1387            *     @arg ADC_FLAG_EOC: End of conversion flag
   1388            *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1389            *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1390            *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1391            * @retval The new state of ADC_FLAG (SET or RESET).
   1392            */
   1393          FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
   1394          {
   1395            FlagStatus bitstatus = RESET;
   1396            /* Check the parameters */
   1397            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1398            assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
   1399            /* Check the status of the specified ADC flag */
   1400            if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   1401            {
   1402              /* ADC_FLAG is set */
   1403              bitstatus = SET;
   1404            }
   1405            else
   1406            {
   1407              /* ADC_FLAG is reset */
   1408              bitstatus = RESET;
   1409            }
   1410            /* Return the ADC_FLAG status */
   1411            return  bitstatus;
   1412          }
   1413          
   1414          /**
   1415            * @brief  Clears the ADCx's pending flags.
   1416            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1417            * @param  ADC_FLAG: specifies the flag to clear. 
   1418            *   This parameter can be any combination of the following values:
   1419            *     @arg ADC_FLAG_AWD: Analog watchdog flag
   1420            *     @arg ADC_FLAG_EOC: End of conversion flag
   1421            *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
   1422            *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
   1423            *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
   1424            * @retval None
   1425            */
   1426          void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
   1427          {
   1428            /* Check the parameters */
   1429            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1430            assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
   1431            /* Clear the selected ADC flags */
   1432            ADCx->SR = ~(uint32_t)ADC_FLAG;
   1433          }
   1434          
   1435          /**
   1436            * @brief  Checks whether the specified ADC interrupt has occurred or not.
   1437            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1438            * @param  ADC_IT: specifies the ADC interrupt source to check. 
   1439            *   This parameter can be one of the following values:
   1440            *     @arg ADC_IT_EOC: End of conversion interrupt mask
   1441            *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1442            *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1443            * @retval The new state of ADC_IT (SET or RESET).
   1444            */
   1445          ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1446          {
   1447            ITStatus bitstatus = RESET;
   1448            uint32_t itmask = 0, enablestatus = 0;
   1449            /* Check the parameters */
   1450            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1451            assert_param(IS_ADC_GET_IT(ADC_IT));
   1452            /* Get the ADC IT index */
   1453            itmask = ADC_IT >> 8;
   1454            /* Get the ADC_IT enable bit status */
   1455            enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;
   1456            /* Check the status of the specified ADC interrupt */
   1457            if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
   1458            {
   1459              /* ADC_IT is set */
   1460              bitstatus = SET;
   1461            }
   1462            else
   1463            {
   1464              /* ADC_IT is reset */
   1465              bitstatus = RESET;
   1466            }
   1467            /* Return the ADC_IT status */
   1468            return  bitstatus;
   1469          }
   1470          
   1471          /**
   1472            * @brief  Clears the ADCx's interrupt pending bits.
   1473            * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
   1474            * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
   1475            *   This parameter can be any combination of the following values:
   1476            *     @arg ADC_IT_EOC: End of conversion interrupt mask
   1477            *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
   1478            *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
   1479            * @retval None
   1480            */
   1481          void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
   1482          {
   1483            uint8_t itmask = 0;
   1484            /* Check the parameters */
   1485            assert_param(IS_ADC_ALL_PERIPH(ADCx));
   1486            assert_param(IS_ADC_IT(ADC_IT));
   1487            /* Get the ADC IT index */
   1488            itmask = (uint8_t)(ADC_IT >> 8);
   1489            /* Clear the selected ADC interrupt pending bits */
   1490            ADCx->SR = ~(uint32_t)itmask;
   1491          }
   1492          
   1493          /**
   1494            * @brief  Initilize ADC1 common registers for channel1 and channel13.
   1495            * @param  None.
   1496            * @retval None
   1497            */
   1498          void ADC1_Initialize(void)
   1499          {
   1500          	ADC_InitTypeDef  ADC_InitStructure;
   1501          	GPIO_InitTypeDef GPIO_InitStructure;
   1502          //	DMA_InitTypeDef DMA_InitStructure;
   1503          	/* Enable ADC1 clocks */
   1504          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
   1505          	/* Enable DMA clock */
   1506          //	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
   1507          
   1508              GPIO_InitStructure.GPIO_Pin  =GPIO_Pin_1;
   1509          	GPIO_InitStructure.GPIO_Mode =GPIO_Mode_AIN;
   1510          	GPIO_Init(GPIOA,&GPIO_InitStructure);
   1511              
   1512           	GPIO_InitStructure.GPIO_Pin  =GPIO_Pin_3;
   1513          	GPIO_InitStructure.GPIO_Mode =GPIO_Mode_AIN;
   1514          	GPIO_Init(GPIOC,&GPIO_InitStructure);   
   1515              
   1516          	ADC_InitStructure.ADC_Mode              = ADC_Mode_Independent;  //
   1517          	ADC_InitStructure.ADC_ScanConvMode      =DISABLE;      //
   1518          	ADC_InitStructure.ADC_ContinuousConvMode =DISABLE;      //
   1519          	ADC_InitStructure.ADC_ExternalTrigConv  = ADC_ExternalTrigConv_None; //
   1520          	ADC_InitStructure.ADC_DataAlign         =ADC_DataAlign_Left;   //
   1521          	ADC_InitStructure.ADC_NbrOfChannel      =1;       //Scan channel number
   1522          	ADC_Init(ADC1,&ADC_InitStructure);
   1523          	// config the ADC clock
   1524          	RCC_ADCCLKConfig(RCC_PCLK2_Div8);
   1525          
   1526          	/* Enable ADC1 */
   1527          	ADC_Cmd(ADC1, ENABLE);
   1528                  
   1529              ADC_ResetCalibration(ADC1);
   1530          	/* Check the end of ADC1 reset calibration register */
   1531          	while(ADC_GetResetCalibrationStatus(ADC1));
   1532          	/* Start ADC1 calibaration */
   1533          	ADC_StartCalibration(ADC1);
   1534          	/* Check the end of ADC1 calibration */
   1535          	while(ADC_GetCalibrationStatus(ADC1));
   1536          }
   1537          
   1538          
   1539          
   1540          
   1541          /**
   1542            * @}
   1543            */
   1544          
   1545          /**
   1546            * @}
   1547            */
   1548          
   1549          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   ADC1_Initialize
        32   -> ADC_Cmd
        32   -> ADC_GetCalibrationStatus
        32   -> ADC_GetResetCalibrationStatus
        32   -> ADC_Init
        32   -> ADC_ResetCalibration
        32   -> ADC_StartCalibration
        32   -> GPIO_Init
        32   -> RCC_ADCCLKConfig
        32   -> RCC_APB2PeriphClockCmd
       0   ADC_AnalogWatchdogCmd
       0   ADC_AnalogWatchdogSingleChannelConfig
       0   ADC_AnalogWatchdogThresholdsConfig
       0   ADC_AutoInjectedConvCmd
       0   ADC_ClearFlag
       0   ADC_ClearITPendingBit
       0   ADC_Cmd
       0   ADC_DMACmd
       8   ADC_DeInit
         8   -> RCC_APB2PeriphResetCmd
       0   ADC_DiscModeChannelCountConfig
       0   ADC_DiscModeCmd
       0   ADC_ExternalTrigConvCmd
       0   ADC_ExternalTrigInjectedConvCmd
       0   ADC_ExternalTrigInjectedConvConfig
       0   ADC_GetCalibrationStatus
       0   ADC_GetConversionValue
       0   ADC_GetDualModeConversionValue
       0   ADC_GetFlagStatus
       0   ADC_GetITStatus
       4   ADC_GetInjectedConversionValue
       0   ADC_GetResetCalibrationStatus
       0   ADC_GetSoftwareStartConvStatus
       0   ADC_GetSoftwareStartInjectedConvCmdStatus
       0   ADC_ITConfig
       8   ADC_Init
      16   ADC_InjectedChannelConfig
       0   ADC_InjectedDiscModeCmd
       0   ADC_InjectedSequencerLengthConfig
      16   ADC_RegularChannelConfig
       0   ADC_ResetCalibration
       4   ADC_SetInjectedOffset
       0   ADC_SoftwareStartConvCmd
       0   ADC_SoftwareStartInjectedConvCmd
       0   ADC_StartCalibration
       0   ADC_StructInit
       0   ADC_TempSensorVrefintCmd
       8   AD_Read
         8   -> ADC_GetConversionValue
         8   -> ad_13_initialize
         8   -> ad_1_initialize
         8   -> uDelay
       8   ad_13_initialize
         8   -> ADC_RegularChannelConfig
         8   -> ADC_SoftwareStartConvCmd
       8   ad_1_initialize
         8   -> ADC_RegularChannelConfig
         8   -> ADC_SoftwareStartConvCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
     148  ADC1_Initialize
      14  ADC_AnalogWatchdogCmd
      16  ADC_AnalogWatchdogSingleChannelConfig
      10  ADC_AnalogWatchdogThresholdsConfig
      26  ADC_AutoInjectedConvCmd
       8  ADC_ClearFlag
      14  ADC_ClearITPendingBit
      26  ADC_Cmd
      26  ADC_DMACmd
      32  ADC_DeInit
      22  ADC_DiscModeChannelCountConfig
      26  ADC_DiscModeCmd
      26  ADC_ExternalTrigConvCmd
      26  ADC_ExternalTrigInjectedConvCmd
      14  ADC_ExternalTrigInjectedConvConfig
      20  ADC_GetCalibrationStatus
       6  ADC_GetConversionValue
       6  ADC_GetDualModeConversionValue
      22  ADC_GetFlagStatus
      42  ADC_GetITStatus
      28  ADC_GetInjectedConversionValue
      20  ADC_GetResetCalibrationStatus
      20  ADC_GetSoftwareStartConvStatus
      20  ADC_GetSoftwareStartInjectedConvCmdStatus
      30  ADC_ITConfig
      74  ADC_Init
     132  ADC_InjectedChannelConfig
      26  ADC_InjectedDiscModeCmd
      22  ADC_InjectedSequencerLengthConfig
     196  ADC_RegularChannelConfig
      10  ADC_ResetCalibration
      26  ADC_SetInjectedOffset
      26  ADC_SoftwareStartConvCmd
      26  ADC_SoftwareStartInjectedConvCmd
      10  ADC_StartCalibration
      26  ADC_StructInit
      34  ADC_TempSensorVrefintCmd
      94  AD_Read
      44  ad_13_initialize
       4  ad_13_initialized
      44  ad_1_initialize
       4  ad_1_initialized
       2  adc_initialized_channel

 
    10 bytes in section .bss
 1 482 bytes in section .text
 
 1 482 bytes of CODE memory
    10 bytes of DATA memory

Errors: none
Warnings: 3
