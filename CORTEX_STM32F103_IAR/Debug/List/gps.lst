###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.2.11947/W32 for ARM       15/Sep/2017  09:59:24
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\workspace\dr002\dr002_suming\v1_board\main_app\GPS\gps.c
#    Command line =  
#        D:\workspace\dr002\dr002_suming\v1_board\main_app\GPS\gps.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -lcN
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\List
#        --diag_suppress Pa050 -o
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\.\ -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Diag_Factory\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\common\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\power\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\SysMan\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Protocol\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\include\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\FreeRTOS\include\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\FreeRTOS\portable\IAR\ARM_CM3\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\drivers\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\GPS\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\GPRS\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Sensors\
#        -Ol --use_c++_inline --require_prototypes
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\List\gps.lst
#    Object file  =  
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\Obj\gps.o
#
###############################################################################

D:\workspace\dr002\dr002_suming\v1_board\main_app\GPS\gps.c
      1          /*----------------------------------------------------------------------------/
      2           *  (C)Dedao, 2016
      3           *-----------------------------------------------------------------------------/
      4           *
      5           * Copyright (C) 2016, Dedao, all right reserved.
      6           *
      7           * 1. Redistributions of source code must retain the above copyright notice,
      8           *    this condition and the following disclaimer.
      9           *
     10           * This software is provided by the copyright holder and contributors "AS IS"
     11           * and any warranties related to this software are DISCLAIMED.
     12           * The copyright owner or contributors be NOT LIABLE for any damages caused
     13           * by use of this software.
     14           *----------------------------------------------------------------------------*/
     15          
     16          /**********************************************************************
     17             Title                      : gps.c         
     18                                                                                   
     19             Module Description         : GPS. This file is the communication task
     20                                                  with gps modlue.
     21          
     22             Author                     : 
     23             
     24           *********************************************************************/
     25          #include <stdio.h>
     26          #include "standard.h"
     27          #include "gps.h"
     28          #include "uart.h"
     29          #include "ring_buf.h"
     30          
     31          //#define USE_DEBUG
     32          #include "Debug.h"
     33          
     34          /**********************************************************************
     35           * Constant and Macro Definitions using #define
     36           *********************************************************************/
     37          #define GPS_DEBUG_BOARD false
     38          #define GPS_DEBUG_VALUE false
     39          #define GPS_DEBUG_MUTEX false
     40          
     41          #if GPS_DEBUG_BOARD
     42          #define GPS_CHANNEL   UART_CONF_CMMB
     43          #define GPS_BAUD_RATE  UART_BAUD_9600
     44          #define GPS_UART_CONFIG  (UART_LSB_FIRST | UART_PARITY_NONE | UART_DATA_BIT_8 | UART_STOP_ONE )
     45          #endif //GPS_DEBUG_BOARD
     46          
     47          #define FRAME_START_CHAR    0x24
     48          #define FIRST_END_SYNC_CHAR                      0x0D
     49          #define SECOND_END_SYNC_CHAR                 0x0A
     50          #define NO_ERROR   0x00
     51          
     52          #define NMEA_CHKSUM_LENGTH           3      //include "*" charcter
     53          #define ASCII_TO_HEX_VALUE               0x30
     54          #define COLON_CH                                   0x3A //":"
     55          #define SLASH_CH                            0x2F //"/"
     56          
     57          #define ZERO_CH                                        0x30
     58          
     59          #define KNOTS_DIV (1943844)
     60          
     61          /**********************************************************************
     62           * Global and Const Variable Defining Definitions / Initializations
     63           *********************************************************************/
     64          
     65          /**********************************************************************
     66           * Static Variables and Const Variables With File Level Scope
     67           *********************************************************************/
     68          static Ring_Buf_Type       gps_rx_ring_control;
     69          static gps_data_frame_t   gps_rx_ring_buffer[GPS_RX_RING_BUF_SIZE];
     70          static gps_rx_err_t       gps_rx_err;
     71          static gps_data_t          gps_data;
     72          static gps_data_t          last_gps_data;
     73          
     74          static Ring_Buf_Type    gps_data_ring_control;
     75          static GPS_log_t   gps_data_ring_buffer[GPS_DATA_RING_BUF_SIZE];
     76          
     77          #define UBX_Ready_To_Receive_Data()    (!Ring_Buf_Is_Full(&gps_rx_ring_control))
     78          #define GPS_Data_Buf_Full()    (Ring_Buf_Is_Full(&gps_data_ring_control))
     79          
     80          #if GPS_DEBUG_VALUE
     81          static uint8_t gps_debug_flag;
     82          #endif
     83          
     84          // In 0.1m
     85          static uint32_t trip_distance=0;
     86          // 0 for trip end; 1 for trip start.
     87          static uint32_t trip_start_flag=0;
     88          
     89          static bool gps_data_ready_flag = true;
     90          /**********************************************************************
     91           * Function Prototypes for Private Functions with File Level Scope
     92           *********************************************************************/
     93          static void GPS_COM_Initialize(void);
     94          static void GPS_Module_Initialization(void);
     95          static bool Gps_any_received_frames(void);
     96          static void Gps_check_receive(void);
     97          static void Gps_Rx_Data_Byte(uint8_t data, uint8_t error);
     98          static void GPS_Validate_Rx_Frame_Data(const uint8_t* rx_buffer, uint8_t num_bytes);
     99          static void gps_evt_nop(int16_t data);
    100          static void GPS_update_last(void);
    101          
    102          static gps_data_frame_t* Gps_received_frame(void);
    103          
    104          static bool NMEA_GNGGA_Msg_Decode(uint8_t * rx_buf);
    105          static bool NMEA_GPGLL_Msg_Decode(uint8_t * rx_buf);
    106          static bool NMEA_GPRMC_Msg_Decode(uint8_t * rx_buf);
    107          #if GPS_CHECK_SATSIG
    108          static bool NMEA_GPGSV_Msg_Decode(uint8_t * rx_buf);
    109          static bool BD_BDGSV_Msg_Decode(uint8_t * rx_buf);
    110          static bool NMEA_GPGSA_Msg_Decode(uint8_t * rx_buf);
    111          static bool BD_BDGSA_Msg_Decode(uint8_t * rx_buf);
    112          #endif
    113          static bool GNSS_GNRMC_Msg_Decode(uint8_t * rx_buf);
    114          
    115          // Compress latitude, longitude and altitude to 4 bytes
    116          static void convert_gps_lon(uint8_t *gps_data, uint8_t *dst_buf);
    117          static void convert_gps_alt(uint8_t *gps_data, uint8_t *dst_buf);
    118          static void convert_gps_knot(uint8_t *gps_data, uint8_t *dst_buf);
    119          static void convert_gps_cog(uint8_t *gps_data, uint8_t *dst_buf);
    120          static void convert_gps_dop(uint8_t *gps_data, uint8_t *dst_buf);
    121          
    122          // Calculate trip mileage
    123          static void count_trip_mileage(uint8_t *speed);
    124          /*********************************************************************/
    125          /* ROM Const Variables With File Level Scope                         */
    126          /*********************************************************************/
    127          static const void_int16_fptr gps_event_handler[GPS_NUM_EVENTS] =
    128          {
    129              gps_evt_nop,
    130          };
    131          
    132          static const char* nmea_msg_add_string[NMEA_NUM_MSG] = 
    133          {
    134              "GNGGA",
    135              "GPGLL",
    136              "GPRMC",
    137          #if GPS_CHECK_SATSIG
    138              "GPGSV",
    139              "BDGSV",
    140              "GPGSA",
    141              "BDGSA",
    142          #endif
    143              "GNRMC",
    144          };
    145          
    146          static const nmea_decode_fptr nmea_decode_table[NMEA_NUM_MSG] =
    147          {
    148              NMEA_GNGGA_Msg_Decode,
    149              NMEA_GPGLL_Msg_Decode,
    150              NMEA_GPRMC_Msg_Decode,
    151          #if GPS_CHECK_SATSIG
    152              NMEA_GPGSV_Msg_Decode,
    153              BD_BDGSV_Msg_Decode,
    154              NMEA_GPGSA_Msg_Decode,
    155              BD_BDGSA_Msg_Decode,
    156          #endif
    157              GNSS_GNRMC_Msg_Decode
    158          };
    159          
    160          /**********************************************************************
    161           * Function Definitions
    162           *********************************************************************/
    163          //#if GPS_DEBUG
    164          /*******************************************************************************
    165          *    Function:  GPS_Task
    166          *
    167          *  Parameters:  None
    168          *     Returns:  None
    169          * Description:  TASK to handle communication between V850 and UBLOX GPS module.
    170          *******************************************************************************/
    171          extern void GPS_Task(void* pvParameters)
    172          {
    173              Data_Message_T msg;
    174              uint8_t data;
    175          
    176              #ifdef USE_DEBUG
    177              DEBUG_PRINT0( DEBUG_MEDIUM, "[GPS]:GPS TASK Started!\r\n");
    178              #endif
    179              
    180          #if 1
    181              GPS_COM_Initialize();
    182          
    183              GPS_Module_Initialization();
    184          #endif
    185          
    186              while(PS_Running()&&(Mdg_SW_Upgrage_mode==false))
    187              {
    188                  if(E_OK == OS_Wait_Message(OS_GPS_TASK, &msg.all, MSec_To_Ticks(500)))
    189                  {
    190                      if(msg.parts.msg < GPS_NUM_EVENTS)
    191                      {
    192                          if(NULL != gps_event_handler[msg.parts.msg])
    193                          {
    194                               (*gps_event_handler[msg.parts.msg])(msg.parts.data);
    195                          }
    196                      }
    197                  }
    198                  while (Uart_Get_Char(UART_GPS_CHANNEL,&data) == true)
    199                  {
    200                      Gps_Rx_Data_Byte(data,0x00);
    201                  }
    202                  do
    203                  {
    204                      Gps_check_receive();
    205                  }while(Gps_any_received_frames());
    206              }
    207              OS_Terminate_Task();
    208          }
    209          
    210          /*******************************************************************************
    211          *    Function:  vGps_Get_Gps_Status
    212          *
    213          *  Parameters:  GPS Infomation to return
    214          *     Returns:  None
    215          * Description:  GCOM_Initialize.
    216          *******************************************************************************/
    217          extern bool vGps_Get_Gps_Status(void)
    218          {
    219              return last_gps_data.valid;
    220          }
    221          
    222          /*******************************************************************************
    223          *    Function:  vGps_Get_Gps_Info
    224          *
    225          *  Parameters:  GPS Infomation to return
    226          *     Returns:  None
    227          * Description:  GCOM_Initialize.
    228          *******************************************************************************/
    229          extern void vGps_Get_Gps_Info(gps_data_t* gpsInfo)
    230          {
    231              /* to prevend gps_data from being accessed while reading gps_data */
    232              memcpy(gpsInfo,&last_gps_data,sizeof(gps_data_t));
    233          
    234          #ifdef USE_DUMMY_GPS_DATA
    235          
    236              gpsInfo->valid = true;
    237          
    238              gpsInfo->utc_time.utc_deal_time[0] = '2';
    239              gpsInfo->utc_time.utc_deal_time[1] = '0';
    240              gpsInfo->utc_time.utc_deal_time[2] = '1';
    241              gpsInfo->utc_time.utc_deal_time[3] = '4';
    242              gpsInfo->utc_time.utc_deal_time[4] = '0';
    243              gpsInfo->utc_time.utc_deal_time[5] = '1';
    244              gpsInfo->utc_time.utc_deal_time[6] = '0';
    245              gpsInfo->utc_time.utc_deal_time[7] = '1';
    246              gpsInfo->utc_time.utc_deal_time[8] = '0';
    247              gpsInfo->utc_time.utc_deal_time[9] = '0';
    248              gpsInfo->utc_time.utc_deal_time[10] = '0';
    249              gpsInfo->utc_time.utc_deal_time[11] = '0';
    250              gpsInfo->utc_time.utc_deal_time[12] = '0';
    251              gpsInfo->utc_time.utc_deal_time[13] = '0';
    252          #endif
    253              /* enable gps_data accessing */
    254          }
    255          
    256          /*******************************************************************************
    257          *    Function:  vGps_Get_Gps_Utc
    258          *
    259          *  Parameters:  GPS UTC to return
    260          *     Returns:  None
    261          * Description:  vGps_Get_Gps_Utc.
    262          *******************************************************************************/
    263          void vGps_Get_Gps_Utc(uint8_t* utc)
    264          {
    265          #ifdef USE_DUMMY_GPS_DATA
    266              gps_data.valid = true;
    267              gps_data.utc_time.utc_deal_time[0] = '2';
    268              gps_data.utc_time.utc_deal_time[1] = '0';
    269              gps_data.utc_time.utc_deal_time[2] = '1';
    270              gps_data.utc_time.utc_deal_time[3] = '6';
    271              gps_data.utc_time.utc_deal_time[4] = '1';
    272              gps_data.utc_time.utc_deal_time[5] = '1';
    273              gps_data.utc_time.utc_deal_time[6] = '2';
    274              gps_data.utc_time.utc_deal_time[7] = '9';
    275              gps_data.utc_time.utc_deal_time[8] = '0';
    276              gps_data.utc_time.utc_deal_time[9] = '0';
    277              gps_data.utc_time.utc_deal_time[10] = '0';
    278              gps_data.utc_time.utc_deal_time[11] = '0';
    279              gps_data.utc_time.utc_deal_time[12] = '0';
    280              gps_data.utc_time.utc_deal_time[13] = '0';
    281          #endif
    282          
    283              *utc = last_gps_data.valid;
    284              memcpy(utc+1,&last_gps_data.utc_time.utc_deal_time,16);
    285          }
    286          
    287          /*******************************************************************************
    288          *    Function:  store_gps_buf
    289          *
    290          *  Parameters:  GPS Infomation to return
    291          *     Returns:  None
    292          * Description:  Save GPS data.
    293          *******************************************************************************/
    294          static void store_gps_buf(gps_data_t buf)
    295          {
    296              GPS_log_t gps_data_tmp;
    297          
    298              Switch_GPS_Sturcture_data_to_log(buf, &gps_data_tmp);
    299              if (!GPS_Data_Buf_Full())
    300              {
    301                  memcpy(&gps_data_ring_buffer[gps_data_ring_control.in], &gps_data_tmp, GPS_LOG_LENGTH);
    302                  *((uint8_t *)&gps_data_ring_buffer[gps_data_ring_control.in]+ (GPS_LOG_LENGTH)) = 0;
    303                  Ring_Buf_Add(&gps_data_ring_control);
    304              }
    305              else
    306              {
    307                  Ring_Buf_Remove(&gps_data_ring_control);
    308                  memcpy(&gps_data_ring_buffer[gps_data_ring_control.in], &gps_data_tmp, GPS_LOG_LENGTH);
    309                  *((uint8_t *)&gps_data_ring_buffer[gps_data_ring_control.in]+ (GPS_LOG_LENGTH)) = 0;
    310                  Ring_Buf_Add(&gps_data_ring_control);
    311              }
    312          }
    313          
    314          uint8_t get_gps_buf(uint8_t *buf)
    315          {
    316              if (Ring_Buf_Is_Empty(&gps_data_ring_control))
    317              {
    318                  return 0;
    319              }
    320              else
    321              {
    322                  memcpy(buf, &gps_data_ring_buffer[gps_rx_ring_control.out], 26);
    323                  Ring_Buf_Remove(&gps_data_ring_control);
    324                  return 1;
    325              }
    326          }
    327          
    328          static void GPS_update_last(void)
    329          {
    330              memcpy(&last_gps_data,&gps_data,sizeof(gps_data_t));
    331              store_gps_buf(last_gps_data);
    332              if ((trip_start_flag==1) && last_gps_data.valid)
    333              {
    334                  count_trip_mileage(last_gps_data.speed);
    335              }
    336          }
    337          
    338          /*******************************************************************************
    339          *    Function:  GCOM_Initialize
    340          *
    341          *  Parameters:  None
    342          *     Returns:  None
    343          * Description:  GCOM_Initialize.
    344          *******************************************************************************/
    345          static void GPS_COM_Initialize(void)
    346          {
    347              gps_rx_err.error_flags = NO_ERROR;
    348              gps_data.valid = false;
    349          
    350              //Add the time fixed value
    351              gps_data.utc_time.gps_raw_time.utc_raw_year[0] = '2';
    352              gps_data.utc_time.gps_raw_time.utc_raw_year[1] = '0';
    353              Uart_Initialize(UART_GPS_CHANNEL);
    354              Ring_Buf_Reset(&gps_rx_ring_control, GPS_RX_RING_BUF_SIZE);
    355              Ring_Buf_Reset(&gps_data_ring_control, GPS_DATA_RING_BUF_SIZE);
    356          }
    357          
    358          
    359          /*******************************************************************************
    360          *    Function:  Gps_Rx_Data_Byte
    361          *
    362          *  Parameters:  None
    363          *  Returns:  None
    364          * Description:  Gps_Rx_Data_Byte.
    365          *******************************************************************************/
    366          static void Gps_Rx_Data_Byte(uint8_t data, uint8_t error)
    367          {
    368              static gps_rx_state_t gps_rx_state = RX_CS_IDLE;          
    369              static uint8_t rx_count = 0;
    370              static uint8_t gps_rx_buffer[GPS_RX_BUF_SIZE] = {0};
    371              uint8_t rx_data_byte_error = error & 0x07;   /*Mask Parity, Stop bit and Overrun errors*/
    372          
    373              static bool first_sync_ch_received = false;
    374          
    375              gps_rx_err.error_flags |= (error & 0x07); /*Mask Parity, Stop bit and Overrun errors*/
    376          
    377              switch(gps_rx_state)                   
    378              {
    379                  case RX_CS_IDLE:
    380                      if ((0x00 == rx_data_byte_error) && (FRAME_START_CHAR == data))/*Jump only if no error in rx byte*/
    381                      {
    382                          gps_rx_state = RX_CS_DATA;
    383                          memset(gps_rx_buffer, 0x00, GPS_RX_BUF_SIZE);
    384                          rx_count = 0;
    385          
    386                          gps_rx_err.error_flags = 0x00;
    387                      }
    388                      break;
    389          
    390                  case RX_CS_DATA:
    391                      if ((0x00 < rx_data_byte_error) )
    392                      {
    393                          gps_rx_state = RX_CS_IDLE; 
    394                      }
    395                      else if (FIRST_END_SYNC_CHAR == data)
    396                      {
    397                          first_sync_ch_received = true;
    398                          gps_rx_buffer[rx_count++] = data;
    399                      }
    400                      else if((SECOND_END_SYNC_CHAR == data) && first_sync_ch_received)
    401                      {
    402                          gps_rx_state = RX_CS_IDLE;
    403                          first_sync_ch_received = false;
    404                          GPS_Validate_Rx_Frame_Data(gps_rx_buffer, rx_count -1); //abandon first sync char
    405                          memset(gps_rx_buffer, 0x00, GPS_RX_BUF_SIZE);
    406                          rx_count = 0;
    407                      }
    408                      else
    409                      {
    410                          gps_rx_buffer[rx_count++] = data;
    411                          first_sync_ch_received = false;
    412                      }
    413                      break; 
    414          
    415                 default:              
    416                   gps_rx_state = RX_CS_IDLE;
    417                   break;
    418             }/*Switch*/
    419          }
    420          
    421          /*******************************************************************************
    422          *    Function:  GPS_Validate_Rx_Frame_Data
    423          *
    424          *  Parameters:  None
    425          *     Returns:  None
    426          * Description:  GPS_Validate_Rx_Frame_Data.
    427          *******************************************************************************/
    428          static void GPS_Validate_Rx_Frame_Data(const uint8_t* rx_buffer, uint8_t num_bytes)
    429          {
    430              uint8_t data_buffer[GPS_RX_BUF_SIZE];
    431              uint8_t cal_checksum;
    432              uint8_t index;
    433          
    434              if( num_bytes > GPS_RX_BUF_SIZE)
    435              {
    436                  num_bytes = GPS_RX_BUF_SIZE;  //be
    437              }
    438          
    439              if( num_bytes >= 10)
    440              {
    441                  memset(data_buffer, 0x00, GPS_RX_BUF_SIZE);
    442                  memcpy(data_buffer, rx_buffer, num_bytes);
    443          
    444                  //checksum compare.
    445                  cal_checksum = 0;
    446                  for(index = 0; index < num_bytes -NMEA_CHKSUM_LENGTH; index++)
    447                  {
    448                      cal_checksum ^= rx_buffer[index];
    449                  }
    450                  if(NO_ERROR == gps_rx_err.error_flags)
    451                  {
    452          #if 1
    453                      if (UBX_Ready_To_Receive_Data())
    454                      {
    455                         memcpy(&gps_rx_ring_buffer[gps_rx_ring_control.in], data_buffer, (num_bytes -NMEA_CHKSUM_LENGTH));   //don't copy checksum
    456                         *((uint8_t *)&gps_rx_ring_buffer[gps_rx_ring_control.in]+ (num_bytes -NMEA_CHKSUM_LENGTH)) = 0;
    457                         Ring_Buf_Add(&gps_rx_ring_control);    
    458                      }
    459                      else
    460                      {
    461                      }
    462          #endif
    463                  }
    464                  else
    465                  {
    466                  }
    467              }
    468          }
    469          /*******************************************************************************
    470          *    Function:  GPS_Module_Initialization
    471          *
    472          *  Parameters:  None
    473          *     Returns:  None
    474          * Description:  GPS_Module_Initialization.
    475          *******************************************************************************/
    476          static void GPS_Module_Initialization(void)
    477          {
    478              IO_3V3_GPS_EN_OUT(Bit_SET);
    479              IO_GPS_RESET_OUT(Bit_RESET);
    480          }
    481          
    482          
    483          /*******************************************************************************
    484          *    Function:  Gps_check_receive
    485          *
    486          *  Parameters:  None
    487          *     Returns:  None
    488          * Description:  Gps_check_receive.
    489          *******************************************************************************/
    490          static void Gps_check_receive(void)
    491          {
    492              gps_data_frame_t * rx_frame;
    493              uint8_t msg_address[GPS_NMEA_ADD_LEN +1]; //length +1 , in order to compare with nmea_msg_add_string.
    494              uint8_t index;
    495          
    496              memset(msg_address, 0x00, GPS_NMEA_ADD_LEN + 1);
    497              if (Gps_any_received_frames())
    498              {
    499                  rx_frame = Gps_received_frame();                            /* get pointer to received data */
    500                  memcpy(msg_address, rx_frame->address, 5);
    501                  for(index = 0; index < NMEA_NUM_MSG; index++)
    502                  {
    503                      if(!strcmp((const char*)msg_address, nmea_msg_add_string[index]))
    504                      {
    505                          break;
    506                      }
    507                  }
    508                  if( index < NMEA_NUM_MSG)
    509                  {
    510                      if((*nmea_decode_table[index])((uint8_t*)(rx_frame->data)))
    511                      {
    512                          GPS_update_last();
    513                      }
    514                  }
    515              }
    516          }
    517          
    518          /*******************************************************************************
    519          *    Function:  ucom_any_received_frames
    520          *
    521          *  Parameters:  None
    522          *     Returns:  TRUE if any receive frames are available
    523          * Description:  Notify decoder task that new frame is available
    524          *******************************************************************************/
    525          static bool Gps_any_received_frames(void)
    526          {
    527             return(!Ring_Buf_Is_Empty(&gps_rx_ring_control));
    528          }
    529          
    530          /*******************************************************************************
    531          *    Function:  ubx_received_frame
    532          *
    533          *  Parameters:  None
    534          *     Returns:  Pointer to received frame / NULL if no available frame
    535          * Description:  Returns pointer to oldest received frame
    536          *               Increment receive ring buffer
    537          *******************************************************************************/
    538          static gps_data_frame_t* Gps_received_frame(void)
    539          {
    540             gps_data_frame_t *rx_frame = NULL;
    541          
    542             if (Gps_any_received_frames())         // ensure frame is available 
    543             {
    544                rx_frame =  &gps_rx_ring_buffer[gps_rx_ring_control.out];                 
    545                Ring_Buf_Remove(&gps_rx_ring_control);
    546             }
    547             return(rx_frame);
    548          }
    549          
    550          /*******************************************************************************
    551          *    Function:  gps_evt_nop
    552          *
    553          *  Parameters:  Tx Message
    554          *     Returns:  Status
    555          * Description:  gps_evt_nop
    556          *******************************************************************************/
    557          static void gps_evt_nop(int16_t data)
    558          {
    559          
    560          }
    561          
    562          static bool GNSS_GNRMC_Msg_Decode(uint8_t * rx_buf)
    563          {
    564              uint8_t len;
    565              uint8_t* original_p;
    566              uint8_t* p ;
    567              uint8_t* p_temp;
    568          
    569          #if GPS_DEBUG_VALUE    
    570              test = strlen(",015531.000,A,3111.849696,N,12125.382428,E,3.98,6.66,221116,,,");
    571              memcpy(rx_buf, ",015531.000,A,3111.849696,N,12125.382428,E,3.98,6.66,221116,,,",test);
    572          #endif
    573          
    574          #if GPS_DEBUG_MUTEX
    575              /* to prevend gps_data from being accessed while updating gps_data */
    576              vTaskSuspendAll();
    577          #endif
    578          
    579              gps_data_ready_flag = false;
    580          
    581              original_p = rx_buf;
    582              //Save the UTC time
    583              rx_buf++; //elimite first comma.
    584              p = rx_buf;
    585          
    586              len = Get_Next_Data_Len_Before_Comma(p);
    587              p+=(len+1); //elimite first comma.
    588              if((len >0) && (len <= GPS_UTC_TIMER_LEN))
    589              {
    590                  gps_data.utc_time.gps_raw_time.utc_raw_hour[0] = rx_buf[0];
    591                  gps_data.utc_time.gps_raw_time.utc_raw_hour[1] = rx_buf[1];
    592          
    593                  gps_data.utc_time.gps_raw_time.utc_raw_min[0] = rx_buf[2];
    594                  gps_data.utc_time.gps_raw_time.utc_raw_min[1] = rx_buf[3];
    595          
    596                  gps_data.utc_time.gps_raw_time.utc_raw_sec[0] = rx_buf[4];
    597                  gps_data.utc_time.gps_raw_time.utc_raw_sec[1] = rx_buf[5];
    598              }
    599              rx_buf+= (len+1);
    600          
    601              len = Get_Next_Data_Len_Before_Comma(p);
    602              p+=(len+1); //elimite first comma.
    603              if(len==1)
    604              {
    605                  if('A' == *rx_buf)
    606                  {
    607                      gps_data.valid = true;
    608                  }
    609                  else
    610                  {
    611                      gps_data.valid = false;
    612                  }
    613              }
    614              rx_buf+= (len+1);
    615          
    616              len = Get_Next_Data_Len_Before_Comma(p);
    617              p+=(len+1); //elimite first comma.
    618              if(len >0)
    619              {
    620                  uint8_t lon_tmp[16];
    621                  memset(lon_tmp,0,16);
    622                  memcpy(lon_tmp, rx_buf, len);
    623                  convert_gps_lon(lon_tmp,gps_data.latitude);
    624              }
    625              else
    626              {
    627              }
    628              rx_buf+= (len+1);
    629          
    630              len = Get_Next_Data_Len_Before_Comma(p);
    631              p+=(len+1); //elimite first comma.
    632              if((len >0) && (len <= 1))
    633              {
    634                  gps_data.north_or_sourth = *rx_buf;
    635              }
    636              rx_buf+= (len + 1);
    637          
    638              len = Get_Next_Data_Len_Before_Comma(p);
    639              p+=(len+1); //elimite first comma.
    640              if(len >0)
    641              {
    642                  uint8_t lon_tmp[16];
    643                  memset(lon_tmp,0,16);
    644                  memcpy(lon_tmp, rx_buf, len);
    645                  convert_gps_lon(lon_tmp,gps_data.longitude);
    646              }
    647              else
    648              {
    649              }
    650              rx_buf+= (len+1);
    651          
    652              len = Get_Next_Data_Len_Before_Comma(p);
    653              p+=(len+1); //elimite first comma.
    654              if(1 == len)
    655              {
    656                  gps_data.east_or_west = *rx_buf;
    657              }
    658              rx_buf+= (len+1);  //also jump ove comma
    659          
    660              len = Get_Next_Data_Len_Before_Comma(p);
    661              p+=(len+1); //elimite first comma.
    662              rx_buf+= (len+1);  //also jump over comma
    663          
    664              p_temp = Get_Filed_Data_Pointer(original_p, 7);
    665              len = Get_Next_Data_Len_Before_Comma(p_temp);
    666              if(len >0)
    667              {
    668                  //get GPS data
    669                  uint8_t spd_tmp[8];
    670                  memset(spd_tmp,0,8);
    671                  memcpy(spd_tmp, p_temp, len);
    672                  convert_gps_knot(spd_tmp,gps_data.speed);
    673              }
    674              else
    675              {
    676                  memset(gps_data.speed,0,2);
    677              }
    678          
    679              p_temp = Get_Filed_Data_Pointer(original_p, 8);
    680              len = Get_Next_Data_Len_Before_Comma(p_temp);
    681              if((len >0) && (len <= GPS_COG_DATE_LEN))
    682              {
    683                  uint8_t cog_tmp[10];
    684                  memset(cog_tmp,0,10);
    685                  memcpy(cog_tmp, p_temp, len);        
    686                  convert_gps_cog(cog_tmp,gps_data.cog);
    687              }
    688              else
    689              {
    690                  memset(gps_data.cog,0,2);
    691              }
    692          
    693              //Save the UTC data
    694              p_temp = Get_Filed_Data_Pointer(original_p, 9);
    695              len = Get_Next_Data_Len_Before_Comma(p_temp);
    696              if((len >0) && (len <= GPS_UTC_DATE_LEN))
    697              {
    698                  gps_data.utc_time.gps_raw_time.utc_raw_day[0] = p_temp[0];
    699                  gps_data.utc_time.gps_raw_time.utc_raw_day[1] = p_temp[1];
    700                  gps_data.utc_time.gps_raw_time.utc_raw_month[0] = p_temp[2];
    701                  gps_data.utc_time.gps_raw_time.utc_raw_month[1] = p_temp[3];
    702                  gps_data.utc_time.gps_raw_time.utc_raw_year[2] = p_temp[4];
    703                  gps_data.utc_time.gps_raw_time.utc_raw_year[3] = p_temp[5];
    704              }
    705          
    706              DEBUG_PRINT1(DEBUG_MEDIUM,"[GNRMC]:%s\n\r",original_p);
    707          #if GPS_DEBUG_MUTEX
    708              /* enable gps_data accessing */
    709              xTaskResumeAll();
    710          #endif
    711              gps_data_ready_flag = true;
    712          
    713              return true;
    714          }
    715          
    716          /*******************************************************************************
    717          *    Function:  gps_evt_nop
    718          *
    719          *  Parameters:  Tx Message
    720          *     Returns:  Status
    721          * Description:  gps_evt_nop
    722          *******************************************************************************/
    723          static bool NMEA_GPRMC_Msg_Decode(uint8_t * rx_buf)
    724          {
    725              uint8_t len;
    726              uint8_t* original_p;
    727              uint8_t* p ;
    728              uint8_t* p_temp;
    729          
    730          #if GPS_DEBUG_MUTEX
    731              /* to prevend gps_data from being accessed while updating gps_data */
    732              vTaskSuspendAll();
    733          #endif
    734              DEBUG_PRINT1(DEBUG_MEDIUM,"[GPRMC]%s\r\n",rx_buf);
    735          
    736              gps_data_ready_flag = false;
    737          
    738              original_p = rx_buf;
    739              //Save the UTC time
    740              rx_buf++; //elimite first comma.
    741              p = rx_buf;
    742          
    743              len = Get_Next_Data_Len_Before_Comma(p);
    744              p+=(len+1); //elimite first comma.
    745              if((len >0) && (len <= GPS_UTC_TIMER_LEN))
    746              {
    747                  gps_data.utc_time.gps_raw_time.utc_raw_hour[0] = rx_buf[0];
    748                  gps_data.utc_time.gps_raw_time.utc_raw_hour[1] = rx_buf[1];
    749          
    750                  gps_data.utc_time.gps_raw_time.utc_raw_min[0] = rx_buf[2];
    751                  gps_data.utc_time.gps_raw_time.utc_raw_min[1] = rx_buf[3];
    752          
    753                  gps_data.utc_time.gps_raw_time.utc_raw_sec[0] = rx_buf[4];
    754                  gps_data.utc_time.gps_raw_time.utc_raw_sec[1] = rx_buf[5];
    755              }
    756              rx_buf+= (len+1);
    757          
    758              len = Get_Next_Data_Len_Before_Comma(p);
    759              p+=(len+1); //elimite first comma.
    760              if(len==1)
    761              {
    762                  DEBUG_PRINT1(DEBUG_MEDIUM,"[valid]:%s\n\r",rx_buf);
    763                  if('A' == *rx_buf)
    764                  {
    765                      gps_data.valid = true;
    766                  }
    767                  else
    768                  {
    769                      gps_data.valid = false;
    770                  }
    771              }
    772              rx_buf+= (len+1);
    773          
    774              len = Get_Next_Data_Len_Before_Comma(p);
    775              p+=(len+1); //elimite first comma.
    776              if(len >0)
    777              {
    778                  uint8_t lon_tmp[16];
    779                  memset(lon_tmp,0,16);
    780                  memcpy(lon_tmp, rx_buf, len);
    781                  convert_gps_lon(lon_tmp,gps_data.latitude);
    782              }
    783              else
    784              {
    785              }
    786              rx_buf+= (len+1);
    787          
    788              len = Get_Next_Data_Len_Before_Comma(p);
    789              p+=(len+1); //elimite first comma.
    790              if((len >0) && (len <= 1))
    791              {
    792                  gps_data.north_or_sourth = *rx_buf;
    793              }
    794              rx_buf+= (len + 1);
    795          
    796              len = Get_Next_Data_Len_Before_Comma(p);
    797              p+=(len+1); //elimite first comma.
    798              if(len >0)
    799              {
    800                  uint8_t lon_tmp[16];
    801                  memset(lon_tmp,0,16);
    802                  memcpy(lon_tmp, rx_buf, len);
    803                  convert_gps_lon(lon_tmp,gps_data.longitude);
    804              }
    805              else
    806              {
    807              }
    808              rx_buf+= (len+1);
    809          
    810              len = Get_Next_Data_Len_Before_Comma(p);
    811              p+=(len+1); //elimite first comma.
    812              if(1 == len)
    813              {
    814                  gps_data.east_or_west = *rx_buf;
    815              }
    816              rx_buf+= (len+1);  //also jump ove comma
    817          
    818              len = Get_Next_Data_Len_Before_Comma(p);
    819              p+=(len+1); //elimite first comma.
    820              rx_buf+= (len+1);  //also jump over comma
    821          
    822              p_temp = Get_Filed_Data_Pointer(original_p, 7);
    823              len = Get_Next_Data_Len_Before_Comma(p_temp);
    824              if(len >0)
    825              {
    826                  //get GPS data
    827                  uint8_t spd_tmp[8];
    828                  memset(spd_tmp,0,8);
    829                  memcpy(spd_tmp, p_temp, len);
    830                  convert_gps_knot(spd_tmp,gps_data.speed);
    831              }
    832              else
    833              {
    834                  memset(gps_data.speed,0,2);
    835              }
    836          
    837              p_temp = Get_Filed_Data_Pointer(original_p, 8);
    838              len = Get_Next_Data_Len_Before_Comma(p_temp);
    839              if((len >0) && (len <= GPS_COG_DATE_LEN))
    840              {
    841                  uint8_t cog_tmp[10];
    842                  memset(cog_tmp,0,10);
    843                  memcpy(cog_tmp, p_temp, len);
    844                  convert_gps_cog(cog_tmp,gps_data.cog);
    845              }
    846              else
    847              {
    848                  memset(gps_data.cog,0,2);
    849              }
    850              //Save the UTC data
    851              p_temp = Get_Filed_Data_Pointer(original_p, 9);
    852              len = Get_Next_Data_Len_Before_Comma(p_temp);
    853              if((len >0) && (len <= GPS_UTC_DATE_LEN))
    854              {
    855                  gps_data.utc_time.gps_raw_time.utc_raw_day[0] = p_temp[0];
    856                  gps_data.utc_time.gps_raw_time.utc_raw_day[1] = p_temp[1];
    857                  gps_data.utc_time.gps_raw_time.utc_raw_month[0] = p_temp[2];
    858                  gps_data.utc_time.gps_raw_time.utc_raw_month[1] = p_temp[3];
    859                  gps_data.utc_time.gps_raw_time.utc_raw_year[2] = p_temp[4];
    860                  gps_data.utc_time.gps_raw_time.utc_raw_year[3] = p_temp[5];
    861              }
    862          
    863             DEBUG_PRINT1(DEBUG_MEDIUM,"[GPRMC]:%s\n\r",original_p);
    864          #if GPS_DEBUG_MUTEX
    865              /* enable gps_data accessing */
    866              xTaskResumeAll();
    867          #endif
    868              gps_data_ready_flag = true;
    869          
    870              return true;
    871          }
    872          
    873          /*******************************************************************************
    874          *    Function:  NMEA_GPGGA_Msg_Decode
    875          *
    876          *  Parameters:  Tx Message
    877          *     Returns:  Status
    878          * Description:  NMEA_GPGGA_Msg_Decode
    879          *******************************************************************************/
    880          static bool NMEA_GNGGA_Msg_Decode(uint8_t * rx_buf)
    881          {
    882              uint8_t len;
    883              uint8_t* original_p;
    884              uint8_t* p ;
    885              uint8_t* p_temp;
    886          
    887          #if GPS_DEBUG_VALUE    
    888              uint8_t test; //Move test here to define it along with GPS_DEBUG_VALUE.
    889              test = strlen("015531.000,3111.849696,N,12125.382428,E,1,3,3.84,141.776,M,8.047,M,,");
    890              memcpy(rx_buf, "015531.000,3111.849696,N,12125.382428,E,1,3,3.84,141.776,M,8.047,M,,",test);
    891          #endif
    892              DEBUG_PRINT1(DEBUG_MEDIUM,"[GNGGA]%s\n\r",rx_buf);
    893          #if GPS_DEBUG_MUTEX
    894          	/* to prevend gps_data from being accessed while updating gps_data */
    895              vTaskSuspendAll();
    896          #endif
    897              gps_data_ready_flag = false;
    898          
    899              original_p = rx_buf;
    900              rx_buf++; //elimite first comma.
    901              p = rx_buf;
    902          
    903              len = Get_Next_Data_Len_Before_Comma(p);
    904              p+=(len+1); //elimite first comma.
    905          #if 1 // UTC time change to GPGGA command
    906              if((len >0) && (len <= GPS_UTC_TIMER_LEN))
    907              {
    908              }
    909          #endif
    910              rx_buf+= (len+1);
    911          
    912              len = Get_Next_Data_Len_Before_Comma(p);
    913              p+=(len+1); //elimite first comma.
    914              rx_buf+= (len+1);
    915          
    916              len = Get_Next_Data_Len_Before_Comma(p);
    917              p+=(len+1); //elimite first comma.
    918              rx_buf+= (len + 1);
    919          
    920              len = Get_Next_Data_Len_Before_Comma(p);
    921              p+=(len+1); //elimite first comma.
    922              rx_buf+= (len+1);
    923          
    924              len = Get_Next_Data_Len_Before_Comma(p);
    925              p+=(len+1); //elimite first comma.
    926              rx_buf+= (len+1);  //also jump ove comma
    927          
    928              len = Get_Next_Data_Len_Before_Comma(p);
    929              p+=(len+1); //elimite first comma.
    930              rx_buf+= (len+1);  //also jump over comma
    931          
    932             //Get the viewed statelite number for gps_sat_info structure.
    933              len = Get_Next_Data_Len_Before_Comma(p);
    934              p+=(len+1); //elimite first comma.
    935              if(len == 2)
    936              {
    937                 gps_data.gnss_sat_info.used_sat_num = (*rx_buf - 0x30) * 10 +  *(rx_buf+1) -0x30;
    938              }
    939              else if (len==1)
    940              {
    941                 gps_data.gnss_sat_info.used_sat_num = *(rx_buf) -0x30;
    942              }
    943              rx_buf+= (len+1);  //also jump over comma
    944          
    945              p_temp = Get_Filed_Data_Pointer(original_p, 8);
    946              len = Get_Next_Data_Len_Before_Comma(p_temp);
    947              if(len >0)
    948              {
    949                  uint8_t alt_tmp[10];
    950                  memset(alt_tmp,0,10);
    951                  memcpy(alt_tmp, p_temp, len);
    952                  convert_gps_alt(alt_tmp,gps_data.altitude);
    953              }
    954              else
    955              {
    956              }
    957          
    958          #if GPS_DEBUG_MUTEX
    959          	/* enable gps_data accessing */
    960             xTaskResumeAll();
    961          #endif   
    962              gps_data_ready_flag = true;
    963          
    964              return true;
    965          }
    966          
    967          /*******************************************************************************
    968          *    Function:  NMEA_GPGLL_Msg_Decode
    969          *
    970          *  Parameters:  Tx Message
    971          *     Returns:  Status
    972          * Description:  NMEA_GPGLL_Msg_Decode
    973          *******************************************************************************/
    974          static bool NMEA_GPGLL_Msg_Decode(uint8_t *rx_buf)
    975          {
    976              return true;
    977          }
    978          
    979          #if GPS_CHECK_SATSIG
    980          /*******************************************************************************
    981          *    Function:  NMEA_GPGSV_Msg_Decode
    982          *
    983          *  Parameters:  Tx Message
    984          *     Returns:  Status
    985          * Description:  NMEA_GPGSV_Msg_Decode
    986          *******************************************************************************/
    987          static bool NMEA_GPGSV_Msg_Decode(uint8_t *rx_buf)
    988          {
    989              uint8_t len;
    990              uint8_t* original_p;
    991              uint8_t* p ;
    992              uint8_t* p_temp;
    993              uint8_t pack_num;
    994              uint8_t cur_sat_num;
    995          
    996          #if GPS_DEBUG_VALUE
    997              uint8_t test; //Move test here to define it along with GPS_DEBUG_VALUE.
    998              gps_debug_flag ++;
    999          
   1000              if (gps_debug_flag == 1)
   1001              {
   1002                  test = strlen(",3,1,09,41,51,61,71,42,52,62,72,43,53,63,73,44,54,64,74*AA");
   1003                  memcpy(rx_buf, ",3,1,09,41,51,61,71,42,52,62,72,43,53,63,73,44,54,64,74*AA",test);
   1004              }
   1005              else if (gps_debug_flag == 2)
   1006              {
   1007                  test = strlen(",3,2,09,41,51,61,75,42,52,62,76,43,53,63,77,44,54,64,78*AA");
   1008                  memcpy(rx_buf, ",3,2,09,41,51,61,75,42,52,62,76,43,53,63,77,44,54,64,78*AA",test);
   1009              }
   1010              else if (gps_debug_flag == 3)
   1011              {
   1012                  gps_debug_flag = 0;
   1013                  test = strlen(",3,3,09,41,51,61,79,42,52,62,01,43,53,63,02,44,54,64,03*AA");
   1014                  memcpy(rx_buf, ",3,3,09,41,51,61,79,42,52,62,01,43,53,63,02,44,54,64,03*AA",test);
   1015              }
   1016                
   1017          #endif
   1018          
   1019              original_p = rx_buf;
   1020              rx_buf++; //elimite first comma.
   1021              p = rx_buf;
   1022          
   1023              //First parameter
   1024              len = Get_Next_Data_Len_Before_Comma(p);
   1025              p+=(len+1);
   1026              if((len >0) && (len <= 2))
   1027              {
   1028                  if (len == 2)
   1029                  {
   1030                  }
   1031                  else
   1032                  {      
   1033                  }
   1034              }
   1035              rx_buf+= (len+1);
   1036          
   1037              //Second parameter
   1038              len = Get_Next_Data_Len_Before_Comma(p);
   1039              p+=(len+1); //elimite first comma.
   1040              if((len >0) && (len <= 2))
   1041              {
   1042                  if (len == 2)
   1043                  {
   1044                      pack_num = (*rx_buf - 0x30) * 10 +  *(rx_buf+1) - 0x30;      
   1045                  }
   1046                  else
   1047                  {      
   1048                      pack_num = *rx_buf - 0x30;
   1049                  }
   1050              }
   1051              rx_buf+= (len+1);
   1052             
   1053              //Third parameter
   1054              len = Get_Next_Data_Len_Before_Comma(p);
   1055              p+=(len+1); //elimite first comma.
   1056              if(len == 2)
   1057              {
   1058                  gps_data.gps_sat_info.viewed_sat_num = (*rx_buf - 0x30) * 10 +  *(rx_buf+1) - 0x30;      
   1059                  if (gps_data.gps_sat_info.viewed_sat_num > 12) 
   1060                  {
   1061                      gps_data.gps_sat_info.viewed_sat_num = 12;
   1062                  }
   1063                  else if (gps_data.gps_sat_info.viewed_sat_num == 0)
   1064                  {
   1065                      memset(gps_data.gps_sat_info.sat_info,0,24);
   1066                  }
   1067              }
   1068              rx_buf+= (len+1);
   1069          
   1070          //Get signal strength parameter
   1071          //0,1,2,3
   1072              for(cur_sat_num = 0; cur_sat_num < 4 ;cur_sat_num++) 
   1073              {
   1074                  if ((cur_sat_num + 4 * (pack_num -1)) >=  gps_data.gps_sat_info.viewed_sat_num)
   1075                  {
   1076                      break;
   1077                  }
   1078          
   1079                  p_temp = Get_Filed_Data_Pointer(original_p, 4 + 4 *cur_sat_num );
   1080                  len = Get_Next_Data_Len_Before_Comma(p_temp);
   1081                  if (len == 2)
   1082                  {
   1083                      gps_data.gps_sat_info.sat_info[cur_sat_num + 4 * (pack_num -1)].sat_num = (*p_temp- 0x30) * 10 +  *(p_temp+1)- 0x30;
   1084                  }
   1085                  else
   1086                  {
   1087                      gps_data.gps_sat_info.sat_info[cur_sat_num + 4 * (pack_num -1)].sat_num = 0;
   1088                  }
   1089          
   1090                  p_temp = Get_Filed_Data_Pointer(original_p, 7 + 4 *cur_sat_num );
   1091                  len = Get_Next_Data_Len_Before_Comma(p_temp);
   1092                  if (len == 2)
   1093                  {
   1094                      gps_data.gps_sat_info.sat_info[cur_sat_num + 4 * (pack_num -1)].sat_sig = (*p_temp- 0x30) * 10 +  *(p_temp+1)- 0x30;      
   1095                  }
   1096                  else
   1097                  {
   1098                      gps_data.gps_sat_info.sat_info[cur_sat_num + 4 * (pack_num -1)].sat_sig = 0;      
   1099                  }
   1100              }
   1101          
   1102              return true;   
   1103          }
   1104          
   1105          static bool BD_BDGSV_Msg_Decode(uint8_t * rx_buf)
   1106          {
   1107              uint8_t len;
   1108              uint8_t* original_p;
   1109              uint8_t* p ;
   1110              uint8_t* p_temp;
   1111              uint8_t pack_num;
   1112              uint8_t cur_sat_num;
   1113          
   1114          #if GPS_DEBUG_VALUE
   1115              uint8_t test; //Move test here to define it along with GPS_DEBUG_VALUE.
   1116              gps_debug_flag ++;
   1117          
   1118              if (gps_debug_flag == 1)
   1119              {
   1120                  test = strlen(",3,1,09,41,51,61,71,42,52,62,72,43,53,63,73,44,54,64,74*AA");
   1121                  memcpy(rx_buf, ",3,1,09,41,51,61,71,42,52,62,72,43,53,63,73,44,54,64,74*AA",test);
   1122              }
   1123              else if (gps_debug_flag == 2)
   1124              {
   1125                  test = strlen(",3,2,09,41,51,61,75,42,52,62,76,43,53,63,77,44,54,64,78*AA");
   1126                  memcpy(rx_buf, ",3,2,09,41,51,61,75,42,52,62,76,43,53,63,77,44,54,64,78*AA",test);
   1127              }
   1128              else if (gps_debug_flag == 3)
   1129              {
   1130                  gps_debug_flag = 0;
   1131                  test = strlen(",3,3,09,41,51,61,79,42,52,62,01,43,53,63,02,44,54,64,03*AA");
   1132                  memcpy(rx_buf, ",3,3,09,41,51,61,79,42,52,62,01,43,53,63,02,44,54,64,03*AA",test);
   1133              }
   1134                
   1135          #endif
   1136          
   1137              original_p = rx_buf;
   1138              rx_buf++; //elimite first comma.
   1139              p = rx_buf;
   1140          
   1141              //First parameter
   1142              len = Get_Next_Data_Len_Before_Comma(p);
   1143              p+=(len+1);
   1144              if((len >0) && (len <= 2))
   1145              {
   1146                  if (len == 2)
   1147                  {
   1148                  }
   1149                  else
   1150                  {      
   1151                  }
   1152              }
   1153              rx_buf+= (len+1);
   1154          
   1155              //Second parameter
   1156              len = Get_Next_Data_Len_Before_Comma(p);
   1157              p+=(len+1); //elimite first comma.
   1158              if((len >0) && (len <= 2))
   1159              {
   1160                  if (len == 2)
   1161                  {
   1162                      pack_num = (*rx_buf - 0x30) * 10 +  *(rx_buf+1) - 0x30;      
   1163                  }
   1164                  else
   1165                  {
   1166                      pack_num = *rx_buf - 0x30;
   1167                  }
   1168              }
   1169              rx_buf+= (len+1);
   1170             
   1171              //Third parameter
   1172              len = Get_Next_Data_Len_Before_Comma(p);
   1173              p+=(len+1); //elimite first comma.
   1174              if(len == 2)
   1175              {
   1176                  gps_data.bd_sat_info.viewed_sat_num = (*rx_buf - 0x30) * 10 +  *(rx_buf+1) - 0x30;      
   1177                  if (gps_data.bd_sat_info.viewed_sat_num > 12) 
   1178                  {
   1179                      gps_data.bd_sat_info.viewed_sat_num = 12;
   1180                  }
   1181                  else if (gps_data.bd_sat_info.viewed_sat_num == 0)
   1182                  {
   1183                      memset(gps_data.bd_sat_info.sat_info,0,24);
   1184                  }
   1185              }
   1186              rx_buf+= (len+1);
   1187          
   1188              //Get signal strength parameter
   1189              //0,1,2,3
   1190              for(cur_sat_num = 0; cur_sat_num < 4 ;cur_sat_num++) 
   1191              {
   1192                  if ((cur_sat_num + 4 * (pack_num -1)) >=  gps_data.bd_sat_info.viewed_sat_num)
   1193                  {
   1194                      break;
   1195                  }
   1196          
   1197                  p_temp = Get_Filed_Data_Pointer(original_p, 4 + 4 *cur_sat_num );
   1198                  len = Get_Next_Data_Len_Before_Comma(p_temp);
   1199                  if (len == 2)
   1200                  {
   1201                      gps_data.bd_sat_info.sat_info[cur_sat_num + 4 * (pack_num -1)].sat_num = (*p_temp- 0x30) * 10 +  *(p_temp+1)- 0x30;
   1202                  }
   1203                  else
   1204                  {
   1205                      gps_data.bd_sat_info.sat_info[cur_sat_num + 4 * (pack_num -1)].sat_num = 0;
   1206                  }
   1207          
   1208                  p_temp = Get_Filed_Data_Pointer(original_p, 7 + 4 *cur_sat_num );
   1209                  len = Get_Next_Data_Len_Before_Comma(p_temp);
   1210                  if (len == 2)
   1211                  {
   1212                      gps_data.bd_sat_info.sat_info[cur_sat_num + 4 * (pack_num -1)].sat_sig = (*p_temp- 0x30) * 10 +  *(p_temp+1)- 0x30;      
   1213                  }
   1214                  else
   1215                  {
   1216                      gps_data.bd_sat_info.sat_info[cur_sat_num + 4 * (pack_num -1)].sat_sig = 0;      
   1217                  }
   1218              }
   1219          
   1220              return true;
   1221          }
   1222          
   1223          static bool NMEA_GPGSA_Msg_Decode(uint8_t * rx_buf)
   1224          {
   1225              uint8_t len;
   1226              uint8_t* original_p;
   1227              uint8_t* p ;
   1228          
   1229              original_p = rx_buf;
   1230              rx_buf++; //elimite first comma.
   1231              p = rx_buf;
   1232          
   1233              //First parameter
   1234              p = Get_Filed_Data_Pointer(original_p, 2);
   1235              len = Get_Next_Data_Len_Before_Comma(p);
   1236              if((len >0) && (len <= 1))
   1237              {
   1238              }
   1239          
   1240              p = Get_Filed_Data_Pointer(original_p, 15);
   1241              len = Get_Next_Data_Len_Before_Comma(p);
   1242              if(len >0)
   1243              {
   1244                  convert_gps_dop(p,gps_data.pdop);
   1245              }
   1246              p+=(len+1);
   1247              return true;
   1248          }
   1249          
   1250          static bool BD_BDGSA_Msg_Decode(uint8_t * rx_buf)
   1251          {
   1252              uint8_t len;
   1253              uint8_t* original_p;
   1254              uint8_t* p ;
   1255          
   1256              original_p = rx_buf;
   1257              rx_buf++; //elimite first comma.
   1258              p = rx_buf;
   1259          
   1260              //First parameter
   1261              p = Get_Filed_Data_Pointer(original_p, 2);
   1262              len = Get_Next_Data_Len_Before_Comma(p);
   1263              if((len >0) && (len <= 1))
   1264              {
   1265              }
   1266          
   1267              p = Get_Filed_Data_Pointer(original_p, 15);
   1268              len = Get_Next_Data_Len_Before_Comma(p);
   1269              if((len >0) && (len <= 8))
   1270              {
   1271                  gps_data.pdop[0]=*p-'0';
   1272                  gps_data.pdop[1]=(*(p+2)-'0')*10+(*(p+3)-'0');
   1273              }
   1274              p+=(len+1);
   1275              return true;
   1276          }
   1277          
   1278          
   1279          #endif
   1280          
   1281          bool GPS_Get_Ready_Flag(void)
   1282          {
   1283          	return gps_data_ready_flag;
   1284          }
   1285          
   1286          void GPS_Send_Data(uint8_t *data, uint32_t len)
   1287          {
   1288              uint32_t i;
   1289              if (len > 1000)
   1290                  len = 1000;
   1291              for (i=0;i<len;i++)
   1292              {
   1293                  Uart_Put_Char(UART_GPS_CHANNEL,*(data + i ));
   1294              }
   1295          }
   1296          
   1297          uint16_t GPS_Parse_Cog(uint8_t *data)
   1298          {
   1299              uint8_t i;
   1300              uint16_t ret = 0;
   1301              if (*data == 0)
   1302                  return 0;
   1303              for(i=0;i<3;i++)
   1304              {
   1305                  if (*(data+i) == 0)
   1306                      break;
   1307                  ret *= 10;
   1308                  ret += *(data+i)-'0';
   1309              }
   1310              return ret;
   1311          }
   1312          
   1313          void GPS_Get_Sig(uint8_t *sig)
   1314          {
   1315              uint8_t i;
   1316              if (gps_data.gps_sat_info.viewed_sat_num == 0)
   1317              {
   1318                  memset(sig, 0, 8);
   1319                  return;
   1320              }
   1321              for (i=0; i<12; i++)
   1322              {
   1323                  if (gps_data.gps_sat_info.sat_info[i].sat_sig > sig[1])
   1324                  {
   1325                      sig[7] = sig[5];
   1326                      sig[6] = sig[4];
   1327                      sig[5] = sig[3];
   1328                      sig[4] = sig[2];
   1329                      sig[3] = sig[1];
   1330                      sig[2] = sig[0];
   1331                      sig[1] = gps_data.gps_sat_info.sat_info[i].sat_sig;
   1332                      sig[0] = gps_data.gps_sat_info.sat_info[i].sat_num;
   1333                  }
   1334                  else if (gps_data.gps_sat_info.sat_info[i].sat_sig > sig[3])
   1335                  {
   1336                      sig[7] = sig[5];
   1337                      sig[6] = sig[4];
   1338                      sig[5] = sig[3];
   1339                      sig[4] = sig[2];
   1340                      sig[3] = gps_data.gps_sat_info.sat_info[i].sat_sig;
   1341                      sig[2] = gps_data.gps_sat_info.sat_info[i].sat_num;
   1342                  }
   1343                  else if (gps_data.gps_sat_info.sat_info[i].sat_sig > sig[5])
   1344                  {
   1345                      sig[7] = sig[5];
   1346                      sig[6] = sig[4];
   1347                      sig[5] = gps_data.gps_sat_info.sat_info[i].sat_sig;
   1348                      sig[4] = gps_data.gps_sat_info.sat_info[i].sat_num;
   1349                  }
   1350                  else if (gps_data.gps_sat_info.sat_info[i].sat_sig > sig[7])
   1351                  {
   1352                      sig[7] = gps_data.gps_sat_info.sat_info[i].sat_sig;
   1353                      sig[6] = gps_data.gps_sat_info.sat_info[i].sat_num;
   1354                  }
   1355              }
   1356          }
   1357          
   1358          static void convert_gps_lon(uint8_t *gps_data, uint8_t *dst_buf)
   1359          {
   1360              uint8_t i=0;
   1361              uint8_t point_ptr = 0;
   1362              uint32_t tmp_min = 0;
   1363              for(i=0;i<(GPS_POS_DATE_LEN-1);i++)
   1364              {
   1365                  if (*(gps_data+i) == '.')
   1366                  {
   1367                      point_ptr = i;
   1368                      break;
   1369                  }
   1370              }
   1371              if (0 == point_ptr)
   1372              {
   1373                  memset(dst_buf,0,4);
   1374              }
   1375              else
   1376              {
   1377                  uint32_t decimal_base;
   1378                  int32_t gps_min_dec = 0;
   1379                  int32_t gps_degree_dec = 0;
   1380                  tmp_min = (*(gps_data+point_ptr-2)-'0') * 10 + (*(gps_data+point_ptr-1) - '0');
   1381                  for (i=point_ptr+1;i<(point_ptr+7);i++)
   1382                  {
   1383                      if (*(gps_data+i) == '\0')
   1384                      {
   1385                          tmp_min *= 10;
   1386                      }
   1387                      else
   1388                      {
   1389                          tmp_min *= 10;
   1390                          tmp_min += (*(gps_data+i)-'0');
   1391                      }
   1392                  }
   1393                  gps_min_dec = (tmp_min) / 60;
   1394                  decimal_base = 1;
   1395                  for (i=(point_ptr-2);i>0;i--)
   1396                  {
   1397                      gps_degree_dec += (*(gps_data+i-1)-'0') * decimal_base;
   1398                      decimal_base *= 10;
   1399                  }
   1400                  gps_min_dec+=gps_degree_dec*1000000;
   1401                  *(dst_buf) = (gps_min_dec>>24) & 0xff;
   1402                  *(dst_buf+1) = (gps_min_dec >> 16) & 0xff;
   1403                  *(dst_buf+2) = (gps_min_dec >> 8) & 0xff;
   1404                  *(dst_buf+3) = gps_min_dec & 0xff;
   1405              }
   1406          }
   1407          
   1408          // Convert altitude to meter
   1409          static void convert_gps_alt(uint8_t *gps_data, uint8_t *dst_buf)
   1410          {
   1411              uint8_t i=0;
   1412              uint8_t point_ptr = 0;
   1413              for(i=0;i<(GPS_POS_DATE_LEN-1);i++)
   1414              {
   1415                  if (*(gps_data+i) == '.')
   1416                  {
   1417                      point_ptr = i;
   1418                      break;
   1419                  }
   1420              }
   1421              if (0 == point_ptr)
   1422              {
   1423                  memset(dst_buf,0,4);
   1424              }
   1425              else
   1426              {
   1427                  uint32_t decimal_base;
   1428                  int32_t gps_degree_dec = 0;
   1429                  decimal_base = 1;
   1430                  for (i=point_ptr-2;i<=point_ptr;i++)
   1431                  {
   1432                      gps_degree_dec += (*(gps_data+i-1)-'0') * decimal_base;
   1433                      decimal_base *= 10;
   1434                  }
   1435                  *(dst_buf) = (gps_degree_dec>>24) & 0xff;
   1436                  *(dst_buf+1) = (gps_degree_dec >> 16) & 0xff;
   1437                  *(dst_buf+2) = (gps_degree_dec >> 8) & 0xff;
   1438                  *(dst_buf+3) = gps_degree_dec & 0xff;
   1439              }
   1440          }
   1441          
   1442          // Convert speed to km/h
   1443          static void convert_gps_knot(uint8_t *gps_data, uint8_t *dst_buf)
   1444          {
   1445              uint8_t i=0;
   1446              uint8_t point_ptr = 0;
   1447              for(i=0;i<(GPS_SPEED_DATE_LEN-1);i++)
   1448              {
   1449                  if (*(gps_data+i) == '.')
   1450                  {
   1451                      point_ptr = i;
   1452                      break;
   1453                  }
   1454              }
   1455              if (0 == point_ptr)
   1456              {
   1457                  memset(dst_buf,0,2);
   1458              }
   1459              else
   1460              {
   1461                  uint32_t decimal_base;
   1462                  int32_t gps_spd_dec = 0;
   1463                  for (i=point_ptr+1;i<(point_ptr+2);i++)
   1464                  {
   1465                      if (*(gps_data+i) == '\0')
   1466                      {
   1467                          gps_spd_dec *= 10;
   1468                      }
   1469                      else
   1470                      {
   1471                          gps_spd_dec *= 10;
   1472                          gps_spd_dec += (*(gps_data+i)-'0');
   1473                      }
   1474                  }
   1475                  gps_spd_dec *=100000;
   1476                  decimal_base = 1;
   1477                  for (i=0;i<point_ptr;i++)
   1478                  {
   1479                      gps_spd_dec += (*(gps_data+i)-'0') * decimal_base * 1000000;
   1480                      decimal_base *= 10;
   1481                  }
   1482                  gps_spd_dec=(gps_spd_dec*36)/(KNOTS_DIV*10);
   1483                  *dst_buf=(gps_spd_dec>>8)&0xff;
   1484                  *(dst_buf+1)=(gps_spd_dec)&0xff;
   1485              }
   1486          }
   1487          
   1488          static void convert_gps_cog(uint8_t *gps_data, uint8_t *dst_buf)
   1489          {
   1490              uint8_t i=0;
   1491              uint8_t point_ptr = 0;
   1492              for(i=0;i<(GPS_COG_DATE_LEN-1);i++)
   1493              {
   1494                  if (*(gps_data+i) == '.')
   1495                  {
   1496                      point_ptr = i;
   1497                      break;
   1498                  }
   1499              }
   1500              if (0 == point_ptr)
   1501              {
   1502                  memset(dst_buf,0,2);
   1503              }
   1504              else
   1505              {
   1506                  uint32_t decimal_base;
   1507                  int32_t gps_cog_dec = 0;
   1508                  decimal_base = 1;
   1509                  {
   1510                      gps_cog_dec += (*(gps_data+point_ptr-1)-'0') * decimal_base;
   1511                      decimal_base *= 10;
   1512                  }
   1513                  *dst_buf=(gps_cog_dec>>8)&0xff;
   1514                  *(dst_buf+1)=(gps_cog_dec)&0xff;
   1515              }
   1516          }
   1517          
   1518          static void convert_gps_dop(uint8_t *gps_data, uint8_t *dst_buf)
   1519          {
   1520              uint8_t i=0;
   1521              uint8_t point_ptr = 0;
   1522              for(i=0;i<(GPS_COG_DATE_LEN-1);i++)
   1523              {
   1524                  if (*(gps_data+i) == '.')
   1525                  {
   1526                      point_ptr = i;
   1527                      break;
   1528                  }
   1529              }
   1530              if (0 == point_ptr)
   1531              {
   1532                  memset(dst_buf,0,2);
   1533              }
   1534              else
   1535              {
   1536                  uint32_t decimal_base;
   1537                  int32_t gps_dop_dec = 0;
   1538                  decimal_base = 10;
   1539                  gps_dop_dec=(*(gps_data+point_ptr+1)-'0');
   1540                  {
   1541                      gps_dop_dec += (*(gps_data+point_ptr-1)-'0') * decimal_base;
   1542                  }
   1543                  *dst_buf=(gps_dop_dec>>8)&0xff;
   1544                  *(dst_buf+1)=(gps_dop_dec)&0xff;
   1545              }
   1546          }
   1547          
   1548          extern void gps_set_trip_start(uint8_t flag)
   1549          {
   1550              if (flag>=1)
   1551              {
   1552                  if (trip_start_flag == 0)
   1553                  {
   1554                      trip_distance=0;
   1555                  }
   1556                  trip_start_flag=1;
   1557              }
   1558              else
   1559              {
   1560                  trip_start_flag=0;
   1561              }
   1562          }
   1563          
   1564          extern uint32_t gps_get_trip_distance(void)
   1565          {
   1566              return trip_distance;
   1567          }
   1568          
   1569          static void count_trip_mileage(uint8_t *speed)
   1570          {
   1571              uint32_t step_meter=0;
   1572              uint16_t speed_tmp=((*speed)<<8)|(*(speed+1));
   1573              if (speed_tmp>10)
   1574              {
   1575                  step_meter=((speed_tmp)*100)/36;
   1576                  trip_distance+=step_meter;
   1577              }
   1578          }
   1579          
   1580          /*=======================================================================================*\
   1581           * File Revision History
   1582           *=======================================================================================
   1583           * ----------  ------   ---------------------------------------------
   1584           *
   1585          \*=======================================================================================*/
   1586          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   BD_BDGSA_Msg_Decode
        16   -> Get_Filed_Data_Pointer
        16   -> Get_Next_Data_Len_Before_Comma
      24   BD_BDGSV_Msg_Decode
        24   -> Get_Filed_Data_Pointer
        24   -> Get_Next_Data_Len_Before_Comma
        24   -> __aeabi_memset
      80   GNSS_GNRMC_Msg_Decode
        80   -> Get_Filed_Data_Pointer
        80   -> Get_Next_Data_Len_Before_Comma
        80   -> __aeabi_memcpy
        80   -> __aeabi_memset
        80   -> convert_gps_cog
        80   -> convert_gps_knot
        80   -> convert_gps_lon
       8   GPS_COM_Initialize
         8   -> Ring_Buf_Reset
         8   -> Uart_Initialize
       0   GPS_Get_Ready_Flag
       8   GPS_Get_Sig
         8   -> __aeabi_memset
       8   GPS_Module_Initialization
         8   -> GPIO_WriteBit
       0   GPS_Parse_Cog
      16   GPS_Send_Data
        16   -> Uart_Put_Char
      16   GPS_Task
        16   -- Indirect call
        16   -> GPS_COM_Initialize
        16   -> GPS_Module_Initialization
        16   -> Gps_Rx_Data_Byte
        16   -> Gps_any_received_frames
        16   -> Gps_check_receive
        16   -> OS_Wait_Message
        16   -> PS_Running
        16   -> Uart_Get_Char
        16   -> vTaskSuspend
     136   GPS_Validate_Rx_Frame_Data
       136   -> Ring_Buf_Add
       136   -> Ring_Buf_Is_Full
       136   -> __aeabi_memcpy
       136   -> __aeabi_memset
     128   GPS_update_last
       112   -> __aeabi_memcpy
       128   -> __aeabi_memcpy4
       112   -> count_trip_mileage
       112   -> store_gps_buf
       8   Gps_Rx_Data_Byte
         8   -> GPS_Validate_Rx_Frame_Data
         8   -> __aeabi_memset
       8   Gps_any_received_frames
         8   -> Ring_Buf_Is_Empty
      24   Gps_check_receive
        24   -- Indirect call
        24   -> GPS_update_last
        24   -> Gps_any_received_frames
        24   -> Gps_received_frame
        24   -> __aeabi_memcpy
        24   -> __aeabi_memset
        24   -> strcmp
       8   Gps_received_frame
         8   -> Gps_any_received_frames
         8   -> Ring_Buf_Remove
      32   NMEA_GNGGA_Msg_Decode
        32   -> Get_Filed_Data_Pointer
        32   -> Get_Next_Data_Len_Before_Comma
        32   -> __aeabi_memcpy
        32   -> __aeabi_memset
        32   -> convert_gps_alt
       0   NMEA_GPGLL_Msg_Decode
      16   NMEA_GPGSA_Msg_Decode
        16   -> Get_Filed_Data_Pointer
        16   -> Get_Next_Data_Len_Before_Comma
        16   -> convert_gps_dop
      24   NMEA_GPGSV_Msg_Decode
        24   -> Get_Filed_Data_Pointer
        24   -> Get_Next_Data_Len_Before_Comma
        24   -> __aeabi_memset
      80   NMEA_GPRMC_Msg_Decode
        80   -> Get_Filed_Data_Pointer
        80   -> Get_Next_Data_Len_Before_Comma
        80   -> __aeabi_memcpy
        80   -> __aeabi_memset
        80   -> convert_gps_cog
        80   -> convert_gps_knot
        80   -> convert_gps_lon
      24   convert_gps_alt
        24   -> __aeabi_memset
       8   convert_gps_cog
         8   -> __aeabi_memset
       8   convert_gps_dop
         8   -> __aeabi_memset
      24   convert_gps_knot
        24   -> __aeabi_memset
      16   convert_gps_lon
        16   -> __aeabi_memset
       0   count_trip_mileage
       8   get_gps_buf
         8   -> Ring_Buf_Is_Empty
         8   -> Ring_Buf_Remove
         8   -> __aeabi_memcpy
       0   gps_evt_nop
       0   gps_get_trip_distance
       0   gps_set_trip_start
     176   store_gps_buf
       160   -> Ring_Buf_Add
       160   -> Ring_Buf_Is_Full
       160   -> Ring_Buf_Remove
       160   -> Switch_GPS_Sturcture_data_to_log
       160   -> __aeabi_memcpy
       176   -> __aeabi_memcpy4
       8   vGps_Get_Gps_Info
         8   -> __aeabi_memcpy
       0   vGps_Get_Gps_Status
       8   vGps_Get_Gps_Utc
         8   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable22
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable26
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_10
       4  ??DataTable27_11
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable27_6
       4  ??DataTable27_7
       4  ??DataTable27_8
       4  ??DataTable27_9
       8  ?_0
       8  ?_1
       8  ?_2
       8  ?_3
       8  ?_4
       8  ?_5
       8  ?_6
       8  ?_7
      94  BD_BDGSA_Msg_Decode
     422  BD_BDGSV_Msg_Decode
     662  GNSS_GNRMC_Msg_Decode
      62  GPS_COM_Initialize
       6  GPS_Get_Ready_Flag
     266  GPS_Get_Sig
      30  GPS_Module_Initialization
      50  GPS_Parse_Cog
      36  GPS_Send_Data
     134  GPS_Task
     162  GPS_Validate_Rx_Frame_Data
      72  GPS_update_last
     270  Gps_Rx_Data_Byte
      24  Gps_any_received_frames
     104  Gps_check_receive
      42  Gps_received_frame
     304  NMEA_GNGGA_Msg_Decode
       4  NMEA_GPGLL_Msg_Decode
      72  NMEA_GPGSA_Msg_Decode
     404  NMEA_GPGSV_Msg_Decode
     662  NMEA_GPRMC_Msg_Decode
     106  convert_gps_alt
      78  convert_gps_cog
      84  convert_gps_dop
     154  convert_gps_knot
     188  convert_gps_lon
      40  count_trip_mileage
       4  first_sync_ch_received
      56  get_gps_buf
     120  gps_data
       4  gps_data_ready_flag
     520  gps_data_ring_buffer
       8  gps_data_ring_control
       4  gps_event_handler
       2  gps_evt_nop
       6  gps_get_trip_distance
     120  gps_rx_buffer
       4  gps_rx_err
    5080  gps_rx_ring_buffer
       8  gps_rx_ring_control
       1  gps_rx_state
      36  gps_set_trip_start
     120  last_gps_data
      32  nmea_decode_table
      32  nmea_msg_add_string
       1  rx_count
     170  store_gps_buf
       4  trip_distance
       4  trip_start_flag
      18  vGps_Get_Gps_Info
       8  vGps_Get_Gps_Status
      26  vGps_Get_Gps_Utc

 
 5 994 bytes in section .bss
    36 bytes in section .data
   100 bytes in section .rodata
 4 994 bytes in section .text
 
 4 994 bytes of CODE  memory
   100 bytes of CONST memory
 6 030 bytes of DATA  memory

Errors: none
Warnings: none
