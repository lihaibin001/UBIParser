###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.2.11947/W32 for ARM       15/Sep/2017  09:59:33
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\workspace\dr002\dr002_suming\v1_board\main_app\drivers\uart.c
#    Command line =  
#        D:\workspace\dr002\dr002_suming\v1_board\main_app\drivers\uart.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -lcN
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\List
#        --diag_suppress Pa050 -o
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\.\ -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Diag_Factory\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\common\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\power\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\SysMan\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Protocol\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\include\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\FreeRTOS\include\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\FreeRTOS\portable\IAR\ARM_CM3\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\drivers\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\GPS\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\GPRS\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Sensors\
#        -Ol --use_c++_inline --require_prototypes
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\List\uart.lst
#    Object file  =  
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\Obj\uart.o
#
###############################################################################

D:\workspace\dr002\dr002_suming\v1_board\main_app\drivers\uart.c
      1          /*----------------------------------------------------------------------------/
      2           *  (C)Dedao, 2016
      3           *-----------------------------------------------------------------------------/
      4           *
      5           * Copyright (C) 2016, Dedao, all right reserved.
      6           *
      7           * 1. Redistributions of source code must retain the above copyright notice,
      8           *    this condition and the following disclaimer.
      9           *
     10           * This software is provided by the copyright holder and contributors "AS IS"
     11           * and any warranties related to this software are DISCLAIMED.
     12           * The copyright owner or contributors be NOT LIABLE for any damages caused
     13           * by use of this software.
     14           *----------------------------------------------------------------------------*/
     15          
     16          /*===========================================================================
     17           * DESCRIPTION:
     18           *   This is the standard code file for UART module.
     19           *
     20          \*===========================================================================*/
     21          
     22          #include "standard.h"
     23          #include "uart.h"
     24          
     25          //#define USE_DEBUG
     26          #include "Debug.h"
     27          
     28          /******************************************************************************/
     29          /* Constant and Macro Definitions using #define                               */
     30          /******************************************************************************/
     31          
     32          /******************************************************************************/
     33          /* Enumerations and Structures and Typedefs                                   */
     34          /******************************************************************************/
     35          // Information for each UART channel is stored in variables of this type:
     36          typedef struct uart_chan_tag
     37          {
     38             uint16_t rx_in;                  // Rx buffer input index
     39             uint16_t rx_out;                 // Rx buffer output index
     40             uint16_t rx_count;               // Rx buffer byte count
     41             uint16_t rx_size;                // Rx buffer size
     42             uint8_t* rx_buf;                 // Rx ring buffer
     43            // uart_rx_func_ptr rx_func;        // Rx callback function pointer
     44             uint16_t tx_in;                  // Tx buffer input index
     45             uint16_t tx_out;                 // Tx buffer output index
     46             uint16_t tx_count;               // Tx buffer byte counter
     47             uint16_t tx_size;                // Tx buffer size
     48             uint8_t* tx_buf;                 // Tx ring buffer
     49             bool     tx_progress;            // Tx in progress
     50          } uart_chan_T;
     51          
     52          
     53          /******************************************************************************/
     54          /* ROM Const Variables With File Level Scope                                  */
     55          /******************************************************************************/
     56          
     57          
     58          /******************************************************************************/
     59          /* Static Variables and Const Variables With File Level Scope                 */
     60          /******************************************************************************/
     61          uart_chan_T uart_chan[UART_NUM_CHANNELS];
     62          
     63          // Tx/Rx buffers (STM32F1 CL have 4 UART channels)
     64          static uint8_t uart0_rx_buf[UART0_RX_BUF_SIZE];
     65          static uint8_t uart0_tx_buf[UART0_TX_BUF_SIZE];
     66          static uint8_t uart1_rx_buf[UART1_RX_BUF_SIZE];
     67          static uint8_t uart1_tx_buf[UART1_TX_BUF_SIZE];
     68          static uint8_t uart2_rx_buf[UART2_RX_BUF_SIZE];
     69          static uint8_t uart2_tx_buf[UART2_TX_BUF_SIZE];
     70          static uint8_t uart3_rx_buf[UART3_RX_BUF_SIZE];
     71          static uint8_t uart3_tx_buf[UART3_TX_BUF_SIZE];
     72          
     73          
     74          
     75          /******************************************************************************/
     76          /* Function Prototypes for Private Functions with File Level Scope            */
     77          /******************************************************************************/
     78          static void u_do_tx (uint8_t chan);    // Transmit helper function
     79          static void uart_initialize_hook(uint8_t channel);
     80          
     81          void Uart_InitIO(uint8_t chan);
     82          
     83          /******************************************************************************/
     84          /* Add User defined functions                                                 */
     85          /******************************************************************************/
     86          
     87          /******************************************************************************/
     88          /* Function Definitions                                                       */
     89          /******************************************************************************/
     90          
     91          void Uart_InitIO(uint8_t chan)
     92          {
     93              USART_InitTypeDef USART_InitStructure;
     94              GPIO_InitTypeDef GPIO_InitStructure;
     95          
     96              switch(chan)
     97              {
     98                  case 0:
     99          		/* Configure USART1 Rx (PA10) as input floating */
    100          		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    101          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    102          		GPIO_Init( GPIOA, &GPIO_InitStructure );
    103          		
    104          		/* Configure USART1 Tx (PA9) as alternate function push-pull */
    105          		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    106          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    107          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    108          		GPIO_Init( GPIOA, &GPIO_InitStructure );
    109          
    110          		USART_InitStructure.USART_BaudRate = 115200;
    111          		USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    112          		USART_InitStructure.USART_StopBits = USART_StopBits_1;
    113          		USART_InitStructure.USART_Parity = USART_Parity_No ;
    114          		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    115          		USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    116          
    117          		USART_Init( USART1, &USART_InitStructure );
    118          		USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
    119          		USART_ITConfig(USART1, USART_IT_TC, DISABLE);
    120          		/* Enable the USART1 */
    121          		USART_Cmd(USART1, ENABLE);
    122                      break;
    123                  case 1:
    124          		/* Configure USART2 Rx (PA10) as input floating */
    125          		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
    126          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    127          		GPIO_Init( GPIOA, &GPIO_InitStructure );
    128          		
    129          		/* Configure USART2 Tx (PA9) as alternate function push-pull */
    130          		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
    131          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    132          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    133          		GPIO_Init( GPIOA, &GPIO_InitStructure );
    134          
    135          		USART_InitStructure.USART_BaudRate = 115200;
    136          		USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    137          		USART_InitStructure.USART_StopBits = USART_StopBits_1;
    138          		USART_InitStructure.USART_Parity = USART_Parity_No ;
    139          		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    140          		USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    141          
    142          		USART_Init( USART2, &USART_InitStructure );
    143          		USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
    144          		USART_ITConfig(USART2, USART_IT_TC, DISABLE);
    145          		/* Enable the USART2 */
    146          		USART_Cmd(USART2, ENABLE);
    147                      break;
    148                  case 2:
    149          		/* Configure USART3 Rx (PB11) as input floating */
    150          		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
    151          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    152          		GPIO_Init( GPIOB, &GPIO_InitStructure );
    153          
    154          		/* Configure USART3 Tx (PB10) as alternate function push-pull */
    155          		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    156          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    157          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    158          		GPIO_Init( GPIOB, &GPIO_InitStructure );
    159          
    160          		USART_InitStructure.USART_BaudRate = 9600;
    161          		USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    162          		USART_InitStructure.USART_StopBits = USART_StopBits_1;
    163          		USART_InitStructure.USART_Parity = USART_Parity_No ;
    164          		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    165          		USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    166          
    167          		USART_Init( USART3, &USART_InitStructure );
    168            		USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
    169          		USART_ITConfig(USART3, USART_IT_TC, DISABLE);
    170          		/* Enable the USART3 */
    171          		USART_Cmd(USART3, ENABLE);
    172                      	break;
    173                  case 3:
    174          		/* Configure  UART4 Tx (PC.10) as alternate function push-pull */
    175          		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    176          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
    177          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;//for K line
    178          		GPIO_Init(GPIOC, &GPIO_InitStructure);
    179          
    180          		/* Configure UART4  Rx (PC.11) as input floating */
    181          		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
    182          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    183          		GPIO_Init(GPIOC, &GPIO_InitStructure);
    184          
    185          		/* UART4 configuration ------------------------------------------------------*/
    186          		/* UART4 configured as follow:
    187          		- BaudRate = 10400 baud  
    188                		- Word Length = 8 Bits
    189          		- One Stop Bit
    190          		- No parity
    191          		- Hardware flow control disabled (RTS and CTS signals)
    192          		- Receive and transmit enabled
    193          		*/
    194          		//	USART_DeInit(UART4);
    195          		USART_InitStructure.USART_BaudRate = 115200;
    196          		USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    197          		USART_InitStructure.USART_StopBits = USART_StopBits_1;
    198          		USART_InitStructure.USART_Parity = USART_Parity_No ;
    199          		USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    200          		USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    201          
    202          		USART_Init(UART4, &USART_InitStructure);
    203          
    204          		/* Enable UART4 Receive and Transmit interrupts */
    205          		USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
    206          		USART_ITConfig(UART4, USART_IT_TC, DISABLE);
    207          
    208          		/* Enable the USART4 */
    209          		USART_Cmd(UART4, ENABLE);
    210          		break;
    211                  default:
    212                      break;
    213              }
    214          }
    215          
    216          void UART_ReConfig(uint32_t baudrate,uint16_t len,uint16_t stopbit,uint16_t parity)
    217          {
    218              	USART_InitTypeDef USART_InitStructure;
    219          
    220          	/* UART4 configuration ------------------------------------------------------*/
    221          	/* UART4 configured as follow:
    222          	- BaudRate = 360 baud  
    223                	- Word Length = 8 Bits
    224          	- One Stop Bit
    225          	- No parity
    226          	- Hardware flow control disabled (RTS and CTS signals)
    227          	- Receive and transmit enabled
    228          	*/
    229          	USART_DeInit(UART4);
    230          	USART_InitStructure.USART_BaudRate = baudrate;
    231          	USART_InitStructure.USART_WordLength = len;
    232          	USART_InitStructure.USART_StopBits = stopbit;
    233          	USART_InitStructure.USART_Parity = parity ;
    234          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    235          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    236          
    237          	USART_Init(UART4, &USART_InitStructure);
    238          
    239          	/* Enable UART4 Receive and Transmit interrupts */
    240          	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
    241          	USART_ITConfig(UART4, USART_IT_TC, DISABLE);
    242          
    243          	/* Enable the USART4 */
    244          	USART_Cmd(UART4, ENABLE);
    245          }
    246          
    247          /*******************************************************************************
    248          *    Function: Uart_Initialize
    249          *
    250          *  Parameters: Channel
    251          *     Returns: None
    252          * Description: Initialize UART specified by channel
    253          *******************************************************************************/
    254          void Uart_Initialize(uint8_t chan)
    255          {
    256             if (chan >= UART_NUM_CHANNELS) return;  // Invalid channel!
    257          
    258             uart_chan[chan].rx_count = 0;    // Clear rx byte counter
    259             uart_chan[chan].rx_in = 0;       // Clear rx buffer input before write index
    260             uart_chan[chan].rx_out = 0;      // Clear rx buffer output before read index
    261             //uart_chan[chan].rx_func = NULL;  // Initialize callback off
    262          
    263             uart_chan[chan].tx_count = 0;    // Clear tx byte counter
    264             uart_chan[chan].tx_in = 0;       // Clear tx buffer input before write index
    265             uart_chan[chan].tx_out = 0;      // Clear tx buffer output before read index
    266             uart_chan[chan].tx_progress = FALSE;   // Clear tx in progress flag
    267          
    268             // Initializations are channel specific
    269             switch (chan)
    270             {
    271                case 0:
    272          
    273                   uart_chan[chan].rx_buf = uart0_rx_buf;
    274                   uart_chan[chan].rx_size = UART0_RX_BUF_SIZE;
    275                   uart_chan[chan].tx_buf = uart0_tx_buf;
    276                   uart_chan[chan].tx_size = UART0_TX_BUF_SIZE;
    277                   uart_initialize_hook(chan);   // Have to set up pins here
    278                   Uart_InitIO(0);
    279                   break;
    280          
    281                case 1:
    282                   uart_chan[chan].rx_buf = uart1_rx_buf;
    283                   uart_chan[chan].rx_size = UART1_RX_BUF_SIZE;
    284                   uart_chan[chan].tx_buf = uart1_tx_buf;
    285                   uart_chan[chan].tx_size = UART1_TX_BUF_SIZE;
    286                   uart_initialize_hook(chan);   // Have to set up pins here
    287                   Uart_InitIO(1);
    288                   break;
    289          
    290                case 2:
    291                   uart_chan[chan].rx_buf = uart2_rx_buf;
    292                   uart_chan[chan].rx_size = UART2_RX_BUF_SIZE;
    293                   uart_chan[chan].tx_buf = uart2_tx_buf;
    294                   uart_chan[chan].tx_size = UART2_TX_BUF_SIZE;
    295                   uart_initialize_hook(chan);   // Have to set up pins here
    296                   Uart_InitIO(2);
    297                   break;
    298                case 3:
    299                   uart_chan[chan].rx_buf = uart3_rx_buf;
    300                   uart_chan[chan].rx_size = UART3_RX_BUF_SIZE;
    301                   uart_chan[chan].tx_buf = uart3_tx_buf;
    302                   uart_chan[chan].tx_size = UART3_TX_BUF_SIZE;
    303                   uart_initialize_hook(chan);   // Have to set up pins here
    304                   Uart_InitIO(3);
    305                   break;
    306                 default:
    307                   break;
    308             }
    309          }
    310          
    311          /*******************************************************************************
    312          *    Function: Uart_Get_Char
    313          *
    314          *  Parameters: Channel, Pointer to variable which can receive one byte of data
    315          *     Returns: TRUE if data is available and written to pointer, else FALSE
    316          * Description: Reads one byte from the UART receive buffer and writes it to a
    317          *              pointer provided by the caller. A value is also returned to
    318          *              indicate whether a byte was read.
    319          *******************************************************************************/
    320          bool Uart_Get_Char (uint8_t chan, uint8_t* ptr)
    321          {
    322             bool ret = FALSE;        // Return value. Assume buffer empty!
    323          
    324             // Error checking
    325             if (chan >= UART_NUM_CHANNELS) 
    326               	return FALSE; // Invalid channel!
    327             if (!ptr) 
    328               	return FALSE;    // Do not accept NULL pointers!
    329          
    330             Disable_Interrupts();
    331             if(uart_chan[chan].rx_in != uart_chan[chan].rx_out)// Rx buffer not empty
    332             {
    333                //uart_chan[chan].rx_count--;   // Decrement rx buffer byte count
    334                uart_chan[chan].rx_out++;     // Increment rx buffe output index
    335                if ((uart_chan[chan].rx_out) >= (uart_chan[chan].rx_size))
    336                {
    337                   uart_chan[chan].rx_out = 0; // Wrap index
    338                }
    339                *ptr = uart_chan[chan].rx_buf[uart_chan[chan].rx_out]; // Store read data
    340          
    341                ret = TRUE;
    342             }
    343             Enable_Interrupts();
    344          
    345             return (ret);
    346          }
    347          
    348          /*******************************************************************************
    349          *    Function: Uart_Put_Char
    350          *
    351          *  Parameters: Channel, Data to transmit
    352          *     Returns: TRUE on success, FALSE on failure
    353          * Description: Copy one byte to tx buffer
    354          *******************************************************************************/
    355          bool Uart_Put_Char (uint8_t chan, uint8_t data)
    356          {
    357             bool ret = FALSE;        // Return value. Assume buffer full!
    358          
    359             if (chan >= UART_NUM_CHANNELS) 
    360             	return FALSE; // Invalid channel!
    361          
    362             /** Enter Critical Section can not restart during this time ***/
    363             Disable_Interrupts();
    364          
    365             // Tx buffer not full
    366             if (uart_chan[chan].tx_count < (uart_chan[chan].tx_size))
    367             {
    368                uart_chan[chan].tx_count++;   // Increment tx buffer byte count
    369                uart_chan[chan].tx_in++;      // Increment tx buffer input index
    370                if ((uart_chan[chan].tx_in) >= (uart_chan[chan].tx_size))
    371                {
    372                   uart_chan[chan].tx_in = 0; // Wrap index
    373                }
    374                uart_chan[chan].tx_buf[uart_chan[chan].tx_in] = data; // Copy byte to tx buffer
    375                ret = TRUE;
    376             }
    377          
    378             if (FALSE == uart_chan[chan].tx_progress) // Send first byte. Interrupts do the rest.
    379             {
    380                u_do_tx(chan);          // Send to hardware
    381                uart_chan[chan].tx_progress = TRUE;    // Flag tx in progress
    382                switch(chan)
    383                {
    384                    case 0:
    385                      USART_ITConfig(USART1, USART_IT_TC, ENABLE);
    386                      break;
    387                    case 1:
    388                      USART_ITConfig(USART2, USART_IT_TC, ENABLE);
    389                      break;
    390                    case 2:
    391                      USART_ITConfig(USART3, USART_IT_TC, ENABLE);
    392                      break;
    393                    case 3:
    394                      USART_ITConfig(UART4, USART_IT_TC, ENABLE);
    395                      break;
    396                }
    397             }
    398          
    399             Enable_Interrupts();
    400             return (ret);
    401          }
    402          
    403          /*******************************************************************************
    404          *    Function: u_do_tx
    405          *
    406          *  Parameters: Channel
    407          *     Returns: Nothing
    408          * Description: Transmit helper function. Takes one byte from transmit queue
    409          *              and sends it to the hardware. Provides common code for first
    410          *              byte transmission (before transmit interrupt is enabled) and
    411          *              successive byte transmission (from transmit interrupt).
    412          *******************************************************************************/
    413          static void u_do_tx (uint8_t chan)
    414          {
    415              USART_TypeDef* tmp_USARTx;
    416          
    417              switch(chan)
    418              {
    419                  case 0:
    420                      tmp_USARTx = USART1;
    421                      break;
    422                  case 1:
    423                      tmp_USARTx = USART2;
    424                      break;
    425                  case 2:
    426                      tmp_USARTx = USART3;
    427                      break;
    428                  case 3:
    429                      tmp_USARTx = UART4;
    430                      break;
    431                  default:
    432          	   return;
    433                      break;
    434              }
    435          
    436              uart_chan[chan].tx_count--;      // Decrement tx buffer byte count
    437              uart_chan[chan].tx_out++;        // Increment index
    438              if ((uart_chan[chan].tx_out) >= (uart_chan[chan].tx_size))
    439              {
    440                 uart_chan[chan].tx_out = 0; // Wrap index
    441              }
    442          
    443              // Write to hardware transmit register
    444              USART_SendData(tmp_USARTx,uart_chan[chan].tx_buf[uart_chan[chan].tx_out]);
    445          
    446              //if(chan == UART_3G_CHANNEL)
    447                  //DEBUG_PRINT1( DEBUG_MEDIUM, "%c\r\n", uart_chan[chan].tx_buf[uart_chan[chan].tx_out]);
    448          }
    449          
    450          /*******************************************************************************
    451          *    Function: UART_TX_ISR
    452          *
    453          *  Parameters: Channel
    454          *     Returns: None
    455          * Description: UART transmit Interrupt Service Routine
    456          *******************************************************************************/
    457          void UART_TX_ISR(uint8_t chan)      
    458          {
    459              USART_TypeDef* tmp_USARTx;
    460          
    461              switch(chan)
    462              {
    463                  case 0:
    464                      tmp_USARTx = USART1;
    465                      break;
    466                  case 1:
    467                      tmp_USARTx = USART2;
    468                      break;
    469                  case 2:
    470                      tmp_USARTx = USART3;
    471                      break;
    472                  case 3:
    473                      tmp_USARTx = UART4;
    474                      break;
    475                  default:
    476          	   return;
    477                      break;
    478              }
    479          
    480              if (uart_chan[chan].tx_in != uart_chan[chan].tx_out) // Any bytes to send?
    481              {
    482                  u_do_tx(chan);       // Send to hardware
    483              }
    484              else
    485              {
    486                  uart_chan[chan].tx_progress = FALSE;     // Disable transmit
    487                  USART_ITConfig(tmp_USARTx, USART_IT_TC, DISABLE);
    488              }
    489          }
    490          
    491          /*******************************************************************************
    492          *    Function: UART_RX_ISR
    493          *
    494          *  Parameters: Channel
    495          *     Returns: None
    496          * Description: UART recieve Interrupt Service Routine
    497          *******************************************************************************/
    498          void UART_RX_ISR(uint8_t chan)
    499          {
    500              volatile uint8_t data;
    501              volatile uint8_t err;
    502              USART_TypeDef* tmp_USARTx;
    503          
    504              if (chan >= UART_NUM_CHANNELS)
    505                  return;  // Invalid channel!
    506          
    507              switch(chan)
    508              {
    509                  case 0:
    510                      tmp_USARTx = USART1;
    511                      break;
    512                  case 1:
    513                      tmp_USARTx = USART2;
    514                      break;
    515                  case 2:
    516                      tmp_USARTx = USART3;
    517                      break;
    518                  case 3:
    519                      tmp_USARTx = UART4;
    520                      break;
    521                  default:
    522                      break;
    523              }
    524          
    525              err = tmp_USARTx->SR;
    526          
    527              /* Read one byte from the receive data register */
    528              data = (uint16_t)(tmp_USARTx->DR & (uint16_t)0x01FF);
    529          
    530          //    if ((err&0x0f)!=0)
    531          //        UART3_Err_Inc();
    532              if(0==((UART_ERR_FRAME | UART_ERR_PARITY)&err))
    533              {
    534                  //uart_chan[chan].rx_count++;
    535                  uart_chan[chan].rx_in++;
    536                  if ((uart_chan[chan].rx_in) >= (uart_chan[chan].rx_size))
    537                  {
    538                      uart_chan[chan].rx_in = 0; // Wrap index
    539                  }
    540                  
    541                  if(uart_chan[chan].rx_in != uart_chan[chan].rx_out)
    542                  {
    543                      uart_chan[chan].rx_buf[uart_chan[chan].rx_in] = data; // Copy data to receive buffer
    544                  }
    545                  else                                    // Rx buffer full
    546                  {
    547                      NOP();// Receive buffer overflow. How to handle?
    548                  }
    549              }
    550              else
    551              {
    552                  if(chan == UART_GSM_CHANNEL)
    553                  {
    554                      __asm("nop");
    555                  }
    556              }
    557              //if(chan == UART_KLINE_CHANNEL)
    558                  //DEBUG_PRINT1( DEBUG_MEDIUM, "%c\r\n", uart_chan[chan].rx_buf[uart_chan[chan].rx_in]);
    559          }
    560          /*******************************************************************************
    561          *    Function: UART_ERR_ISR
    562          *
    563          *  Parameters: Channel
    564          *     Returns: None
    565          * Description: UART ERR Interrupt Service Routine
    566          *******************************************************************************/
    567          void UART_ERR_ISR(uint8_t chan)
    568          {
    569              volatile uint8_t data;
    570              volatile uint8_t err;
    571              USART_TypeDef* tmp_USARTx;
    572          
    573              switch(chan)
    574              {
    575                  case 0:
    576                      tmp_USARTx = USART1;
    577                      break;
    578                  case 1:
    579                      tmp_USARTx = USART2;
    580                      break;
    581                  case 2:
    582                      tmp_USARTx = USART3;
    583                      break;
    584                  case 3:
    585                      tmp_USARTx = UART4;
    586                      break;
    587                  default:
    588          	    return;
    589                      break;
    590              }
    591          
    592              //clear error
    593              err = tmp_USARTx->SR;
    594              data = (uint16_t)(tmp_USARTx->DR & (uint16_t)0x01FF);
    595          }
    596          
    597          /******************************************************************************/
    598          /* Function Definitions                                                       */
    599          /******************************************************************************/
    600          
    601          /*******************************************************************************
    602          *    Function: uart_initialize_hook
    603          *  Parameters: Channel
    604          *     Returns: None
    605          * Description: Project specific initializations for UART
    606          *******************************************************************************/
    607          void uart_initialize_hook(uint8_t channel)
    608          {    
    609              switch (channel)
    610              {
    611                  case 0:
    612                      break;
    613                  case 1:
    614                      break;
    615                  case 2:
    616                      break;
    617                  case 3:
    618                      break;
    619                  default:
    620          	    return;
    621                      break;
    622              }
    623          }
    624          
    625          /*******************************************************************************
    626          *    Function: UART_Transmit
    627          *  Parameters: Channel
    628          *              pointer to transmit data buffer
    629          *              number of bytes to send
    630          *     Returns: Number of bytes successfully sent/buffered
    631          * Description: This function is used only as legacy code for XM CBM diagnostics (not efficient)
    632          *              Driver task using UART driver should use Uart_Put_Char directly to queue
    633          *               bytes on transmit buffer and check return value to verify if byte to
    634          *               transmit is successfully sent/buffered. If not, task should sleep to allow
    635          *               Tx buffer to allow room for byte to be buffered.
    636          *              Tx Buffer size should be configured accordingly
    637          *******************************************************************************/
    638          extern uint8_t UART_Transmit(uint8_t channel, const uint8_t* tx_buf, uint8_t bytes)
    639          {
    640              uint8_t ret = 0;
    641              int i;
    642          
    643              for (i=0; i < bytes; i++)
    644              {
    645                  if ( Uart_Put_Char(channel, *(tx_buf + i)) )
    646                  {
    647                      ret++;
    648                  }
    649              }
    650          
    651              return (ret);
    652          }
    653          
    654          /*******************************************************************************
    655          *    Function: UART_Rx_Empty
    656          *  Parameters: Channel
    657          *     Returns: Nothing
    658          * Description: Reconfigures UART channel's pins to be I/O input (disables UART function)
    659          *******************************************************************************/
    660          bool UART_Rx_Empty (uint8_t chan)
    661          {
    662              return ((0 ==uart_chan[chan].rx_count)&& (uart_chan[chan].rx_in == uart_chan[chan].rx_out));
    663          }
    664          /*******************************************************************************
    665          *  Function: UART_Reset_Buf
    666          *
    667          *  Parameters: None
    668          *  Returns: None
    669          *  Description: Intialize the specified uart device
    670          *******************************************************************************/
    671          void UART_Reset_Buf(uint8_t chan)
    672          {
    673              if (chan >= UART_NUM_CHANNELS)
    674                  return;  // Invalid channel!
    675          
    676              if (NULL != &uart_chan[chan]) 
    677              {
    678                  uart_chan[chan].rx_count = 0; // Clear rx byte counter
    679                  uart_chan[chan].rx_in = 0;    // Increment before write index
    680                  uart_chan[chan].rx_out = 0;   // Increment before read index
    681          
    682                  uart_chan[chan].tx_count = 0; // Clear tx byte counter 
    683                  uart_chan[chan].tx_in = 0;    // Clear tx buffer input before write index
    684                  uart_chan[chan].tx_out = 0;   // Clear tx buffer output before read index
    685                  uart_chan[chan].tx_progress = false;   // Clear tx in progress flag
    686              }
    687          }
    688          
    689          /*=======================================================================================*\
    690           * File Revision History
    691           *=======================================================================================
    692           * ----------  ------   ---------------------------------------------
    693           *
    694           *
    695          \*=======================================================================================*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   UART_ERR_ISR
       4   UART_RX_ISR
      40   UART_ReConfig
        40   -> USART_Cmd
        40   -> USART_DeInit
        40   -> USART_ITConfig
        40   -> USART_Init
       0   UART_Reset_Buf
       0   UART_Rx_Empty
       8   UART_TX_ISR
         8   -> USART_ITConfig
         8   -> u_do_tx
      24   UART_Transmit
        24   -> Uart_Put_Char
      16   Uart_Get_Char
        16   -> ulPortSetInterruptMask
        16   -> vPortClearInterruptMask
      24   Uart_InitIO
        24   -> GPIO_Init
        24   -> USART_Cmd
        24   -> USART_ITConfig
        24   -> USART_Init
       8   Uart_Initialize
         8   -> Uart_InitIO
         8   -> uart_initialize_hook
      16   Uart_Put_Char
        16   -> USART_ITConfig
        16   -> u_do_tx
        16   -> ulPortSetInterruptMask
        16   -> vPortClearInterruptMask
       8   u_do_tx
         8   -> USART_SendData
       0   uart_initialize_hook


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      52  UART_ERR_ISR
     212  UART_RX_ISR
      98  UART_ReConfig
     132  UART_Reset_Buf
      56  UART_Rx_Empty
     104  UART_TX_ISR
      54  UART_Transmit
     200  Uart_Get_Char
     586  Uart_InitIO
     522  Uart_Initialize
     352  Uart_Put_Char
     190  u_do_tx
     152  uart0_rx_buf
     152  uart0_tx_buf
    1100  uart1_rx_buf
    1000  uart1_tx_buf
     600  uart2_rx_buf
     100  uart2_tx_buf
      20  uart3_rx_buf
      20  uart3_tx_buf
     112  uart_chan
      28  uart_initialize_hook

 
 3 256 bytes in section .bss
 2 650 bytes in section .text
 
 2 650 bytes of CODE memory
 3 256 bytes of DATA memory

Errors: none
Warnings: none
