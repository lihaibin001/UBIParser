###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.2.11947/W32 for ARM       15/Sep/2017  09:59:26
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\workspace\dr002\dr002_suming\v1_board\main_app\Power\Psync.c
#    Command line =  
#        D:\workspace\dr002\dr002_suming\v1_board\main_app\Power\Psync.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -lcN
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\List
#        --diag_suppress Pa050 -o
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\.\ -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Diag_Factory\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\common\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\power\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\SysMan\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Protocol\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\include\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\FreeRTOS\include\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\FreeRTOS\portable\IAR\ARM_CM3\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\drivers\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\GPS\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\GPRS\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Sensors\
#        -Ol --use_c++_inline --require_prototypes
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\List\Psync.lst
#    Object file  =  
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\Obj\Psync.o
#
###############################################################################

D:\workspace\dr002\dr002_suming\v1_board\main_app\Power\Psync.c
      1          /*----------------------------------------------------------------------------/
      2           *  (C)Dedao, 2016
      3           *-----------------------------------------------------------------------------/
      4           *
      5           * Copyright (C) 2016, Dedao, all right reserved.
      6           *
      7           * 1. Redistributions of source code must retain the above copyright notice,
      8           *    this condition and the following disclaimer.
      9           *
     10           * This software is provided by the copyright holder and contributors "AS IS"
     11           * and any warranties related to this software are DISCLAIMED.
     12           * The copyright owner or contributors be NOT LIABLE for any damages caused
     13           * by use of this software.
     14           *----------------------------------------------------------------------------*/
     15          /* $Header:   psync.c  $*/
     16          /**********************************************************************
     17           *       Title:   psync.c
     18           *
     19           *  Description:  This is the standard code file for psync.
     20           *
     21           *      Author:   
     22           *
     23           *********************************************************************/
     24          
     25          /**********************************************************************
     26           * Installation Instructions (periodic tasks, etc.)
     27           *
     28           *********************************************************************/
     29          
     30          /**********************************************************************
     31           * Include header files
     32           *********************************************************************/
     33          /* Dependent "compile.cmd"                                           */
     34          /*********************************************************************/
     35          #include "standard.h"
     36          #include "fsm.h"
     37          #include "Psync.hee"
     38          
     39          #include "TelmApp.h"
     40          #include "ATProtocol.h"
     41          #include "TelmProtocol.h"
     42          
     43          #define USE_DEBUG
     44          #include "Debug.h"
     45          
     46          /*********************************************************************
     47           * File level pragmas
     48           *********************************************************************/
     49          
     50          /**********************************************************************
     51           * Constant and Macro Definitions using #define
     52           *********************************************************************/
     53          #define PS_IO_DELAY 32
     54          
     55          #define IGNITION_ON_DBNC  (32/PS_IO_DELAY) 
     56          #define IGNITION_OFF_DBNC (250/PS_IO_DELAY)
     57          
     58          
     59          #define CAN_Get_Ignition_State()  PS_Logical_Ignition_On()
     60          
     61          /**********************************************************************
     62           * Enumerations and Structures and Typedefs
     63           *********************************************************************/
     64          
     65          /**********************************************************************
     66           * Global and Const Variable Defining Definitions / Initializations
     67           *********************************************************************/
     68          static ps_data_type ps_data = {0,0,0,false,false};
     69          static PS_Cal_T ps_cal_data = {3,3,2};
     70          //static PS_Cal_T ps_cal_data = {0xffff,0xffff,0xffff};
     71          /**********************************************************************
     72           * Static Variables and Const Variables With File Level Scope
     73           *********************************************************************/
     74          static bool idle_is_requested = false;
     75          static bool rtc_is_not_requested = false;
     76          
     77          __no_init uint8_t can_wakeup_cnt ;
     78          
     79          /**********************************************************************
     80           * ROM Const Variables With File Level Scope
     81           *********************************************************************/
     82          /**********************************************************************
     83           * Function Prototypes for Private Functions with File Level Scope
     84           *********************************************************************/
     85          static void PS_Set_Logical_IGN_State(bool state);
     86          static void PS_Set_Logical_Eng_State(bool state);
     87          /*** STT Functions ***/
     88          static uint8_t no_action(void);
     89          static uint8_t ps_start_action(void);
     90          
     91          static uint8_t ps_entry_root(void);
     92          static uint8_t ps_entry_idle(void);
     93          static uint8_t ps_entry_awake(void);
     94          //static uint8_t ps_entry_sys_on(void);
     95          //static uint8_t ps_entry_user_on(void);
     96          static uint8_t ps_entry_eng_on(void);
     97          static uint8_t ps_exit_awake(void);
     98          //static uint8_t ps_exit_user_on(void);
     99          static uint8_t ps_exit_eng_on(void);
    100          
    101          static uint8_t ps_cs_root(void);
    102          static uint8_t ps_cs_idle(void);
    103          static uint8_t ps_cs_awake(void);
    104          //static uint8_t ps_cs_sys_on(void);
    105          //static uint8_t ps_cs_user_on(void);
    106          static uint8_t ps_cs_eng_on(void);
    107          
    108          //static uint8_t ps_check_user_mode_condition (void);
    109          //static uint8_t ps_check_obd_active_user_on (void);
    110          //static uint8_t ps_check_obd_active (void);
    111          
    112          //static uint8_t ps_check_can_sleep (void);
    113          
    114          //static uint8_t ps_set_force_user_off(void);
    115          //static uint8_t ps_start_stdby_tmr(void);
    116          //static uint8_t ps_restart_stdby_tmr(void);
    117          //static uint8_t ps_stop_obd_on_tmr(void);
    118          //static uint8_t ps_set_user_off_start_stdby_tmr (void);
    119          //static uint8_t ps_set_ign_on_to_awake (void);
    120          
    121          /********************************/
    122          /* STATE TRANSITION DESCRIPTION */
    123          /********************************/
    124          #include "fsm_tran.h"
    125          #include "ps_stt.h"
    126          
    127          /********************************/
    128          /* STATE TREE DESCRIPTION       */
    129          /********************************/
    130          #include "fsm_tree.h"
    131          #include "ps_stt.h"
    132          
    133          /**********************************************************************
    134           * Add User defined functions
    135           *********************************************************************/
    136          
    137          /*===========================================================================*
    138           *
    139           * Please refer to the detailed description in psync.h.
    140           *
    141           *===========================================================================*/
    142          //bool PS_Is_Obd_Off_Requested(void)
    143          //{
    144          //    return false;
    145          //}
    146          
    147          /**********************************************************************
    148           * Function Definitions
    149           *********************************************************************/
    150          
    151          /**********************************************************************
    152          *
    153          *    Function: PS_Initialize
    154          *
    155          *  Parameters: none
    156          *
    157          *     Returns: none
    158          *
    159          * Description: Initialization of the PSYNC module
    160          *
    161          **********************************************************************/
    162          void PS_Initialize (void)
    163          {
    164              PS_Current_State_T new_state = 0;
    165              Data_Message_T     msg;
    166          
    167              if(Cold_Start())
    168              {
    169                  PS_Set_Last_State(0);//set last state as PS_ROOT if cold start
    170                  
    171                  Sys_Clear_Int_battery_Flag();
    172              }
    173          
    174              msg.parts.msg  = START;
    175              msg.parts.data = 0;
    176              new_state = FSM_Process_Evt(msg, PS_ROOT, tree_psync);
    177              PS_Set_Current_State(new_state);
    178          }
    179          
    180          /**********************************************************************
    181          *
    182          *    Function: PS_Task
    183          *
    184          *  Parameters: none
    185          *
    186          *     Returns: none
    187          *
    188          * Description: Entry point for the psync task.
    189          *
    190          **********************************************************************/
    191          void Psync_Task ( void *pvParameters )
    192          {
    193              Data_Message_T     msg;
    194              Status_Type        status;
    195              PS_Current_State_T new_state;
    196              bool               state_changed;
    197              #ifdef USE_DEBUG
    198              DEBUG_PRINT0( DEBUG_MEDIUM, "[Psync]:Psync TASK Started!\r\n");
    199              #endif
    200          
    201          
    202          #if 0
    203              if ((Cold_Start())
    204              	||(Sys_Is_Gsensor_Wakeup())
    205              	||(Sys_Is_Low_Batt_Wakeup()))
    206              {
    207                  PS_Set_Obd_On(true);/*cold start, enter power on 5min mode*/
    208              }
    209          #endif
    210              
    211              FOREVER
    212              {
    213          
    214                  state_changed = false;
    215          
    216                  // wait until next event in mailbox OR time expired
    217                  status = OS_Wait_Message(OS_PSYNC_TASK,&msg.all, PS_TASK_REQUEUE_TIME);
    218          
    219                  // process ALL events in queue first !!!
    220                  while (E_OK == status)
    221                  {
    222                      // process event
    223                      new_state = FSM_Process_Evt(msg, PS_Get_Current_State(), tree_psync);
    224          
    225                      if (new_state != PS_Get_Current_State())
    226                      {
    227                          PS_Set_Current_State(new_state);
    228          	            #ifdef USE_DEBUG
    229                          DEBUG_PRINT1(DEBUG_HIGH,"[PSYNC]:PS STATE IS %x\n\r",new_state);
    230                          #endif
    231                          state_changed = true;
    232                      }
    233          
    234                      // get next event from mailbox without waiting
    235                      status = OS_Receive_Message(OS_PSYNC_TASK,&msg.all);
    236                  }
    237          
    238                  // process all cs routines for the active state tree branch
    239                  FSM_Process_CS(PS_Get_Current_State(), tree_psync);
    240          
    241                  if (state_changed)
    242                  {
    243                      OS_Release_Resource(RES_RELAYS);
    244                  }
    245              }
    246          }
    247          /*********************************************************************/
    248          /*no actions                                                     */
    249          /*********************************************************************/
    250          static uint8_t no_action(void)
    251          {
    252             return(0);
    253          }
    254          /*********************************************************************/
    255          /* start actions                                                     */
    256          /*********************************************************************/
    257          static uint8_t ps_start_action (void)
    258          {
    259              ps_put_permanent_sleep( false );
    260              ps_put_awake_requested( false );
    261              return(0);
    262          }
    263          
    264          /*********************************************************************/
    265          /* entry actions                                                     */
    266          /*********************************************************************/
    267          static uint8_t ps_entry_root (void)
    268          {
    269             PS_Current_State_T last_state = PS_Get_Last_State();
    270          
    271             /* correction of last_state */
    272             switch (last_state)
    273             {
    274          //      case PS_USER_ON:
    275          //      case PS_ENG_ON:
    276          //         last_state = PS_SYS_ON;
    277          //         break;
    278                   
    279                case PS_AWAKE:
    280                   /* do nothing, last state is okay */
    281                   break;
    282          
    283                default:
    284                   last_state = PS_AWAKE;
    285                   break;   
    286             }
    287          
    288          //   if (last_state == PS_AWAKE)
    289          //   {
    290          //      /* start standby timer to stay at least 30s in PS_AWAKE */
    291          //      TMR_Start_Timer(PS_STDBY_TIMER, PS_STDBY_TIME3, null_action);
    292          //   }
    293          //   
    294             return(last_state);
    295          }
    296          
    297          static uint8_t ps_entry_idle (void)
    298          {
    299             TMR_Stop_Timer(PS_STDBY_TIMER);
    300          
    301             {
    302                ps_put_permanent_sleep( true );
    303             }
    304          
    305             return(PS_IDLE);
    306          }
    307          
    308          static uint8_t ps_entry_awake (void)
    309          {
    310          //   PS_Set_Last_State(PS_AWAKE);
    311            Tick_Type awake_time;
    312            PS_Current_State_T last_state = PS_Get_Last_State();
    313          
    314             //start timer for a period to stay at least in PS_Awake before going PS_Idle
    315             if (PS_MIN_AWAKE_TIME > TMR_Get_Pending_Time(PS_MIN_AWAKE_TIMER))
    316             {
    317                if(MDG_In_Mode())
    318                {
    319                	TMR_Start_Timer(PS_MIN_AWAKE_TIMER, 0, null_action);//enter sleep right now
    320                }
    321                else if(Sys_Is_RTC_Deep_Wakeup())
    322                {
    323                	TMR_Start_Timer(PS_MIN_AWAKE_TIMER, 1000, null_action);
    324                }
    325                else
    326                {
    327                	TMR_Start_Timer(PS_MIN_AWAKE_TIMER, PS_MIN_AWAKE_TIME, null_action);
    328                }
    329             }
    330          
    331             if (Sys_Get_Int_battery_Flag())
    332             {
    333               awake_time = PS_STDBY_INT_BATT_TIME;
    334             }
    335             else if (last_state == PS_ENG_ON)
    336             {
    337               /* start standby timer to stay 300s in PS_AWAKE */
    338               awake_time = PS_STDBY_TIME_FROM_ENG_ON;
    339             }
    340             else
    341             {
    342               /* start standby timer to stay 30s in PS_AWAKE */
    343               awake_time = PS_STDBY_TIME3;     
    344             }
    345          
    346             TMR_Start_Timer(PS_STDBY_TIMER, awake_time, null_action);
    347             PS_Set_Last_State(PS_AWAKE);
    348             return(PS_AWAKE);
    349          }
    350          
    351          /*
    352          static uint8_t ps_entry_sys_on (void)
    353          {
    354             PS_Current_State_T last_state = PS_Get_Last_State();
    355          
    356             // correction of last_state in error case
    357             if ((last_state != PS_USER_ON)
    358             &&  (last_state != PS_ENG_ON))
    359             {
    360                last_state = PS_USER_ON;
    361             }
    362          
    363             return(last_state);
    364          }
    365          */
    366          
    367          //
    368          //static uint8_t ps_entry_user_on (void)
    369          //{
    370          //   PS_Set_Last_State(PS_USER_ON);
    371          //   ps_put_user_on( true );
    372          //   TMR_Stop_Timer(PS_STDBY_TIMER);
    373          //
    374          //   /* start timer only if ign off and manuf diag not active AND eng diag not active */
    375          //   if ((PS_Logical_Ignition_On() == ON))
    376          //   {
    377          //      /* start OBD_ON timer to stay here before going back to PS_Awake */
    378          //      if(PS_Get_Obd_On_Minutes() != 0xFFFF)
    379          //      {
    380          //      }
    381          //   }
    382          //   else
    383          //   {
    384          //      /* start OBD_ON timer to stay here before going back to PS_Awake */
    385          //      if(PS_Get_Obd_On_Minutes() != 0xFFFF)
    386          //      {
    387          //              if((Sys_Is_Gsensor_Wakeup())
    388          //                  ||(Sys_Is_Low_Batt_Wakeup()))
    389          //              {
    390          //
    391          //              }
    392          //              else
    393          //              {
    394          //
    395          //              }
    396          //      }
    397          //      else
    398          //      {
    399          //
    400          //      }
    401          //   }      
    402          //   return(PS_USER_ON);
    403          //}
    404          //
    405          
    406          static uint8_t ps_entry_eng_on (void)
    407          {
    408             PS_Set_Last_State(PS_ENG_ON);
    409             Periodic_Clear_Low_Volt_Cnt();
    410             
    411             //
    412             TMR_Start_Timer(PS_INT_BATT_CHRG_DELAY_TIMER, PS_CHRG_DELAY_TIME, null_action);
    413             
    414             return(PS_ENG_ON);
    415          }
    416          
    417          /*********************************************************************/
    418          /* exit actions                                                      */
    419          /*********************************************************************/
    420          static uint8_t ps_exit_awake (void)
    421          {
    422             TMR_Stop_Timer(PS_MIN_AWAKE_TIMER);
    423             TMR_Stop_Timer(PS_STDBY_TIMER);
    424             return(0);
    425          }
    426          
    427          //static uint8_t ps_exit_user_on (void)
    428          //{
    429          //   return(0);
    430          //}
    431          
    432          static uint8_t ps_exit_eng_on (void)
    433          {
    434             write_flash_last_pos();
    435             
    436             //
    437             TMR_Stop_Timer(PS_INT_BATT_CHRG_DELAY_TIMER);
    438             TMR_Stop_Timer(PS_INT_BATT_CHRG_TIMER);
    439             IO_CHARGE_CTL(Bit_RESET);
    440             
    441          #if 0
    442             OS_Send_Message(OS_IOT_TASK, Build_Message(TM_EVT_ENG_ON_OFF, OFF));
    443          #endif
    444             return(0);
    445          }
    446          
    447          /*********************************************************************/
    448          /* cs routines                                                       */
    449          /*********************************************************************/
    450          static uint8_t ps_cs_root (void)
    451          {
    452             return(0);
    453          }
    454          
    455          static uint8_t ps_cs_idle (void)
    456          {
    457              if (ps_awake_requested())
    458              {
    459                  OS_Send_Message(OS_PSYNC_TASK, PS_EVT_AWAKE);
    460              }
    461              else
    462              {
    463                  OS_Release_Resource(RES_RELAYS);
    464              }
    465              return(0);
    466          }
    467          
    468          static uint8_t ps_cs_awake (void)
    469          {
    470              /* check timer first to block checking of the other*/
    471             /*...function for at least PS_MIN_AWAKE_TIME*/
    472             if (TMR_Check_Timer(PS_MIN_AWAKE_TIMER))
    473             {
    474          //      if ((PS_Is_Idle_Requested())
    475          //	  	|| (Sys_Is_RTC_Deep_Wakeup()))
    476          //      {
    477          //         /* force immediate shutdown */
    478          ////         OS_Send_Message(OS_PSYNC_TASK, PS_EVT_IDLE);
    479          //      }
    480          //      else
    481                {
    482                   if (TMR_Check_Timer(PS_STDBY_TIMER))/*standby time is up,go to idle*/
    483                   {
    484          //              OS_Send_Message(OS_PSYNC_TASK, PS_EVT_IDLE);
    485                      if (!ACC_Is_Volt_Checking())
    486                      {
    487                          OS_Send_Message(OS_PSYNC_TASK, PS_EVT_GO_IDLE);
    488                      }
    489                   }
    490                }         
    491             }
    492          
    493          //   if (TMR_Check_Timer(PS_STDBY_TIMEOUT_TIMER))//standby timeout, force sleep
    494          //   {
    495          //      DEBUG_PRINT0(DEBUG_HIGH,"[SYSTEM]:Standby Timeout, Force Sleep!!!\n\r");
    496          //      RL_Force_Sleep();
    497          //   }
    498          
    499             if (!Sys_Get_Int_battery_Flag())      // not use internal battery case
    500             {     
    501           //    if(ACC_Is_On_After_Delay())     //ACC on
    502               if(rl_get_acc_status())     //ACC on
    503               {
    504                 PS_Set_Ignition(ON);
    505               }
    506             }
    507             return(0);
    508          }
    509          
    510          //static uint8_t ps_cs_sys_on (void)
    511          //{
    512          //   return(0);
    513          //}
    514          
    515          //static uint8_t ps_cs_user_on (void)
    516          //{
    517          ////   if ((TMR_Check_Timer(PS_OBD_ON_TIMER))
    518          ////   	&&(!MDG_In_Mode()))
    519          //   {
    520          ////      OS_Send_Message(OS_PSYNC_TASK, PS_EVT_OBD_ON_TMR_EXP);
    521          //   }
    522          //   return(0);
    523          //}
    524          
    525          static uint8_t ps_cs_eng_on (void)
    526          {
    527              uint16_t vol_ext=Pwr_Fail_Get_Voltage();
    528              uint16_t vol_int=Pwr_Fail_Get_Int_Voltage();
    529              
    530              if((!rl_get_acc_status()) || Sys_Get_Int_battery_Flag()) /* ACC OFF */
    531              {
    532                  PS_Set_Ignition(OFF);
    533              }
    534              
    535              if (TMR_Check_Timer(PS_INT_BATT_CHRG_DELAY_TIMER))
    536              {
    537                  if (Pwr_Is_Charge_Request() && (!TMR_Is_Timer_Active(PS_INT_BATT_CHRG_TIMER)))
    538                  {
    539                    TMR_Start_Timer(PS_INT_BATT_CHRG_TIMER, PS_CHRG_TIME, null_action);
    540                    IO_CHARGE_CTL(Bit_SET);
    541                    DEBUG_PRINT1(DEBUG_MEDIUM,"[RELAY]Int Battery start charing=%d\n\r",vol_int);
    542                  }
    543                  else if (TMR_Check_Timer(PS_INT_BATT_CHRG_TIMER))
    544                  {
    545                    IO_CHARGE_CTL(Bit_RESET); // time out, stop chagring
    546                  }
    547                  else
    548                  {
    549                    //In charging
    550                  }
    551              }
    552              
    553              return(0);
    554          }
    555          
    556          
    557          /*********************************************************************/
    558          /* condition actions                                                 */
    559          /*********************************************************************/
    560          //static uint8_t ps_check_user_mode_condition (void)
    561          //{
    562          //   uint8_t condition = 1;
    563          //
    564          //   if (PS_Logical_Ignition_On())
    565          //      condition = 1;
    566          //   else
    567          //      condition = 2;
    568          //
    569          //   return(condition);
    570          //}
    571          //
    572          //static uint8_t ps_check_obd_active_user_on (void)
    573          //{
    574          //   uint8_t condition = 2;
    575          //   
    576          //   if (false)
    577          //   {
    578          //      condition = 1;
    579          //   }
    580          //   else
    581          //   {
    582          //      condition = 2;
    583          //   }
    584          //   return(condition);
    585          //}
    586          //
    587          //static uint8_t ps_check_obd_active (void)
    588          //{
    589          //   uint8_t condition = 2;
    590          //
    591          //   if (false)//(Pwr_Fail_Is_Reset_Condition())
    592          //      condition = 1;
    593          //   else
    594          //      condition = 2;
    595          //
    596          //   return(condition);
    597          //}
    598          //
    599          //#if 0
    600          //static uint8_t ps_check_user_on (void)
    601          //{
    602          //   uint8_t condition = 2;
    603          //
    604          //   if (ps_user_on())
    605          //      condition = 1;
    606          //   else
    607          //      condition = 2;
    608          //
    609          //   return(condition);
    610          //}
    611          //#endif
    612          //static uint8_t ps_check_can_sleep (void)
    613          //{
    614          //   uint8_t condition = 2;
    615          //
    616          //  return(condition);
    617          //}
    618          
    619          /*********************************************************************/
    620          /* transition actions                                                */
    621          /*********************************************************************/
    622          //static uint8_t ps_set_force_user_off (void)
    623          //{
    624          //   ps_put_user_on( false );
    625          //   DEBUG_PRINT0(DEBUG_HIGH,"[SYSTEM]:ACC ON time out, Force Sleep!!!\n\r");
    626          //   RL_Force_Sleep();//force sleep, disable can interrupt
    627          //   return(0);
    628          //}
    629          //
    630          //static uint8_t ps_set_user_off_start_stdby_tmr (void)
    631          //{
    632          //   ps_put_user_on( false );
    633          //
    634          //   TMR_Start_Timer(PS_STDBY_TIMER, PS_STDBY_TIME3, null_action);
    635          //   return(0);
    636          //}
    637          //
    638          //static uint8_t ps_start_stdby_tmr (void)
    639          //{
    640          //   TMR_Start_Timer(PS_STDBY_TIMER, PS_STDBY_TIME3, null_action);
    641          //   return(0);
    642          //}
    643          //
    644          //static uint8_t ps_restart_stdby_tmr (void)
    645          //{
    646          //   TMR_Start_Timer(PS_STDBY_TIMER, PS_STDBY_RETRY_TIME, null_action);
    647          //   if (!TMR_Is_Timer_Active(PS_STDBY_TIMEOUT_TIMER))
    648          //   {
    649          //      TMR_Start_Timer(PS_STDBY_TIMEOUT_TIMER, PS_STDBY_TIMEOUT_TIME, null_action);
    650          //   }
    651          //   return(0);
    652          //}
    653          //
    654          //static uint8_t ps_stop_obd_on_tmr (void)
    655          //{
    656          ////   TMR_Stop_Timer(PS_OBD_ON_TIMER);
    657          //   TMR_Stop_Timer(TELM_BATT_CHECK_DELAY_TIMER);
    658          //   TMR_Stop_Timer(TELM_BATT_CHECK_TIMER);
    659          //   return(0);
    660          //}
    661          //
    662          //static uint8_t ps_set_ign_on_to_awake (void)
    663          //{
    664          //   ps_put_user_on( false );
    665          //
    666          ////   TMR_Start_Timer(PS_STDBY_TIMER, PS_STDBY_TIME_FROM_ENG_ON, null_action);
    667          //
    668          //   TMR_Start_Timer(TELM_BATT_CHECK_DELAY_TIMER, PS_BATT_CHECK_DELAY_TIME, PS_Start_Batt_Check_Timer);
    669          //   return(0);
    670          //}
    671          
    672          /*********************************************************************/
    673          /* user public function                                     */
    674          /*********************************************************************/
    675          void PS_Start_Batt_Check_Timer (void)
    676          {
    677              if (Pwr_Fail_Is_Mute_Condition())
    678              {
    679                  TMR_Start_Timer(TELM_BATT_CHECK_TIMER, 30000, PS_Check_Batt_Before_Sleep);
    680              }
    681          }
    682          
    683          /**********************************************************************
    684          *
    685          *    Function: PS_Check_Batt_Before_Sleep
    686          *
    687          *  Parameters: None
    688          *
    689          *
    690          * Description: 
    691          *
    692          **********************************************************************/
    693          void PS_Check_Batt_Before_Sleep (void)
    694          {
    695             if (Pwr_Fail_Is_Mute_Condition())//workaround, send low battery message if power failed
    696             {
    697          //        OS_Send_Message(OS_IOT_TASK,Build_Message(TM_EVT_BATTERY_FAULT, 1));				
    698             }
    699          }
    700          
    701          /**********************************************************************
    702          *
    703          *    Function: PS_Send_Crash_Msg_On_Timer
    704          *
    705          *  Parameters: None
    706          *
    707          *
    708          * Description: 
    709          *
    710          **********************************************************************/
    711          void PS_Send_Crash_Msg_On_Timer (void)//workaround only
    712          {
    713             //if (false == PS_Logical_Ignition_On())//if ACC ON, discard this message
    714             if (!PS_Eng_On())//if Eng ON, discard this message
    715             {
    716          //        OS_Send_Message(OS_IOT_TASK,Build_Message(TM_EVT_CAR_CRASHED, 1) );				
    717             }
    718          }
    719          
    720          /**********************************************************************
    721          *
    722          *    Function: PS_Idle
    723          *
    724          *  Parameters: None
    725          *
    726          *     Returns: true  - if in RL is in idle state
    727          *              false - if not
    728          *
    729          * Description: Checks if RL is in idle state. This is used only from watchtmr.
    730          *
    731          **********************************************************************/
    732          bool PS_Idle(void)
    733          {
    734             return((RL_In_Idle())&&(!PS_Awake()));
    735          }
    736          
    737          /**********************************************************************
    738          *
    739          *    Function: PS_Awake
    740          *
    741          *  Parameters: None
    742          *
    743          *     Returns: true  - if PS is at least awake
    744          *              false - if not
    745          *
    746          * Description: Checks if system is awake.
    747          *
    748          **********************************************************************/
    749          bool PS_Awake(void)
    750          {
    751             return(!(PS_Get_Current_State() <= PS_IDLE) || ps_awake_requested());
    752          }
    753          
    754          /**********************************************************************
    755          *
    756          *    Function: PS_Play_On
    757          *
    758          *  Parameters: None
    759          *
    760          *     Returns: true  - if play is requested
    761          *              false - if play is not requested
    762          *
    763          * Description: Checks if play mode is requested.
    764          *
    765          **********************************************************************/
    766          //bool PS_Play_On(void)
    767          //{
    768          //   return((PS_Get_Current_State() == PS_USER_ON)
    769          //       || (PS_Get_Current_State() == PS_ENG_ON));
    770          //}
    771          
    772          ///**********************************************************************
    773          //*
    774          //*    Function: PS_User_On
    775          //*
    776          //*  Parameters: None
    777          //*
    778          //*     Returns: true  - if obd is switched on by user
    779          //*              false - if obd is not switched on by user
    780          //*
    781          //* Description: Checks if obd is switched on by user.
    782          //*
    783          //**********************************************************************/
    784          //bool PS_User_On(void)
    785          //{
    786          //   return(PS_Get_Current_State() == PS_USER_ON);
    787          //}
    788          
    789          /**********************************************************************
    790          *
    791          *    Function: PS_Eng_On
    792          *
    793          *  Parameters: None
    794          *
    795          *     Returns: None
    796          *
    797          * Description: 
    798          *
    799          *********************************************************************/
    800          bool PS_Eng_On(void)
    801          {
    802             return(PS_Get_Current_State() == PS_ENG_ON);
    803          }
    804          
    805          /**********************************************************************
    806          *
    807          *    Function: PS_Running
    808          *
    809          *  Parameters: None
    810          *
    811          *     Returns: true  - if in system is still running
    812          *              false - if not
    813          *
    814          * Description: Checks if system is still running
    815          *
    816          *********************************************************************/
    817          bool PS_Running(void)
    818          {
    819             //return(!(PS_Get_Current_State() == PS_IDLE) || ps_awake_requested());
    820             return(!(PS_Get_Current_State() == PS_IDLE));
    821          }
    822          
    823          /**********************************************************************
    824          *
    825          *    Function: PS_Full_System
    826          *
    827          *  Parameters: None
    828          *
    829          *     Returns: true  - if in PS_Full_System
    830          *              false - if not
    831          *
    832          * Description: Checks if PS_Full_System
    833          *
    834          **********************************************************************/
    835          bool PS_Full_System(void)
    836          {
    837             return(!(PS_Get_Current_State() == PS_IDLE)
    838                 && !(PS_Get_Current_State() == PS_AWAKE));
    839          }
    840          
    841          /**********************************************************************
    842          *
    843          *    Function: PS_Permanent_Sleep
    844          *
    845          *  Parameters: None
    846          *
    847          *     Returns: true  - if in permanent sleep mode
    848          *              false - if not
    849          *
    850          * Description: Checks if in permanent sleep mode
    851          *
    852          *********************************************************************/
    853          bool PS_Permanent_Sleep(void)
    854          {
    855             return(ps_permanent_sleep());
    856          }
    857          
    858          /**********************************************************************
    859          *
    860          *    Function: PS_Pending_Awake
    861          *
    862          *  Parameters: None
    863          *
    864          *     Returns: true  - if awake requested
    865          *              false - if awake not requested
    866          *
    867          * Description: Checks if awake is requested
    868          *
    869          **********************************************************************/
    870          bool PS_Pending_Awake(void)
    871          {
    872             bool wake_up = false;
    873             /*Fixme:reserved*/
    874             return(wake_up);
    875          }
    876          
    877          /**********************************************************************
    878          *
    879          *    Function: PS_Get_Idle_Time
    880          *
    881          *  Parameters: None
    882          *
    883          *     Returns: How long the obd should remain idle, given in absolute
    884          *              idle ticks (DO NOT ADD OS_Time() TO THIS RESULT);
    885          *              0 indicates forever)
    886          *
    887          * Description: Calculates how long the obd should stay in idle.
    888          *
    889          *********************************************************************/
    890          Tick_Type PS_Get_Idle_Time(void)
    891          {
    892             // calculate here the time and condition to stay idle:
    893             // if not permanent sleep e.g. 2h TIM readiness OR 2x 2h Timeframe
    894             // then come out of IDLE every 1.5 sec to check for TA
    895             // else stay in idle forever (= 0)
    896             /*CJ:reserved for future application,should be permanent sleep by now*/
    897             return(ps_permanent_sleep() ? 0 : (OS_Time() + PS_IDLE_TIME));
    898          }
    899          
    900          /**********************************************************************
    901          *
    902          *    Function: PS_Is_Idle_Requested
    903          *
    904          *  Parameters: None
    905          *
    906          *     Returns: true  - if idle requested
    907          *              false - if idle not requested
    908          *
    909          * Description: returns if idle is requested
    910          *
    911          **********************************************************************/
    912          bool PS_Is_Idle_Requested(void)
    913          {
    914             return(idle_is_requested);
    915          }
    916          
    917          /**********************************************************************
    918          *
    919          *    Function: PS_Is_RTC_Requested
    920          *
    921          *  Parameters: None
    922          *
    923          *     Returns: true  - if idle requested
    924          *              false - if idle not requested
    925          *
    926          * Description: returns if idle is requested
    927          *
    928          **********************************************************************/
    929          bool PS_Is_RTC_Requested(void)
    930          {
    931             return(!rtc_is_not_requested);
    932          }
    933          
    934          /**********************************************************************
    935          *
    936          *    Function: PS_Go_Idle
    937          *
    938          *  Parameters: rtc_config:if RTC periodically wake up is required
    939          *
    940          *     Returns: None
    941          *
    942          * Description: Forces a qucik (hard) transition to idle mode
    943          *
    944          *********************************************************************/
    945          void PS_Go_Idle(bool rtc_config)
    946          {
    947              idle_is_requested = true;
    948              rtc_is_not_requested = rtc_config;
    949              OS_Send_Message(OS_PSYNC_TASK, PS_EVT_GO_IDLE);
    950          }
    951          
    952          /**********************************************************************
    953           *
    954           *    Function: PS_Go_Awake
    955           *
    956           *  Parameters: awake_time_in_ms - ms value for time the obd should
    957           *              remain awake
    958           *
    959           *     Returns: None
    960           *
    961           * Description: This function requests a wake up of the obd for
    962           *              a specified period of time.
    963           *
    964           *********************************************************************/
    965          void PS_Go_Awake(Tick_Type awake_time_in_ms)
    966          {
    967              if (awake_time_in_ms > TMR_Get_Pending_Time(PS_MIN_AWAKE_TIMER))
    968              {
    969                  TMR_Start_Timer(PS_MIN_AWAKE_TIMER, awake_time_in_ms, null_action);
    970              }
    971          
    972              OS_Send_Message(OS_PSYNC_TASK, PS_EVT_AWAKE);
    973          }
    974          
    975          /**********************************************************************
    976          *
    977          *    Function: PS_Set_Ignition
    978          *
    979          *  Parameters: status 0=OFF, 1=ON
    980          *
    981          *     Returns: None
    982          *
    983          * Description: informs PSYNC about the ignition status, called by the
    984          *              CAN module
    985          *
    986          **********************************************************************/
    987          void PS_Set_Ignition(bool status)
    988          {
    989              Message_Type msg;
    990              if(status != PS_Logical_Ignition_On())  
    991              {
    992                  PS_Set_Logical_IGN_State(status);
    993                  msg = PS_Logical_Ignition_On() ? PS_EVT_IGN_ON : PS_EVT_IGN_OFF;
    994                  OS_Send_Message(OS_PSYNC_TASK, msg);
    995              }
    996          }
    997          /**********************************************************************
    998          *
    999          *    Function: PS_Set_Engine_On
   1000          *
   1001          *  Parameters: status 0=OFF, 1=ON
   1002          *
   1003          *     Returns: None
   1004          *
   1005          * Description: 
   1006          *
   1007          **********************************************************************/
   1008          void PS_Set_Engine_On(bool status)
   1009          {
   1010              Message_Type msg;
   1011              if(status != PS_Logical_Engine_On())  
   1012              {
   1013                  PS_Set_Logical_Eng_State(status);
   1014                  msg = PS_Logical_Engine_On() ? PS_EVT_ENG_ON : PS_EVT_ENG_OFF;
   1015                  OS_Send_Message(OS_PSYNC_TASK, msg);
   1016              }
   1017          }
   1018          
   1019          /**********************************************************************
   1020          *
   1021          *    Function: PS_Set_Obd_On
   1022          *
   1023          *  Parameters: status t/f
   1024          *
   1025          *     Returns: None
   1026          *
   1027          * Description: requests PS to switch Obd ON (behaviour like onoff key)
   1028          *
   1029          *********************************************************************/
   1030          void PS_Set_Obd_On(bool status)
   1031          {
   1032             OS_Send_Message(OS_PSYNC_TASK, status ? PS_EVT_OBD_ON : PS_EVT_OBD_OFF);
   1033          }
   1034          
   1035          /**********************************************************************
   1036          *
   1037          *    Function: PS_Set_ON_Minutes
   1038          *
   1039          *  Parameters: None
   1040          *
   1041          *     Returns: None
   1042          *
   1043          * Description: sets the ps_on_minutes
   1044          *
   1045          *********************************************************************/
   1046          void PS_Set_ON_Minutes(uint16_t minutes)
   1047          {
   1048             PS_Set_Obd_On_Minutes(minutes);
   1049          
   1050          //   if (TMR_Is_Timer_Active(PS_OBD_ON_TIMER))
   1051             {
   1052                //restart timer with new value
   1053          //      TMR_Start_Timer(PS_OBD_ON_TIMER, PS_OBD_ON_TIME, null_action);
   1054             }
   1055          }
   1056          /*===========================================================================*\
   1057           *
   1058           * Please refer to the detailed description in psync_ps.h.
   1059           *
   1060          \*===========================================================================*/
   1061          void PS_Set_Obd_On_Minutes(uint16_t minutes)
   1062          {
   1063             ps_cal_data.obd_on_minutes = minutes;
   1064          }
   1065          
   1066          /*===========================================================================*\
   1067           *
   1068           * Please refer to the detailed description in psync_ps.h.
   1069           *
   1070          \*===========================================================================*/
   1071          uint16_t PS_Get_Obd_On_Minutes(void)
   1072          {
   1073             return(ps_cal_data.obd_on_minutes);
   1074          }
   1075          /*===========================================================================*\
   1076           *
   1077           * Please refer to the detailed description in psync_ps.h.
   1078           *
   1079          \*===========================================================================*/
   1080          void PS_Set_ACC_On_Minutes(uint16_t minutes)
   1081          {
   1082             ps_cal_data.acc_on_minutes = minutes;
   1083          }
   1084          
   1085          /*===========================================================================*\
   1086           *
   1087           * Please refer to the detailed description in psync_ps.h.
   1088           *
   1089          \*===========================================================================*/
   1090          uint16_t PS_Get_ACC_On_Minutes(void)
   1091          {
   1092             return(ps_cal_data.acc_on_minutes);
   1093          }
   1094          
   1095          /*===========================================================================*\
   1096           *
   1097           * Please refer to the detailed description in psync_ps.h.
   1098           *
   1099          \*===========================================================================*/
   1100          void PS_Set_Event_On_Minutes(uint16_t minutes)
   1101          {
   1102             ps_cal_data.event_on_minutes = minutes;
   1103          }
   1104          
   1105          /*===========================================================================*\
   1106           *
   1107           * Please refer to the detailed description in psync_ps.h.
   1108           *
   1109          \*===========================================================================*/
   1110          uint16_t PS_Get_Event_On_Minutes(void)
   1111          {
   1112             return(ps_cal_data.event_on_minutes);
   1113          }
   1114          
   1115          /**********************************************************************
   1116          *
   1117          *    Function: PS_Set_Restart_ON_Timer
   1118          *
   1119          *  Parameters: None
   1120          *
   1121          *     Returns: None
   1122          *
   1123          * Description: starts timer without storing new value
   1124          *
   1125          *********************************************************************/
   1126          void PS_Restart_ON_Timer(uint16_t minutes)
   1127          {
   1128          //   if (TMR_Is_Timer_Active(PS_OBD_ON_TIMER))
   1129             {
   1130                //restart timer with new value
   1131          //      TMR_Start_Timer(PS_OBD_ON_TIMER, minutes * 60000, null_action);
   1132             }
   1133          }
   1134          
   1135          /**********************************************************************
   1136          *
   1137          *    Function: PS_Get_ON_Minutes
   1138          *
   1139          *  Parameters: None
   1140          *
   1141          *     Returns: None
   1142          *
   1143          * Description: returns ps_on_minutes
   1144          *
   1145          *********************************************************************/
   1146          uint16_t PS_Get_ON_Minutes(void)
   1147          {
   1148             return(PS_Get_Obd_On_Minutes());
   1149          }
   1150          
   1151          /**********************************************************************
   1152          *
   1153          *    Function: PS_Set_Idle
   1154          *
   1155          *  Parameters: None
   1156          *
   1157          *     Returns: None
   1158          *
   1159          * Description: Forces a hard idle transition
   1160          *
   1161          *********************************************************************/
   1162          void PS_Set_Idle(void)
   1163          {
   1164             PS_Set_Current_State(PS_IDLE);
   1165          }
   1166          
   1167          /**********************************************************************
   1168          *
   1169          *    Function: PS_Update
   1170          *
   1171          *  Parameters: None
   1172          *
   1173          *     Returns: None
   1174          *
   1175          * Description: forces a immediate run of PSYNC task
   1176          *
   1177          *********************************************************************/
   1178          //static void PS_Update(void)
   1179          //{
   1180          //   OS_Send_Message(OS_PSYNC_TASK, PS_EVT_UPDATE);
   1181          //}
   1182          
   1183          /*===========================================================================*\
   1184           *
   1185           * Please refer to the detailed description in psync.h.
   1186           *
   1187          \*===========================================================================*/
   1188          void PS_Set_Current_State(PS_Current_State_T state)
   1189          {
   1190             ps_data.current_state = state;
   1191          }
   1192          
   1193          /*===========================================================================*\
   1194           *
   1195           * Please refer to the detailed description in psync.h.
   1196           *
   1197          \*===========================================================================*/
   1198          PS_Current_State_T PS_Get_Current_State(void)
   1199          {
   1200             return(ps_data.current_state);
   1201          }
   1202          
   1203          /*===========================================================================*\
   1204           *
   1205           * Please refer to the detailed description in psync.h.
   1206           *
   1207          \*===========================================================================*/
   1208          void PS_Set_Last_State(PS_Current_State_T state)
   1209          {
   1210             ps_data.last_state = state;
   1211          }
   1212          
   1213          /*===========================================================================*\
   1214           *
   1215           * Please refer to the detailed description in psync.h.
   1216           *
   1217          \*===========================================================================*/
   1218          PS_Current_State_T PS_Get_Last_State(void)
   1219          {
   1220             return(ps_data.last_state);
   1221          }
   1222          
   1223          /*===========================================================================*\
   1224           *
   1225           * Please refer to the detailed description in psync.h.
   1226           *
   1227          \*===========================================================================*/
   1228          void PS_Set_Flag(PS_Flags_Enum_T flag, bool status)
   1229          {
   1230             if(true == status)
   1231             {
   1232                 Set_Bit(&ps_data.flags, flag);
   1233             }
   1234             else
   1235             {
   1236                 Clear_Bit(&ps_data.flags, flag);
   1237             }
   1238          }
   1239          
   1240          /*===========================================================================*\
   1241           *
   1242           * Please refer to the detailed description in psync_ps.h.
   1243           *
   1244          \*===========================================================================*/
   1245          bool PS_Get_Flag(PS_Flags_Enum_T flag)
   1246          {
   1247             return(Read_Bit(&ps_data.flags, flag));
   1248          }
   1249          
   1250          /**********************************************************************
   1251           * Description: 
   1252           *  Parameters: None
   1253           *     Returns: 
   1254           *********************************************************************/
   1255          bool PS_Logical_Engine_On(void)
   1256          {
   1257             return(ps_data.logical_engine);
   1258          }
   1259          
   1260          /**********************************************************************
   1261           * Description: Set logical engine state
   1262           *  Parameters: new state value
   1263           *     Returns: void
   1264           *********************************************************************/
   1265          static void PS_Set_Logical_Eng_State(bool state)
   1266          {
   1267             ps_data.logical_engine = state;
   1268          }
   1269          
   1270          /**********************************************************************
   1271           * Description: Accessor to determine whether logical ignition is on or not.
   1272           *  Parameters: None
   1273           *     Returns: whether or not the logical ignition is on
   1274           *********************************************************************/
   1275          bool PS_Logical_Ignition_On(void)
   1276          {
   1277             return(ps_data.logical_ignition);
   1278          }
   1279          /**********************************************************************
   1280           * Description: Set logical ignition state
   1281           *  Parameters: new state value
   1282           *     Returns: void
   1283           *********************************************************************/
   1284          static void PS_Set_Logical_IGN_State(bool state)
   1285          {
   1286             ps_data.logical_ignition = state;
   1287          }
   1288          
   1289          /**********************************************************************
   1290           *
   1291           * Revision History
   1292           *
   1293           *********************************************************************
   1294           *********************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   PS_Awake
         8   -> PS_Get_Current_State
         8   -> PS_Get_Flag
       8   PS_Check_Batt_Before_Sleep
         8   -> Pwr_Fail_Is_Mute_Condition
       8   PS_Eng_On
         8   -> PS_Get_Current_State
       8   PS_Full_System
         8   -> PS_Get_Current_State
       0   PS_Get_ACC_On_Minutes
       0   PS_Get_Current_State
       0   PS_Get_Event_On_Minutes
       8   PS_Get_Flag
         8   -> Read_Bit_Subr
       8   PS_Get_Idle_Time
         8   -> PS_Get_Flag
         8   -> xTaskGetTickCountFromISR
       0   PS_Get_Last_State
       8   PS_Get_ON_Minutes
         8   -> PS_Get_Obd_On_Minutes
       0   PS_Get_Obd_On_Minutes
       8   PS_Go_Awake
         8   -> OS_Send_Message
         8   -> TMR_Get_Pending_Time
         8   -> TMR_Start_Timer
       8   PS_Go_Idle
         8   -> OS_Send_Message
       8   PS_Idle
         8   -> PS_Awake
         8   -> RL_In_Idle
       8   PS_Initialize
         8   -> FSM_Process_Evt
         8   -> Get_Cold_Start
         8   -> PS_Set_Current_State
         8   -> PS_Set_Last_State
         8   -> Sys_Clear_Int_battery_Flag
       0   PS_Is_Idle_Requested
       0   PS_Is_RTC_Requested
       0   PS_Logical_Engine_On
       0   PS_Logical_Ignition_On
       0   PS_Pending_Awake
       8   PS_Permanent_Sleep
         8   -> PS_Get_Flag
       0   PS_Restart_ON_Timer
       8   PS_Running
         8   -> PS_Get_Current_State
       8   PS_Send_Crash_Msg_On_Timer
         8   -> PS_Eng_On
       0   PS_Set_ACC_On_Minutes
       0   PS_Set_Current_State
       8   PS_Set_Engine_On
         8   -> OS_Send_Message
         8   -> PS_Logical_Engine_On
         8   -> PS_Set_Logical_Eng_State
       0   PS_Set_Event_On_Minutes
       8   PS_Set_Flag
         8   -> Assign_Bit
       8   PS_Set_Idle
         8   -> PS_Set_Current_State
       8   PS_Set_Ignition
         8   -> OS_Send_Message
         8   -> PS_Logical_Ignition_On
         8   -> PS_Set_Logical_IGN_State
       0   PS_Set_Last_State
       0   PS_Set_Logical_Eng_State
       0   PS_Set_Logical_IGN_State
       8   PS_Set_ON_Minutes
         8   -> PS_Set_Obd_On_Minutes
       8   PS_Set_Obd_On
         8   -> OS_Send_Message
       0   PS_Set_Obd_On_Minutes
       8   PS_Start_Batt_Check_Timer
         8   -> Pwr_Fail_Is_Mute_Condition
         8   -> TMR_Start_Timer
      24   Psync_Task
        24   -> FSM_Process_CS
        24   -> FSM_Process_Evt
        24   -> OS_Receive_Message
        24   -> OS_Release_Resource
        24   -> OS_Wait_Message
        24   -> PS_Get_Current_State
        24   -> PS_Set_Current_State
        24   -> printf
       0   no_action
       8   ps_cs_awake
         8   -> ACC_Is_Volt_Checking
         8   -> OS_Send_Message
         8   -> PS_Set_Ignition
         8   -> Sys_Get_Int_battery_Flag
         8   -> TMR_Is_Timer_Active
         8   -> TMR_Is_Timer_Running
         8   -> rl_get_acc_status
       8   ps_cs_eng_on
         8   -> GPIO_WriteBit
         8   -> PS_Set_Ignition
         8   -> Pwr_Fail_Get_Int_Voltage
         8   -> Pwr_Fail_Get_Voltage
         8   -> Pwr_Is_Charge_Request
         8   -> Sys_Get_Int_battery_Flag
         8   -> TMR_Is_Timer_Active
         8   -> TMR_Is_Timer_Running
         8   -> TMR_Start_Timer
         8   -> printf
         8   -> rl_get_acc_status
       8   ps_cs_idle
         8   -> OS_Release_Resource
         8   -> OS_Send_Message
         8   -> PS_Get_Flag
       0   ps_cs_root
       8   ps_entry_awake
         8   -> MDG_In_Mode
         8   -> PS_Get_Last_State
         8   -> PS_Set_Last_State
         8   -> Sys_Get_Int_battery_Flag
         8   -> Sys_Is_RTC_Deep_Wakeup
         8   -> TMR_Get_Pending_Time
         8   -> TMR_Start_Timer
       8   ps_entry_eng_on
         8   -> PS_Set_Last_State
         8   -> Periodic_Clear_Low_Volt_Cnt
         8   -> TMR_Start_Timer
       8   ps_entry_idle
         8   -> PS_Set_Flag
         8   -> TMR_Stop_Timer
       8   ps_entry_root
         8   -> PS_Get_Last_State
       8   ps_exit_awake
         8   -> TMR_Stop_Timer
       8   ps_exit_eng_on
         8   -> GPIO_WriteBit
         8   -> TMR_Stop_Timer
         8   -> write_flash_last_pos
       8   ps_start_action
         8   -> PS_Set_Flag


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_10
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable25_5
       4  ??DataTable25_6
       4  ??DataTable25_7
       4  ??DataTable25_8
       4  ??DataTable25_9
      32  ?_0
      28  ?_1
      40  ?_2
      32  PS_AWAKE_
      30  PS_Awake
       8  PS_Check_Batt_Before_Sleep
      24  PS_ENG_ON_
      20  PS_Eng_On
      28  PS_Full_System
       6  PS_Get_ACC_On_Minutes
       6  PS_Get_Current_State
       6  PS_Get_Event_On_Minutes
      14  PS_Get_Flag
      26  PS_Get_Idle_Time
       6  PS_Get_Last_State
       8  PS_Get_ON_Minutes
       6  PS_Get_Obd_On_Minutes
      34  PS_Go_Awake
      22  PS_Go_Idle
       8  PS_IDLE_
      28  PS_Idle
      56  PS_Initialize
       6  PS_Is_Idle_Requested
      18  PS_Is_RTC_Requested
       6  PS_Logical_Engine_On
       6  PS_Logical_Ignition_On
       4  PS_Pending_Awake
      10  PS_Permanent_Sleep
      16  PS_ROOT_
       2  PS_Restart_ON_Timer
      20  PS_Running
       8  PS_Send_Crash_Msg_On_Timer
       6  PS_Set_ACC_On_Minutes
       6  PS_Set_Current_State
      40  PS_Set_Engine_On
       6  PS_Set_Event_On_Minutes
      46  PS_Set_Flag
      10  PS_Set_Idle
      40  PS_Set_Ignition
       6  PS_Set_Last_State
       6  PS_Set_Logical_Eng_State
       6  PS_Set_Logical_IGN_State
      10  PS_Set_ON_Minutes
      20  PS_Set_Obd_On
       6  PS_Set_Obd_On_Minutes
      26  PS_Start_Batt_Check_Timer
     120  Psync_Task
       1  can_wakeup_cnt
       4  idle_is_requested
       4  no_action
       8  ps_cal_data
      84  ps_cs_awake
     138  ps_cs_eng_on
      32  ps_cs_idle
       4  ps_cs_root
      12  ps_data
     132  ps_entry_awake
      30  ps_entry_eng_on
      20  ps_entry_idle
      18  ps_entry_root
      18  ps_exit_awake
      34  ps_exit_eng_on
      22  ps_start_action
       4  rtc_is_not_requested
      64  tree_psync

 
    20 bytes in section .bss
     8 bytes in section .data
     1 byte  in section .noinit
   244 bytes in section .rodata
 1 318 bytes in section .text
 
 1 318 bytes of CODE  memory
   244 bytes of CONST memory
    29 bytes of DATA  memory

Errors: none
Warnings: none
