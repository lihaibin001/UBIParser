###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.2.11947/W32 for ARM       15/Sep/2017  09:59:21
# Copyright 1999-2016 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\workspace\dr002\dr002_suming\v1_board\main_app\Sensors\bma2x2.c
#    Command line =  
#        D:\workspace\dr002\dr002_suming\v1_board\main_app\Sensors\bma2x2.c -D
#        VECT_TAB_FLASH -D IAR_ARM_CM3 -lcN
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\List
#        --diag_suppress Pa050 -o
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.5\arm\INC\c\DLib_Config_Full.h"
#        -I D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\.\ -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Diag_Factory\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\common\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\power\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\SysMan\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Protocol\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\include\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\FreeRTOS\include\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\FreeRTOS\portable\IAR\ARM_CM3\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\drivers\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Arch\stm32f1\Libraries\CMSIS\CM3\CoreSupport\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\GPS\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\GPRS\
#        -I
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\..\main_app\Sensors\
#        -Ol --use_c++_inline --require_prototypes
#    Locale       =  Chinese (Simplified)_People's Republic of China.936
#    List file    =  
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\List\bma2x2.lst
#    Object file  =  
#        D:\workspace\dr002\dr002_suming\v1_board\CORTEX_STM32F103_IAR\Debug\Obj\bma2x2.o
#
###############################################################################

D:\workspace\dr002\dr002_suming\v1_board\main_app\Sensors\bma2x2.c
      1          /*!
      2          ****************************************************************************
      3          * Copyright (C) 2015 - 2016 Bosch Sensortec GmbH
      4          *
      5          * bma2x2.c
      6          * Date: 2016/11/14
      7          * Revision: 2.0.7 $
      8          *
      9          * Usage: Sensor Driver for BMA2x2 sensor
     10          *
     11          ****************************************************************************
     12          * Disclaimer
     13          *
     14          * Common:
     15          * Bosch Sensortec products are developed for the consumer goods industry.
     16          * They may only be used within the parameters of the respective valid
     17          * product data sheet.  Bosch Sensortec products are provided with the
     18          * express understanding that there is no warranty of fitness for a
     19          * particular purpose.They are not fit for use in life-sustaining,
     20          * safety or security sensitive systems or any system or device
     21          * that may lead to bodily harm or property damage if the system
     22          * or device malfunctions. In addition,Bosch Sensortec products are
     23          * not fit for use in products which interact with motor vehicle systems.
     24          * The resale and or use of products are at the purchasers own risk and
     25          * his own responsibility. The examination of fitness for the intended use
     26          * is the sole responsibility of the Purchaser.
     27          *
     28          * The purchaser shall indemnify Bosch Sensortec from all third party
     29          * claims, including any claims for incidental, or consequential damages,
     30          * arising from any product use not covered by the parameters of
     31          * the respective valid product data sheet or not approved by
     32          * Bosch Sensortec and reimburse Bosch Sensortec for all costs in
     33          * connection with such claims.
     34          *
     35          * The purchaser must monitor the market for the purchased products,
     36          * particularly with regard to product safety and inform Bosch Sensortec
     37          * without delay of all security relevant incidents.
     38          *
     39          * Engineering Samples are marked with an asterisk (*) or (e).
     40          * Samples may vary from the valid technical specifications of the product
     41          * series. They are therefore not intended or fit for resale to third
     42          * parties or for use in end products. Their sole purpose is internal
     43          * client testing. The testing of an engineering sample may in no way
     44          * replace the testing of a product series. Bosch Sensortec assumes
     45          * no liability for the use of engineering samples.
     46          * By accepting the engineering samples, the Purchaser agrees to indemnify
     47          * Bosch Sensortec from all claims arising from the use of engineering
     48          * samples.
     49          *
     50          * Special:
     51          * This software module (hereinafter called "Software") and any information
     52          * on application-sheets (hereinafter called "Information") is provided
     53          * free of charge for the sole purpose to support your application work.
     54          * The Software and Information is subject to the following
     55          * terms and conditions:
     56          *
     57          * The Software is specifically designed for the exclusive use for
     58          * Bosch Sensortec products by personnel who have special experience
     59          * and training. Do not use this Software if you do not have the
     60          * proper experience or training.
     61          *
     62          * This Software package is provided `` as is `` and without any expressed
     63          * or implied warranties,including without limitation, the implied warranties
     64          * of merchantability and fitness for a particular purpose.
     65          *
     66          * Bosch Sensortec and their representatives and agents deny any liability
     67          * for the functional impairment
     68          * of this Software in terms of fitness, performance and safety.
     69          * Bosch Sensortec and their representatives and agents shall not be liable
     70          * for any direct or indirect damages or injury, except as
     71          * otherwise stipulated in mandatory applicable law.
     72          *
     73          * The Information provided is believed to be accurate and reliable.
     74          * Bosch Sensortec assumes no responsibility for the consequences of use
     75          * of such Information nor for any infringement of patents or
     76          * other rights of third parties which may result from its use.
     77          * No license is granted by implication or otherwise under any patent or
     78          * patent rights of Bosch. Specifications mentioned in the Information are
     79          * subject to change without notice.
     80          **************************************************************************/
     81          /*! file <BMA2x2 >
     82          brief <Sensor driver for BMA2x2> */
     83          
     84          #include "stm32f10x.h"
     85          #include "bma2x2.h"
     86          /*! user defined code to be added here ... */
     87          static struct bma2x2_t *p_bma2x2;
     88          /*! Based on Bit resolution value_u8 should be modified */
     89          u8 V_BMA2x2RESOLUTION_U8 = BMA2x2_14_RESOLUTION;
     90          
     91          /****************************************************************************/
     92          /*!	Static Function Declarations
     93          *****************************************************************************/
     94          /*!
     95          *  @brief This API computes the number of bytes of accel FIFO data
     96          *  which is to be parsed.
     97          *
     98          *  @param[out] data_index       : The start index for parsing data
     99          *  @param[out] data_read_length : No of bytes to be parsed from FIFO buffer
    100          *  @param[in] accel_frame_count : Number of accelerometer frames to be read
    101          *  @param[in] fifo_data_select  : Denoting enabled axes data stored in FIFO
    102          *  @param[in] fifo_conf         : FIFO configuration structure
    103          *
    104          */
    105          static void get_accel_len_to_parse(u8 *data_index, u8 *data_read_length,
    106                                             u8 accel_frame_count, u8 fifo_data_select,
    107                                             struct fifo_configuration *fifo_conf);
    108          
    109          /*!
    110          *  @brief This API is used to parse the accelerometer frame from the
    111          *  user defined FIFO data buffer mapped to the structure fifo_conf and store
    112          *  it in the union fifo_frame
    113          *
    114          *  @note It update the data_index value which is used to store the index of
    115          *  the current data byte which is parsed.
    116          *
    117          *  @note The parsed accel frames stored in the union fifo_conf contains data
    118          *  in accordance with the enabled data axes to be stored in FIFO
    119          *  (XYZ axes or individual axis)
    120          *
    121          *  @param[in,out] accel_frame  : Instance of union fifo_frame
    122          *  @param[in,out] data_index   : Index value of noumber of bytes parsed
    123          *  @param[in,out] accel_index  : Index value of accelerometer frame parsed
    124          *  @param[in] fifo_data_select : Denoting enabled axes data stored in FIFO
    125          *  @param[in] fifo_conf        : FIFO configuration structure
    126          *
    127          */
    128          static void unpack_accel_frame(union fifo_frame *accel_frame, u8 *data_index,
    129                                         u8 *accel_index, u8 fifo_data_select,
    130                                         struct fifo_configuration *fifo_conf);
    131          
    132          /*!
    133          *  @brief This API is used to parse the accelerometer data and
    134          *  store it in the union fifo_frame
    135          *  It also updates the data_index value which stores the index of
    136          *  the current data byte which is parsed
    137          *
    138          *  @param[in,out] accel_frame  : Instance of union fifo_frame
    139          *  @param[in,out] data_index   : Index value of noumber of bytes parsed
    140          *  @param[in] fifo_conf        : FIFO configuration structure
    141          *
    142          */
    143          static void unpack_accel_xyz(union fifo_frame *accel_frame, u8 *data_index,
    144                                       struct fifo_configuration *fifo_conf);
    145          /*!
    146          * @brief
    147          *	This API reads the data from
    148          *	the given register continuously
    149          *
    150          *
    151          *	@param addr_u8 -> Address of the register
    152          *	@param data_u8 -> The data from the register
    153          *	@param len_u32 -> no of bytes to read
    154          *
    155          *
    156          *	@return results of bus communication function
    157          *	@retval 0 -> Success
    158          *	@retval -1 -> Error
    159          *
    160          *
    161          */
    162          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_burst_read(u8 addr_u8,
    163                                                        u8 *data_u8, u32 len_u32)
    164          {
    165          	/* Variable used to return value of
    166          	communication routine*/
    167          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    168              
    169          	if (p_bma2x2 == BMA2x2_NULL) {
    170          		/* Check the struct p_bma2x2 is empty */
    171          		return E_BMA2x2_NULL_PTR;
    172              } else {
    173                  /* Read the data from the register*/
    174                  com_rslt = p_bma2x2->BMA2x2_BURST_READ_FUNC
    175          			(p_bma2x2->dev_addr, addr_u8, data_u8, len_u32);
    176              }
    177          	return com_rslt;
    178          }
    179          /*!
    180          *	@brief
    181          *	This function is used for initialize
    182          *	bus read and bus write functions
    183          *	assign the chip id and device address
    184          *	chip id is read in the register 0x00 bit from 0 to 7
    185          *
    186          *	@param bma2x2 : structure pointer
    187          *
    188          *	@return results of bus communication function
    189          *	@retval 0 -> Success
    190          *	@retval -1 -> Error
    191          *
    192          *	@note
    193          *	While changing the parameter of the bma2x2_t
    194          *	consider the following point:
    195          *	Changing the reference value of the parameter
    196          *	will changes the local copy or local reference
    197          *	make sure your changes will not
    198          *	affect the reference value of the parameter
    199          *	(Better case don't change the reference value of the parameter)
    200          *
    201          */
    202          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_init(struct bma2x2_t *bma2x2)
    203          {
    204          	/*  Variable used to return value of
    205          	communication routine*/
    206          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    207          	u8 data_u8 = BMA2x2_INIT_VALUE;
    208          	u8 config_data_u8 = BMA2x2_INIT_VALUE;
    209          	/* assign bma2x2 ptr */
    210          	p_bma2x2 = bma2x2;
    211          	if (p_bma2x2 == BMA2x2_NULL) {
    212          		/* Check the struct p_bma2x2 is empty */
    213          		com_rslt = E_BMA2x2_NULL_PTR;
    214          	} else {
    215          		/* read Chip Id */
    216          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    217                      (p_bma2x2->dev_addr,
    218                       BMA2x2_CHIP_ID_REG, &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
    219          		p_bma2x2->chip_id = data_u8;    /* get bit slice */
    220          		/* read the fifo config register and update
    221          		the value to the fifo_config*/
    222          		com_rslt += bma2x2_read_reg(BMA2x2_FIFO_MODE_REG,
    223                                              &config_data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
    224          		p_bma2x2->fifo_config = config_data_u8;
    225          	}
    226          	return com_rslt;
    227          }
    228          /*!
    229          * @brief
    230          *	This API gives data to the given register and
    231          *	the data is written in the corresponding register address
    232          *
    233          *
    234          *	@param adr_u8  -> Address of the register
    235          *	@param data_u8 -> The data to the register
    236          *	@param len_u8 -> no of bytes to read
    237          *
    238          *
    239          *
    240          *	@return results of bus communication function
    241          *	@retval 0 -> Success
    242          *	@retval -1 -> Error
    243          *
    244          *
    245          */
    246          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_write_reg(u8 adr_u8,
    247                                                       u8 *data_u8, u8 len_u8)
    248          {
    249          	/*  Variable used to return value of
    250          	communication routine*/
    251          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    252              
    253          	if (p_bma2x2 == BMA2x2_NULL) {
    254          		/* Check the struct p_bma2x2 is empty */
    255          		return E_BMA2x2_NULL_PTR;
    256              } else {
    257          		/* Write the data to the register*/
    258          		com_rslt = p_bma2x2->BMA2x2_BUS_WRITE_FUNC
    259                      (p_bma2x2->dev_addr, adr_u8, data_u8, len_u8);
    260                  
    261          		if (p_bma2x2->power_mode_u8 != BMA2x2_MODE_NORMAL) {
    262          			/*A minimum interface idle time delay
    263          			of atleast 450us is required as per the data sheet.*/
    264          			p_bma2x2->delay_msec(BMA2x2_INTERFACE_IDLE_TIME_DELAY);
    265          		}
    266          	}
    267          	return com_rslt;
    268          }
    269          /*!
    270          * @brief This API reads the data from
    271          *           the given register address
    272          *
    273          *
    274          *	@param adr_u8 -> Address of the register
    275          *	@param data_u8 -> The data from the register
    276          *	@param len_u8 -> no of bytes to read
    277          *
    278          *
    279          *
    280          *	@return results of bus communication function
    281          *	@retval 0 -> Success
    282          *	@retval -1 -> Error
    283          *
    284          *
    285          */
    286          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_reg(u8 adr_u8,
    287                                                      u8 *data_u8, u8 len_u8)
    288          {
    289          	/*  Variable used to return value of
    290          	communication routine*/
    291          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    292              
    293          	if (p_bma2x2 == BMA2x2_NULL) {
    294          		/* Check the struct p_bma2x2 is empty */
    295          		return E_BMA2x2_NULL_PTR;
    296              } else {
    297                  /*Read the data from the register*/
    298                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    299          			(p_bma2x2->dev_addr, adr_u8, data_u8, len_u8);
    300              }
    301          	return com_rslt;
    302          }
    303          /*!
    304          * @brief
    305          *	This API reads acceleration data X values
    306          *	from location 02h and 03h
    307          *
    308          *
    309          *  @param   accel_x_s16 : pointer holding the data of accel X
    310          *		       value       |   resolution
    311          *       ----------------- | --------------
    312          *              0          | BMA2x2_12_RESOLUTION
    313          *              1          | BMA2x2_10_RESOLUTION
    314          *              2          | BMA2x2_14_RESOLUTION
    315          *
    316          *
    317          *	@return results of bus communication function
    318          *	@retval 0 -> Success
    319          *	@retval -1 -> Error
    320          *
    321          *
    322          */
    323          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_x(s16 *accel_x_s16)
    324          {
    325          	/*  Variable used to return value of
    326          	communication routine*/
    327          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    328          	/* Array holding the accel x value
    329          	data_u8[0] - x->LSB
    330          	data_u8[1] - x->MSB
    331          	*/
    332          	u8	data_u8[BMA2x2_ACCEL_DATA_SIZE] = {
    333                  BMA2x2_INIT_VALUE, BMA2x2_INIT_VALUE};
    334          	if (p_bma2x2 == BMA2x2_NULL) {
    335          		/* Check the struct p_bma2x2 is empty */
    336          		return E_BMA2x2_NULL_PTR;
    337              } else {
    338          		switch (V_BMA2x2RESOLUTION_U8) {
    339                      /* This case used for the resolution bit 12*/
    340                    case BMA2x2_12_RESOLUTION:
    341          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    342                          (p_bma2x2->dev_addr,
    343                           BMA2x2_ACCEL_X12_LSB_REG, data_u8,
    344                           BMA2x2_LSB_MSB_READ_LENGTH);
    345          			*accel_x_s16 = (s16)((((s32)((s8)
    346                                                   data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    347                                            << BMA2x2_SHIFT_EIGHT_BITS) |
    348                                           (data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB] &
    349                                            BMA2x2_RESOLUTION_12_MASK));
    350          			*accel_x_s16 = *accel_x_s16 >>
    351                          BMA2x2_SHIFT_FOUR_BITS;
    352                      break;
    353                      /* This case used for the resolution bit 10*/
    354                    case BMA2x2_10_RESOLUTION:
    355          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    356                          (p_bma2x2->dev_addr,
    357                           BMA2x2_ACCEL_X10_LSB_REG, data_u8,
    358                           BMA2x2_LSB_MSB_READ_LENGTH);
    359          			*accel_x_s16 = (s16)((((s32)((s8)
    360                                                   data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    361                                            << BMA2x2_SHIFT_EIGHT_BITS) |
    362                                           (data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB] &
    363                                            BMA2x2_RESOLUTION_10_MASK));
    364          			*accel_x_s16 = *accel_x_s16 >>
    365                          BMA2x2_SHIFT_SIX_BITS;
    366                      break;
    367                      /* This case used for the resolution bit 14*/
    368                    case BMA2x2_14_RESOLUTION:
    369          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    370                          (p_bma2x2->dev_addr,
    371                           BMA2x2_ACCEL_X14_LSB_REG, data_u8,
    372                           BMA2x2_LSB_MSB_READ_LENGTH);
    373          			*accel_x_s16 = (s16)((((s32)((s8)
    374                                                   data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    375                                            << BMA2x2_SHIFT_EIGHT_BITS) |
    376                                           (data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB] &
    377                                            BMA2x2_RESOLUTION_14_MASK));
    378          			*accel_x_s16 = *accel_x_s16 >>
    379                          BMA2x2_SHIFT_TWO_BITS;
    380                      break;
    381                    default:
    382                      break;
    383          		}
    384          	}
    385          	return com_rslt;
    386          }
    387          /*!
    388          * @brief
    389          *	This API reads acceleration data X values
    390          *	from location 02h and 03h bit resolution support 8bit
    391          *
    392          *
    393          *  @param   accel_x_s8 : pointer holding the data of accel X
    394          *
    395          *
    396          *
    397          *	@return results of bus communication function
    398          *	@retval 0 -> Success
    399          *	@retval -1 -> Error
    400          *
    401          *
    402          */
    403          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_eight_resolution_x(
    404                                                                           s8 *accel_x_s8)
    405          {
    406          	/*  Variable used to return value of
    407          	communication routine*/
    408          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    409          	u8	data = BMA2x2_INIT_VALUE;
    410              
    411          	if (p_bma2x2 == BMA2x2_NULL) {
    412          		/* Check the struct p_bma2x2 is empty */
    413          		return E_BMA2x2_NULL_PTR;
    414              } else {
    415                  /* Read the sensor X data*/
    416                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    417          			(p_bma2x2->dev_addr,
    418                       BMA2x2_X_AXIS_MSB_ADDR, &data,
    419                       BMA2x2_GEN_READ_WRITE_LENGTH);
    420                  *accel_x_s8 = BMA2x2_GET_BITSLICE(data,
    421                                                    BMA2x2_ACCEL_X_MSB);
    422              }
    423          	return com_rslt;
    424          }
    425          /*!
    426          * @brief
    427          *	This API reads acceleration data Y values
    428          *	from location 04h and 05h
    429          *
    430          *  @param   accel_y_s16 : pointer holding the data of accel Y
    431          *		       value       |   resolution
    432          *       ----------------- | --------------
    433          *              0          | BMA2x2_12_RESOLUTION
    434          *              1          | BMA2x2_10_RESOLUTION
    435          *              2          | BMA2x2_14_RESOLUTION
    436          *
    437          *
    438          *	@return results of bus communication function
    439          *	@retval 0 -> Success
    440          *	@retval -1 -> Error
    441          *
    442          *
    443          */
    444          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_y(s16 *accel_y_s16)
    445          {
    446          	/*  Variable used to return value of
    447          	communication routine*/
    448          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    449          	/* Array holding the accel y value
    450          	data_u8[0] - y->LSB
    451          	data_u8[1] - y->MSB
    452          	*/
    453          	u8 data_u8[BMA2x2_ACCEL_DATA_SIZE] = {BMA2x2_INIT_VALUE,
    454          	BMA2x2_INIT_VALUE};
    455              
    456          	if (p_bma2x2 == BMA2x2_NULL) {
    457          		/* Check the struct p_bma2x2 is empty */
    458          		return E_BMA2x2_NULL_PTR;
    459              } else {
    460          		switch (V_BMA2x2RESOLUTION_U8) {
    461                      /* This case used for the resolution bit 12*/
    462                    case BMA2x2_12_RESOLUTION:
    463          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    464                          (p_bma2x2->dev_addr,
    465                           BMA2x2_ACCEL_Y12_LSB_REG, data_u8,
    466                           BMA2x2_LSB_MSB_READ_LENGTH);
    467          			*accel_y_s16 = (s16)((((s32)((s8)
    468                                                   data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    469                                            << BMA2x2_SHIFT_EIGHT_BITS) |
    470                                           (data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB] &
    471                                            BMA2x2_12_BIT_SHIFT));
    472          			*accel_y_s16 = *accel_y_s16 >>
    473                          BMA2x2_SHIFT_FOUR_BITS;
    474                      break;
    475                      /* This case used for the resolution bit 10*/
    476                    case BMA2x2_10_RESOLUTION:
    477          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    478                          (p_bma2x2->dev_addr,
    479                           BMA2x2_ACCEL_Y10_LSB_REG, data_u8,
    480                           BMA2x2_LSB_MSB_READ_LENGTH);
    481          			*accel_y_s16 = (s16)((((s32)((s8)
    482                                                   data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    483                                            << BMA2x2_SHIFT_EIGHT_BITS) |
    484                                           (data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB] &
    485                                            BMA2x2_10_BIT_SHIFT));
    486          			*accel_y_s16 = *accel_y_s16 >>
    487                          BMA2x2_SHIFT_SIX_BITS;
    488                      break;
    489                      /* This case used for the resolution bit 14*/
    490                    case BMA2x2_14_RESOLUTION:
    491          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    492                          (p_bma2x2->dev_addr,
    493                           BMA2x2_ACCEL_Y14_LSB_REG, data_u8,
    494                           BMA2x2_LSB_MSB_READ_LENGTH);
    495          			*accel_y_s16 = (s16)((((s32)((s8)
    496                                                   data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    497                                            << BMA2x2_SHIFT_EIGHT_BITS) |
    498                                           (data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB] &
    499                                            BMA2x2_14_BIT_SHIFT));
    500          			*accel_y_s16 = *accel_y_s16 >>
    501                          BMA2x2_SHIFT_TWO_BITS;
    502                      break;
    503                    default:
    504                      break;
    505          		}
    506          	}
    507          	return com_rslt;
    508          }
    509          /*!
    510          * @brief This API reads acceleration data Y values of
    511          * 8bit  resolution  from location 05h
    512          *
    513          *
    514          *
    515          *
    516          *  @param accel_y_s8   The data of y
    517          *
    518          *
    519          *
    520          *	@return results of bus communication function
    521          *	@retval 0 -> Success
    522          *	@retval -1 -> Error
    523          *
    524          *
    525          */
    526          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_eight_resolution_y(
    527                                                                           s8 *accel_y_s8)
    528          {
    529              /*  Variable used to return value of
    530          	communication routine*/
    531          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    532          	u8	data = BMA2x2_INIT_VALUE;
    533              
    534          	if (p_bma2x2 == BMA2x2_NULL) {
    535          		/* Check the struct p_bma2x2 is empty */
    536          		return E_BMA2x2_NULL_PTR;
    537              } else {
    538                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    539          			(p_bma2x2->dev_addr,
    540                       BMA2x2_Y_AXIS_MSB_ADDR, &data,
    541                       BMA2x2_GEN_READ_WRITE_LENGTH);
    542                  *accel_y_s8 = BMA2x2_GET_BITSLICE(data,
    543                                                    BMA2x2_ACCEL_Y_MSB);
    544              }
    545          	return com_rslt;
    546          }
    547          /*!
    548          * @brief This API reads acceleration data Z values
    549          *                          from location 06h and 07h
    550          *
    551          *
    552          *  @param   accel_z_s16 : pointer holding the data of accel Z
    553          *		       value       |   resolution
    554          *       ----------------- | --------------
    555          *              0          | BMA2x2_12_RESOLUTION
    556          *              1          | BMA2x2_10_RESOLUTION
    557          *              2          | BMA2x2_14_RESOLUTION
    558          *
    559          *
    560          *	@return results of bus communication function
    561          *	@retval 0 -> Success
    562          *	@retval -1 -> Error
    563          *
    564          *
    565          */
    566          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_z(s16 *accel_z_s16)
    567          {
    568          	/*  Variable used to return value of
    569          	communication routine*/
    570          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    571          	/* Array holding the accel z value
    572          	data_u8[0] - z->LSB
    573          	data_u8[1] - z->MSB
    574          	*/
    575          	u8 data_u8[BMA2x2_ACCEL_DATA_SIZE] = {BMA2x2_INIT_VALUE,
    576          	BMA2x2_INIT_VALUE};
    577              
    578          	if (p_bma2x2 == BMA2x2_NULL) {
    579          		/* Check the struct p_bma2x2 is empty */
    580          		return E_BMA2x2_NULL_PTR;
    581              } else {
    582          		switch (V_BMA2x2RESOLUTION_U8) {
    583                    case BMA2x2_12_RESOLUTION:
    584          			/* This case used for the resolution bit 12*/
    585          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    586                          (p_bma2x2->dev_addr,
    587                           BMA2x2_ACCEL_Z12_LSB_REG, data_u8,
    588                           BMA2x2_LSB_MSB_READ_LENGTH);
    589          			*accel_z_s16 = (s16)((((s32)((s8)
    590                                                   data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    591                                            << BMA2x2_SHIFT_EIGHT_BITS) |
    592                                           (data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB]
    593                                            & BMA2x2_12_BIT_SHIFT));
    594          			*accel_z_s16 = *accel_z_s16 >>
    595                          BMA2x2_SHIFT_FOUR_BITS;
    596                      break;
    597                      /* This case used for the resolution bit 10*/
    598                    case BMA2x2_10_RESOLUTION:
    599          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    600                          (p_bma2x2->dev_addr,
    601                           BMA2x2_ACCEL_Z10_LSB_REG, data_u8,
    602                           BMA2x2_LSB_MSB_READ_LENGTH);
    603          			*accel_z_s16 = (s16)((((s32)((s8)
    604                                                   data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    605                                            << BMA2x2_SHIFT_EIGHT_BITS) |
    606                                           (data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB]
    607                                            & BMA2x2_10_BIT_SHIFT));
    608          			*accel_z_s16 = *accel_z_s16 >>
    609                          BMA2x2_SHIFT_SIX_BITS;
    610                      break;
    611                      /* This case used for the resolution bit 14*/
    612                    case BMA2x2_14_RESOLUTION:
    613          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    614                          (p_bma2x2->dev_addr,
    615                           BMA2x2_ACCEL_Z14_LSB_REG, data_u8,
    616                           BMA2x2_LSB_MSB_READ_LENGTH);
    617          			*accel_z_s16 = (s16)((((s32)((s8)
    618                                                   data_u8[BMA2x2_SENSOR_DATA_ACCEL_MSB]))
    619                                            << BMA2x2_SHIFT_EIGHT_BITS) |
    620                                           (data_u8[BMA2x2_SENSOR_DATA_ACCEL_LSB]
    621                                            & BMA2x2_14_BIT_SHIFT));
    622          			*accel_z_s16 = *accel_z_s16 >>
    623                          BMA2x2_SHIFT_TWO_BITS;
    624                      break;
    625                    default:
    626                      break;
    627          		}
    628          	}
    629          	return com_rslt;
    630          }
    631          /*!
    632          * @brief
    633          *	This API reads acceleration data Z values of
    634          *	8bit  resolution  from location 07h
    635          *
    636          *
    637          *
    638          *
    639          *  \@aram  accel_z_s8 : the data of z
    640          *
    641          *
    642          *	@return results of bus communication function
    643          *	@retval 0 -> Success
    644          *	@retval -1 -> Error
    645          *
    646          *
    647          */
    648          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_eight_resolution_z(
    649                                                                           s8 *accel_z_s8)
    650          {
    651              /*  Variable used to return value of
    652          	communication routine*/
    653          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    654          	u8	data = BMA2x2_INIT_VALUE;
    655              
    656          	if (p_bma2x2 == BMA2x2_NULL) {
    657          		/* Check the struct p_bma2x2 is empty */
    658          		return E_BMA2x2_NULL_PTR;
    659              } else {
    660                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    661          			(p_bma2x2->dev_addr,
    662                       BMA2x2_Z_AXIS_MSB_ADDR, &data,
    663                       BMA2x2_GEN_READ_WRITE_LENGTH);
    664                  *accel_z_s8 = BMA2x2_GET_BITSLICE(data,
    665                                                    BMA2x2_ACCEL_Z_MSB);
    666              }
    667          	return com_rslt;
    668          }
    669          /*!
    670          *	@brief This API reads acceleration data X,Y,Z values
    671          *	from location 02h to 07h
    672          *
    673          *  @param accel : pointer holding the data of accel
    674          *		       value       |   resolution
    675          *       ----------------- | --------------
    676          *              0          | BMA2x2_12_RESOLUTION
    677          *              1          | BMA2x2_10_RESOLUTION
    678          *              2          | BMA2x2_14_RESOLUTION
    679          *
    680          *	@return results of bus communication function
    681          *	@retval 0 -> Success
    682          *	@retval -1 -> Error
    683          *
    684          *
    685          */
    686          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_xyz(
    687                                                            struct bma2x2_accel_data *accel)
    688          {
    689          	/*  Variable used to return value of
    690          	communication routine*/
    691          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    692          	/* Array holding the accel xyz value
    693          	data_u8[0] - x->LSB
    694          	data_u8[1] - x->MSB
    695          	data_u8[2] - y->MSB
    696          	data_u8[3] - y->MSB
    697          	data_u8[4] - z->MSB
    698          	data_u8[5] - z->MSB
    699          	*/
    700          	u8 data_u8[BMA2x2_ACCEL_XYZ_DATA_SIZE] = {
    701                  BMA2x2_INIT_VALUE, BMA2x2_INIT_VALUE,
    702                  BMA2x2_INIT_VALUE, BMA2x2_INIT_VALUE,
    703                  BMA2x2_INIT_VALUE, BMA2x2_INIT_VALUE};
    704              
    705          	if (p_bma2x2 == BMA2x2_NULL) {
    706          		/* Check the struct p_bma2x2 is empty */
    707          		return E_BMA2x2_NULL_PTR;
    708              } else {
    709          		switch (V_BMA2x2RESOLUTION_U8) {
    710                      /* This case used for the resolution bit 12*/
    711                    case BMA2x2_12_RESOLUTION:
    712          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    713                          (p_bma2x2->dev_addr, BMA2x2_ACCEL_X12_LSB_REG,
    714                           data_u8, BMA2x2_SHIFT_SIX_BITS);
    715          			/* read the x data_u8*/
    716          			accel->x = (s16)((((s32)((s8)
    717                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_X_MSB]))
    718                                        << BMA2x2_SHIFT_EIGHT_BITS) |
    719                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_X_LSB] &
    720                                        BMA2x2_12_BIT_SHIFT));
    721          			accel->x = accel->x >> BMA2x2_SHIFT_FOUR_BITS;
    722                      
    723          			/* read the y data_u8*/
    724          			accel->y = (s16)((((s32)((s8)
    725                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_MSB]))
    726                                        << BMA2x2_SHIFT_EIGHT_BITS) |
    727                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_LSB] &
    728                                        BMA2x2_12_BIT_SHIFT));
    729          			accel->y = accel->y >> BMA2x2_SHIFT_FOUR_BITS;
    730                      
    731          			/* read the z data_u8*/
    732          			accel->z = (s16)((((s32)((s8)
    733                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_MSB]))
    734                                        << BMA2x2_SHIFT_EIGHT_BITS) |
    735                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_LSB] &
    736                                        BMA2x2_12_BIT_SHIFT));
    737          			accel->z = accel->z >> BMA2x2_SHIFT_FOUR_BITS;
    738                      
    739                      break;
    740                    case BMA2x2_10_RESOLUTION:
    741                      /* This case used for the resolution bit 10*/
    742          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    743                          (p_bma2x2->dev_addr, BMA2x2_ACCEL_X10_LSB_REG,
    744                           data_u8, BMA2x2_SHIFT_SIX_BITS);
    745          			/* read the x data_u8*/
    746          			accel->x = (s16)((((s32)((s8)
    747                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_X_MSB]))
    748                                        << BMA2x2_SHIFT_EIGHT_BITS) |
    749                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_X_LSB] &
    750                                        BMA2x2_10_BIT_SHIFT));
    751          			accel->x = accel->x >> BMA2x2_SHIFT_SIX_BITS;
    752                      
    753          			/* read the y data_u8*/
    754          			accel->y = (s16)((((s32)((s8)
    755                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_MSB]))
    756                                        << BMA2x2_SHIFT_EIGHT_BITS) |
    757                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_LSB] &
    758                                        BMA2x2_10_BIT_SHIFT));
    759          			accel->y = accel->y >> BMA2x2_SHIFT_SIX_BITS;
    760                      
    761          			/* read the z data_u8*/
    762          			accel->z = (s16)((((s32)((s8)
    763                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_MSB]))
    764                                        << BMA2x2_SHIFT_EIGHT_BITS) |
    765                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_LSB]
    766                                        & BMA2x2_10_BIT_SHIFT));
    767          			accel->z = accel->z >> BMA2x2_SHIFT_SIX_BITS;
    768                      break;
    769                      /* This case used for the resolution bit 14*/
    770                    case BMA2x2_14_RESOLUTION:
    771          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    772                          (p_bma2x2->dev_addr, BMA2x2_ACCEL_X14_LSB_REG,
    773                           data_u8, BMA2x2_SHIFT_SIX_BITS);
    774                      
    775          			/* read the x data_u8*/
    776          			accel->x = (s16)((((s32)((s8)
    777                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_X_MSB]))<<
    778                                        BMA2x2_SHIFT_EIGHT_BITS) |
    779                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_X_LSB]
    780                                        & BMA2x2_14_BIT_SHIFT));
    781          			accel->x = accel->x >> BMA2x2_SHIFT_TWO_BITS;
    782                      
    783          			/* read the y data_u8*/
    784          			accel->y = (s16)((((s32)((s8)
    785                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_MSB]))<<
    786                                        BMA2x2_SHIFT_EIGHT_BITS) |
    787                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_LSB]
    788                                        & BMA2x2_14_BIT_SHIFT));
    789          			accel->y = accel->y >> BMA2x2_SHIFT_TWO_BITS;
    790                      
    791          			/* read the z data_u8*/
    792          			accel->z = (s16)((((s32)((s8)
    793                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_MSB]))<<
    794                                        BMA2x2_SHIFT_EIGHT_BITS) |
    795                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_LSB]
    796                                        & BMA2x2_14_BIT_SHIFT));
    797          			accel->z = accel->z >> BMA2x2_SHIFT_TWO_BITS;
    798                      break;
    799                    default:
    800                      break;
    801          		}
    802          	}
    803          	return com_rslt;
    804          }
    805          /*!
    806          * @brief This API reads acceleration of 8 bit resolution
    807          * data of X,Y,Z values
    808          * from location 03h , 05h and 07h
    809          *
    810          *
    811          *
    812          *
    813          *  @param accel : pointer holding the data of accel
    814          *
    815          *
    816          *
    817          *	@return results of bus communication function
    818          *	@retval 0 -> Success
    819          *	@retval -1 -> Error
    820          *
    821          *
    822          */
    823          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_eight_resolution_xyz(
    824                                                                             struct bma2x2_accel_eight_resolution *accel)
    825          {
    826          	/*  Variable used to return value of
    827          	communication routine*/
    828          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    829          	u8	data_u8 = BMA2x2_INIT_VALUE;
    830              
    831          	if (p_bma2x2 == BMA2x2_NULL) {
    832          		/* Check the struct p_bma2x2 is empty */
    833          		return E_BMA2x2_NULL_PTR;
    834              } else {
    835          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    836                      (p_bma2x2->dev_addr,
    837                       BMA2x2_X_AXIS_MSB_ADDR, &data_u8,
    838                       BMA2x2_GEN_READ_WRITE_LENGTH);
    839          		accel->x = BMA2x2_GET_BITSLICE(data_u8,
    840                                                 BMA2x2_ACCEL_X_MSB);
    841                  
    842          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    843                      (p_bma2x2->dev_addr,
    844                       BMA2x2_Y_AXIS_MSB_ADDR, &data_u8,
    845                       BMA2x2_GEN_READ_WRITE_LENGTH);
    846          		accel->y = BMA2x2_GET_BITSLICE(data_u8,
    847                                                 BMA2x2_ACCEL_Y_MSB);
    848                  
    849          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    850                      (p_bma2x2->dev_addr,
    851                       BMA2x2_Z_AXIS_MSB_ADDR, &data_u8,
    852                       BMA2x2_GEN_READ_WRITE_LENGTH);
    853          		accel->z = BMA2x2_GET_BITSLICE(data_u8,
    854                                                 BMA2x2_ACCEL_Z_MSB);
    855              }
    856          	return com_rslt;
    857          }
    858          /*!
    859          *	@brief This API read tap-sign, tap-first-xyz
    860          *	slope-sign, slope-first-xyz status register byte
    861          *	from location 0Bh
    862          *
    863          *   @param stat_tap_u8 : The status of tap and slope
    864          *
    865          *
    866          *
    867          *	@return results of bus communication function
    868          *	@retval 0 -> Success
    869          *	@retval -1 -> Error
    870          *
    871          *
    872          */
    873          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_tap_stat(
    874                                                               u8 *stat_tap_u8)
    875          {
    876          	/*  Variable used to return value of
    877          	communication routine*/
    878          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    879              
    880          	if (p_bma2x2 == BMA2x2_NULL) {
    881          		/* Check the struct p_bma2x2 is empty */
    882          		return E_BMA2x2_NULL_PTR;
    883              } else {
    884                  /* Read the interrupt status register 0x0B*/
    885                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    886          			(p_bma2x2->dev_addr, BMA2x2_STAT_TAP_SLOPE_ADDR,
    887                       stat_tap_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
    888              }
    889          	return com_rslt;
    890          }
    891          /*!
    892          *	@brief This API read orient, high-sign and high-first-xyz
    893          *	status register byte from location 0Ch
    894          *
    895          *
    896          *  @param stat_orient_u8 : The status of orient and high
    897          *
    898          *
    899          *
    900          *	@return results of bus communication function
    901          *	@retval 0 -> Success
    902          *	@retval -1 -> Error
    903          *
    904          *
    905          */
    906          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_orient_stat(
    907                                                                  u8 *stat_orient_u8)
    908          {
    909          	/*  Variable used to return value of
    910          	communication routine*/
    911          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    912              
    913          	if (p_bma2x2 == BMA2x2_NULL) {
    914          		/* Check the struct p_bma2x2 is empty */
    915          		return E_BMA2x2_NULL_PTR;
    916              } else {
    917                  /* Read the interrupt status register 0x0C*/
    918                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
    919          			(p_bma2x2->dev_addr, BMA2x2_STAT_ORIENT_HIGH_ADDR,
    920                       stat_orient_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
    921              }
    922          	return com_rslt;
    923          }
    924          /*!
    925          *	@brief This API reads fifo overrun and fifo frame counter
    926          *	status register byte  from location 0Eh
    927          *
    928          *  @param stat_fifo_u8 : The status of fifo overrun and frame counter
    929          *
    930          *
    931          *
    932          *	@return results of bus communication function
    933          *	@retval 0 -> Success
    934          *	@retval -1 -> Error
    935          *
    936          *
    937          */
    938          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_fifo_stat(
    939                                                           u8 *stat_fifo_u8)
    940          {
    941          	/*  Variable used to return value of
    942          	communication routine*/
    943          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    944              
    945          	if (p_bma2x2 == BMA2x2_NULL) {
    946          		/* Check the struct p_bma2x2 is empty */
    947          		return E_BMA2x2_NULL_PTR;
    948              } else {
    949                  /* Read the interrupt status register 0x0E*/
    950                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(p_bma2x2->dev_addr,
    951                                                            BMA2x2_STAT_FIFO_ADDR,
    952                                                            stat_fifo_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
    953              }
    954          	return com_rslt;
    955          }
    956          /*!
    957          *	@brief This API read fifo frame count
    958          *	from location 0Eh bit position 0 to 6
    959          *
    960          *
    961          * @param frame_count_u8 : The status of fifo frame count
    962          *
    963          *
    964          *
    965          *	@return results of bus communication function
    966          *	@retval 0 -> Success
    967          *	@retval -1 -> Error
    968          *
    969          *
    970          */
    971          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_fifo_frame_count(u8 *frame_count_u8)
    972          {
    973          	/*  Variable used to return value of
    974          	communication routine*/
    975          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
    976          	u8 data_u8 = BMA2x2_INIT_VALUE;
    977              
    978          	if (p_bma2x2 == BMA2x2_NULL) {
    979          		/* Check the struct p_bma2x2 is empty */
    980          		return E_BMA2x2_NULL_PTR;
    981              } else {
    982                  /* Read the FIFO frame count*/
    983                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(p_bma2x2->dev_addr,
    984                                                            BMA2x2_FIFO_FRAME_COUNT_STAT_REG,
    985                                                            &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
    986                  *frame_count_u8 = BMA2x2_GET_BITSLICE(data_u8,
    987                                                        BMA2x2_FIFO_FRAME_COUNT_STAT);
    988              }
    989          	return com_rslt;
    990          }
    991          /*!
    992          *	@brief This API read fifo overrun
    993          *	from location 0Eh bit position 7
    994          *
    995          *
    996          * @param fifo_overrun_u8 : The status of fifo overrun
    997          *
    998          *
    999          *
   1000          *	@return results of bus communication function
   1001          *	@retval 0 -> Success
   1002          *	@retval -1 -> Error
   1003          *
   1004          *
   1005          */
   1006          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_fifo_overrun(
   1007                                                              u8 *fifo_overrun_u8)
   1008          {
   1009              /*  Variable used to return value of
   1010          	communication routine*/
   1011          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1012          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1013              
   1014          	if (p_bma2x2 == BMA2x2_NULL) {
   1015          		/* Check the struct p_bma2x2 is empty */
   1016          		return E_BMA2x2_NULL_PTR;
   1017              } else {
   1018                  /* Read the status of fifo over run*/
   1019                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   1020                                                            p_bma2x2->dev_addr,
   1021                                                            BMA2x2_FIFO_OVERRUN_STAT_REG,
   1022                                                            &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1023                  *fifo_overrun_u8 = BMA2x2_GET_BITSLICE(data_u8,
   1024                                                         BMA2x2_FIFO_OVERRUN_STAT);
   1025              }
   1026          	return com_rslt;
   1027          }
   1028          /*!
   1029          *	@brief This API read interrupt status of flat, orient, single tap,
   1030          *	double tap, slow no motion, slope, highg and lowg from location 09h
   1031          *
   1032          *
   1033          *
   1034          *	@param  intr_stat_u8 : The value of interrupt status
   1035          *
   1036          *
   1037          *
   1038          *	@return results of bus communication function
   1039          *	@retval 0 -> Success
   1040          *	@retval -1 -> Error
   1041          *
   1042          *
   1043          */
   1044          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_stat(u8 *intr_stat_u8)
   1045          {
   1046          	/*  Variable used to return value of
   1047          	communication routine*/
   1048          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1049              
   1050          	if (p_bma2x2 == BMA2x2_NULL) {
   1051          		/* Check the struct p_bma2x2 is empty */
   1052          		return E_BMA2x2_NULL_PTR;
   1053              } else {
   1054                  /* Read the interrupt status register 0x09*/
   1055                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(p_bma2x2->dev_addr,
   1056                                                            BMA2x2_STAT1_ADDR, intr_stat_u8,
   1057                                                            BMA2x2_SHIFT_FOUR_BITS);
   1058              }
   1059          	return com_rslt;
   1060          }
   1061          /*!
   1062          * @brief This API is used to get the ranges(g values) of the sensor
   1063          *	in the register 0x0F bit from 0 to 3
   1064          *
   1065          *
   1066          *	@param range_u8 : The value of range
   1067          *		  range_u8       |   result
   1068          *       ----------------- | --------------
   1069          *              0x03       | BMA2x2_RANGE_2G
   1070          *              0x05       | BMA2x2_RANGE_4G
   1071          *              0x08       | BMA2x2_RANGE_8G
   1072          *              0x0C       | BMA2x2_RANGE_16G
   1073          *
   1074          *
   1075          *
   1076          *	@return results of bus communication function
   1077          *	@retval 0 -> Success
   1078          *	@retval -1 -> Error
   1079          *
   1080          *
   1081          */
   1082          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_range(u8 *range_u8)
   1083          {
   1084          	/*  Variable used to return value of
   1085          	communication routine*/
   1086          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1087          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1088              
   1089          	if (p_bma2x2 == BMA2x2_NULL) {
   1090          		/* Check the struct p_bma2x2 is empty */
   1091          		return E_BMA2x2_NULL_PTR;
   1092              } else {
   1093          		/* Read the range register 0x0F*/
   1094          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(p_bma2x2->dev_addr,
   1095                                                            BMA2x2_RANGE_SELECT_REG, &data_u8,
   1096                                                            BMA2x2_GEN_READ_WRITE_LENGTH);
   1097          		data_u8 = BMA2x2_GET_BITSLICE(data_u8, BMA2x2_RANGE_SELECT);
   1098          		*range_u8 = data_u8;
   1099          	}
   1100          	return com_rslt;
   1101          }
   1102          /*!
   1103          * @brief This API is used to set the ranges(g values) of the sensor
   1104          *	in the register 0x0F bit from 0 to 3
   1105          *
   1106          *
   1107          *	@param range_u8 : The value of range
   1108          *		  range_u8 |   result
   1109          *       ----------------- | --------------
   1110          *              0x03       | BMA2x2_RANGE_2G
   1111          *              0x05       | BMA2x2_RANGE_4G
   1112          *              0x08       | BMA2x2_RANGE_8G
   1113          *              0x0C       | BMA2x2_RANGE_16G
   1114          *
   1115          *
   1116          *
   1117          *	@return results of bus communication function
   1118          *	@retval 0 -> Success
   1119          *	@retval -1 -> Error
   1120          *
   1121          *
   1122          */
   1123          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_range(u8 range_u8)
   1124          {
   1125          	/*  Variable used to return value of
   1126          	communication routine*/
   1127          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1128          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1129              
   1130          	if (p_bma2x2 == BMA2x2_NULL) {
   1131          		/* Check the struct p_bma2x2 is empty */
   1132          		return E_BMA2x2_NULL_PTR;
   1133              } else {
   1134          		if ((range_u8 == BMA2x2_RANGE_2G) ||
   1135                      (range_u8 == BMA2x2_RANGE_4G) ||
   1136                          (range_u8 == BMA2x2_RANGE_8G) ||
   1137                              (range_u8 == BMA2x2_RANGE_16G)) {
   1138                                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1139                                      (p_bma2x2->dev_addr,
   1140                                       BMA2x2_RANGE_SELECT_REG, &data_u8,
   1141                                       BMA2x2_GEN_READ_WRITE_LENGTH);
   1142                                  switch (range_u8) {
   1143                                    case BMA2x2_RANGE_2G:
   1144                                      data_u8  = BMA2x2_SET_BITSLICE(data_u8,
   1145                                                                     BMA2x2_RANGE_SELECT,
   1146                                                                     BMA2x2_RANGE_2G);
   1147                                      break;
   1148                                    case BMA2x2_RANGE_4G:
   1149                                      data_u8  = BMA2x2_SET_BITSLICE(data_u8,
   1150                                                                     BMA2x2_RANGE_SELECT,
   1151                                                                     BMA2x2_RANGE_4G);
   1152                                      break;
   1153                                    case BMA2x2_RANGE_8G:
   1154                                      data_u8  = BMA2x2_SET_BITSLICE(data_u8,
   1155                                                                     BMA2x2_RANGE_SELECT,
   1156                                                                     BMA2x2_RANGE_8G);
   1157                                      break;
   1158                                    case BMA2x2_RANGE_16G:
   1159                                      data_u8  = BMA2x2_SET_BITSLICE(data_u8,
   1160                                                                     BMA2x2_RANGE_SELECT,
   1161                                                                     BMA2x2_RANGE_16G);
   1162                                      break;
   1163                                    default:
   1164                                      break;
   1165                                  }
   1166                                  /* Write the range register 0x0F*/
   1167                                  com_rslt += bma2x2_write_reg(BMA2x2_RANGE_SELECT_REG,
   1168                                                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1169                              } else {
   1170                                  com_rslt = E_OUT_OF_RANGE;
   1171                              }
   1172          	}
   1173          	return com_rslt;
   1174          }
   1175          /*!
   1176          *  @brief This API is used to get the bandwidth of the sensor in the register
   1177          *  0x10 bit from 0 to 4
   1178          *
   1179          *
   1180          *  @param bw_u8 : The value of bandwidth
   1181          *          bw_u8          |   result
   1182          *       ----------------- | --------------
   1183          *              0x08       | BMA2x2_BW_7_81HZ
   1184          *              0x09       | BMA2x2_BW_15_63HZ
   1185          *              0x0A       | BMA2x2_BW_31_25HZ
   1186          *              0x0B       | BMA2x2_BW_62_50HZ
   1187          *              0x0C       | BMA2x2_BW_125HZ
   1188          *              0x0D       | BMA2x2_BW_250HZ
   1189          *              0x0E       | BMA2x2_BW_500HZ
   1190          *              0x0F       | BMA2x2_BW_1000HZ
   1191          *
   1192          *
   1193          *
   1194          *  @return results of bus communication function
   1195          *  @retval 0 -> Success
   1196          *  @retval -1 -> Error
   1197          *
   1198          *
   1199          */
   1200          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_bw(u8 *bw_u8)
   1201          {
   1202          	/*  Variable used to return value of
   1203          	communication routine*/
   1204          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1205          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1206              
   1207          	if (p_bma2x2 == BMA2x2_NULL) {
   1208          		/* Check the struct p_bma2x2 is empty */
   1209          		return E_BMA2x2_NULL_PTR;
   1210              } else {
   1211                  /* Read the bandwidth register 0x10*/
   1212                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1213          			(p_bma2x2->dev_addr,
   1214                       BMA2x2_BW_REG, &data_u8,
   1215                       BMA2x2_GEN_READ_WRITE_LENGTH);
   1216                  data_u8 = BMA2x2_GET_BITSLICE(data_u8, BMA2x2_BW);
   1217                  *bw_u8 = data_u8;
   1218              }
   1219          	return com_rslt;
   1220          }
   1221          /*!
   1222          *	@brief This API is used to set the bandwidth of the sensor
   1223          *      in the register
   1224          *	0x10 bit from 0 to 4
   1225          *
   1226          *
   1227          *  @param bw_u8 : The value of bandwidth
   1228          *		  bw_u8          |   result
   1229          *       ----------------- | --------------
   1230          *              0x08       | BMA2x2_BW_7_81HZ
   1231          *              0x09       | BMA2x2_BW_15_63HZ
   1232          *              0x0A       | BMA2x2_BW_31_25HZ
   1233          *              0x0B       | BMA2x2_BW_62_50HZ
   1234          *              0x0C       | BMA2x2_BW_125HZ
   1235          *              0x0D       | BMA2x2_BW_250HZ
   1236          *              0x0E       | BMA2x2_BW_500HZ
   1237          *              0x0F       | BMA2x2_BW_1000HZ
   1238          *
   1239          *
   1240          *
   1241          *	@return results of bus communication function
   1242          *	@retval 0 -> Success
   1243          *	@retval -1 -> Error
   1244          *
   1245          *
   1246          */
   1247          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_bw(u8 bw_u8)
   1248          {
   1249              /*  Variable used to return value of
   1250              communication routine*/
   1251              BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1252              u8 data_u8 = BMA2x2_INIT_VALUE;
   1253              u8 data_bw_u8 = BMA2x2_INIT_VALUE;
   1254              if (p_bma2x2 == BMA2x2_NULL) {
   1255          		/* Check the struct p_bma2x2 is empty */
   1256          		com_rslt = E_BMA2x2_NULL_PTR;
   1257          	} else {
   1258                  /* Check the chip id 0xFB, it support upto 500Hz*/
   1259                  if (p_bma2x2->chip_id == BANDWIDTH_DEFINE) {
   1260                      if (bw_u8 > BMA2x2_ACCEL_BW_MIN_RANGE &&
   1261                          bw_u8 < BMA2x2_ACCEL_BW_1000HZ_RANGE) {
   1262                              switch (bw_u8) {
   1263                                case BMA2x2_BW_7_81HZ:
   1264                                  data_bw_u8 = BMA2x2_BW_7_81HZ;
   1265                                  
   1266                                  /*  7.81 Hz      64000 uS   */
   1267                                  break;
   1268                                case BMA2x2_BW_15_63HZ:
   1269                                  data_bw_u8 = BMA2x2_BW_15_63HZ;
   1270                                  
   1271                                  /*  15.63 Hz     32000 uS   */
   1272                                  break;
   1273                                case BMA2x2_BW_31_25HZ:
   1274                                  data_bw_u8 = BMA2x2_BW_31_25HZ;
   1275                                  
   1276                                  /*  31.25 Hz     16000 uS   */
   1277                                  break;
   1278                                case BMA2x2_BW_62_50HZ:
   1279                                  data_bw_u8 = BMA2x2_BW_62_50HZ;
   1280                                  
   1281                                  /*  62.50 Hz     8000 uS   */
   1282                                  break;
   1283                                case BMA2x2_BW_125HZ:
   1284                                  data_bw_u8 = BMA2x2_BW_125HZ;
   1285                                  
   1286                                  /*  125 Hz       4000 uS   */
   1287                                  break;
   1288                                case BMA2x2_BW_250HZ:
   1289                                  data_bw_u8 = BMA2x2_BW_250HZ;
   1290                                  
   1291                                  /*  250 Hz       2000 uS   */
   1292                                  break;
   1293                                case BMA2x2_BW_500HZ:
   1294                                  data_bw_u8 = BMA2x2_BW_500HZ;
   1295                                  
   1296                                  /*  500 Hz       1000 uS   */
   1297                                  break;
   1298                                default:
   1299                                  break;
   1300                              }
   1301                              /* Write the bandwidth register */
   1302                              com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1303                                  (p_bma2x2->dev_addr,
   1304                                   BMA2x2_BW_REG, &data_u8,
   1305                                   BMA2x2_GEN_READ_WRITE_LENGTH);
   1306                              data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   1307                                                            BMA2x2_BW, data_bw_u8);
   1308                              com_rslt += bma2x2_write_reg
   1309                                  (BMA2x2_BW_REG, &data_u8,
   1310                                   BMA2x2_GEN_READ_WRITE_LENGTH);
   1311                          } else {
   1312                              com_rslt = E_OUT_OF_RANGE;
   1313                          }
   1314          		} else {
   1315                      if (bw_u8 > BMA2x2_ACCEL_BW_MIN_RANGE &&
   1316                          bw_u8 < BMA2x2_ACCEL_BW_MAX_RANGE) {
   1317                              switch (bw_u8) {
   1318                                case BMA2x2_BW_7_81HZ:
   1319                                  data_bw_u8 = BMA2x2_BW_7_81HZ;
   1320                                  
   1321                                  /*  7.81 Hz      64000 uS   */
   1322                                  break;
   1323                                case BMA2x2_BW_15_63HZ:
   1324                                  data_bw_u8 = BMA2x2_BW_15_63HZ;
   1325                                  
   1326                                  /*  15.63 Hz     32000 uS   */
   1327                                  break;
   1328                                case BMA2x2_BW_31_25HZ:
   1329                                  data_bw_u8 = BMA2x2_BW_31_25HZ;
   1330                                  
   1331                                  /*  31.25 Hz     16000 uS   */
   1332                                  break;
   1333                                case BMA2x2_BW_62_50HZ:
   1334                                  data_bw_u8 = BMA2x2_BW_62_50HZ;
   1335                                  
   1336                                  /*  62.50 Hz     8000 uS   */
   1337                                  break;
   1338                                case BMA2x2_BW_125HZ:
   1339                                  data_bw_u8 = BMA2x2_BW_125HZ;
   1340                                  
   1341                                  /*  125 Hz       4000 uS   */
   1342                                  break;
   1343                                case BMA2x2_BW_250HZ:
   1344                                  data_bw_u8 = BMA2x2_BW_250HZ;
   1345                                  
   1346                                  /*  250 Hz       2000 uS   */
   1347                                  break;
   1348                                case BMA2x2_BW_500HZ:
   1349                                  data_bw_u8 = BMA2x2_BW_500HZ;
   1350                                  
   1351                                  /*!  500 Hz       1000 uS   */
   1352                                  break;
   1353                                case BMA2x2_BW_1000HZ:
   1354                                  data_bw_u8 = BMA2x2_BW_1000HZ;
   1355                                  
   1356                                  /*  1000 Hz      500 uS   */
   1357                                  break;
   1358                                default:
   1359                                  break;
   1360                              }
   1361                              /* Write the bandwidth register */
   1362                              com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1363                                  (p_bma2x2->dev_addr,
   1364                                   BMA2x2_BW_REG, &data_u8,
   1365                                   BMA2x2_GEN_READ_WRITE_LENGTH);
   1366                              data_u8 = BMA2x2_SET_BITSLICE
   1367                                  (data_u8, BMA2x2_BW, data_bw_u8);
   1368                              com_rslt += bma2x2_write_reg(
   1369                                                           BMA2x2_BW_REG, &data_u8,
   1370                                                           BMA2x2_GEN_READ_WRITE_LENGTH);
   1371                          } else {
   1372                              com_rslt = E_OUT_OF_RANGE;
   1373                          }
   1374          		}
   1375          	}
   1376          	return com_rslt;
   1377          }
   1378          /*!
   1379          *	@brief This API is used to get the operating
   1380          *	modes of the sensor in the register 0x11 and 0x12
   1381          *	@note Register 0x11 - bit from 5 to 7
   1382          *	@note Register 0x12 - bit from 5 and 6
   1383          *
   1384          *
   1385          *  @param power_mode_u8 : The value of power mode
   1386          *	power_mode_u8           |value  |   0x11  |   0x12
   1387          *  ------------------------- |-------| --------|--------
   1388          *  BMA2x2_MODE_NORMAL        |  0    |  0x00   |  0x00
   1389          *  BMA2x2_MODE_LOWPOWER1     |  1    |  0x02   |  0x00
   1390          *  BMA2x2_MODE_SUSPEND       |  2    |  0x06   |  0x00
   1391          *  BMA2x2_MODE_DEEP_SUSPEND  |  3    |  0x01   |  0x00
   1392          *  BMA2x2_MODE_LOWPOWER2     |  4    |  0x02   |  0x01
   1393          *  BMA2x2_MODE_STANDBY       |  5    |  0x04   |  0x00
   1394          *
   1395          *
   1396          *
   1397          *	@return results of bus communication function
   1398          *	@retval 0 -> Success
   1399          *	@retval -1 -> Error
   1400          *
   1401          *
   1402          */
   1403          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_power_mode(
   1404                                                            u8 *power_mode_u8)
   1405          {
   1406          	/*  Variable used to return value of
   1407          	communication routine*/
   1408              BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1409              u8 data_u8 = BMA2x2_INIT_VALUE;
   1410              u8 data2_u8 = BMA2x2_INIT_VALUE;
   1411              if (p_bma2x2 == BMA2x2_NULL) {
   1412                  /* Check the struct p_bma2x2 is empty */
   1413          		com_rslt = E_BMA2x2_NULL_PTR;
   1414          	} else {
   1415          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1416                      (p_bma2x2->dev_addr, BMA2x2_MODE_CTRL_REG,
   1417                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1418          		com_rslt += p_bma2x2->BMA2x2_BUS_READ_FUNC
   1419                      (p_bma2x2->dev_addr, BMA2x2_LOW_NOISE_CTRL_ADDR,
   1420                       &data2_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1421                  
   1422          		data_u8  = (data_u8 &
   1423                              BMA2x2_POWER_MODE_HEX_E_ZERO_MASK) >>
   1424                      BMA2x2_SHIFT_FIVE_BITS;
   1425          		data2_u8  = (data2_u8 &
   1426                               BMA2x2_POWER_MODE_HEX_4_ZERO_MASK) >>
   1427                      BMA2x2_SHIFT_SIX_BITS;
   1428                  
   1429                  if ((data_u8 ==
   1430                       BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK) &&
   1431                      (data2_u8 ==
   1432                       BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK)) {
   1433                           *power_mode_u8  = BMA2x2_MODE_NORMAL;
   1434                       } else {
   1435                           if ((data_u8 ==
   1436                                BMA2x2_POWER_MODE_HEX_ZERO_TWO_MASK) &&
   1437                               (data2_u8 ==
   1438                                BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK)) {
   1439                                    *power_mode_u8  =
   1440                                        BMA2x2_MODE_LOWPOWER1;
   1441                                } else {
   1442                                    if ((data_u8 ==
   1443                                         BMA2x2_POWER_MODE_HEX_ZERO_FOUR_MASK
   1444                                             || data_u8 ==
   1445                                                 BMA2x2_POWER_MODE_HEX_ZERO_SIX_MASK) &&
   1446                                        (data2_u8 ==
   1447                                         BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK)) {
   1448                                             *power_mode_u8  =
   1449                                                 BMA2x2_MODE_SUSPEND;
   1450                                         } else {
   1451                                             if (((data_u8 &
   1452                                                   BMA2x2_POWER_MODE_HEX_ZERO_ONE_MASK)
   1453                                                  == BMA2x2_POWER_MODE_HEX_ZERO_ONE_MASK)) {
   1454                                                      *power_mode_u8  =
   1455                                                          BMA2x2_MODE_DEEP_SUSPEND;
   1456                                                  } else {
   1457                                                      if ((data_u8 ==
   1458                                                           BMA2x2_POWER_MODE_HEX_ZERO_TWO_MASK)
   1459                                                          && (data2_u8 ==
   1460                                                              BMA2x2_POWER_MODE_HEX_ZERO_ONE_MASK)) {
   1461                                                                  *power_mode_u8  =
   1462                                                                      BMA2x2_MODE_LOWPOWER2;
   1463                                                              } else {
   1464                                                                  if ((data_u8 ==
   1465                                                                       BMA2x2_POWER_MODE_HEX_ZERO_FOUR_MASK) &&
   1466                                                                      (data2_u8 ==
   1467                                                                       BMA2x2_POWER_MODE_HEX_ZERO_ONE_MASK))
   1468                                                                      *power_mode_u8  =
   1469                                                                          BMA2x2_MODE_STANDBY;
   1470                                                                  else
   1471                                                                      *power_mode_u8 =
   1472                                                                          BMA2x2_MODE_DEEP_SUSPEND;
   1473                                                              }
   1474                                                  }
   1475                                         }
   1476                                }
   1477                       }
   1478          	}
   1479          	p_bma2x2->power_mode_u8 = *power_mode_u8;
   1480              return com_rslt;
   1481          }
   1482          
   1483          /*!
   1484          *	@brief This API is used to set the operating
   1485          *	modes of the sensor in the register 0x11 and 0x12
   1486          *	@note Register 0x11 - bit from 5 to 7
   1487          *	@note Register 0x12 - bit from 5 and 6
   1488          *
   1489          *
   1490          *  @param power_mode_u8 : The value of power mode
   1491          *	power_mode_u8         |value  |   0x11  |   0x12
   1492          *  ------------------------- |-------| --------|--------
   1493          *  BMA2x2_MODE_NORMAL        |  0    |  0x00   |  0x00
   1494          *  BMA2x2_MODE_LOWPOWER1     |  1    |  0x02   |  0x00
   1495          *  BMA2x2_MODE_SUSPEND       |  2    |  0x06   |  0x00
   1496          *  BMA2x2_MODE_DEEP_SUSPEND  |  3    |  0x01   |  0x00
   1497          *  BMA2x2_MODE_LOWPOWER2     |  4    |  0x02   |  0x01
   1498          *  BMA2x2_MODE_STANDBY       |  5    |  0x04   |  0x00
   1499          *
   1500          *
   1501          *
   1502          *	@return results of bus communication function
   1503          *	@retval 0 -> Success
   1504          *	@retval -1 -> Error
   1505          *
   1506          *
   1507          */
   1508          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_power_mode(u8 power_mode_u8)
   1509          {
   1510              /*  Variable used to return value of
   1511          	communication routine*/
   1512          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1513          	u8 mode_ctr_eleven_reg = BMA2x2_INIT_VALUE;
   1514          	u8 mode_ctr_twel_reg = BMA2x2_INIT_VALUE;
   1515          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1516          	u8 data2_u8 = BMA2x2_INIT_VALUE;
   1517          	u8 pre_fifo_config_data = BMA2x2_INIT_VALUE;
   1518              
   1519          	if (p_bma2x2 == BMA2x2_NULL) {
   1520          		/* Check the struct p_bma2x2 is empty */
   1521          		com_rslt = E_BMA2x2_NULL_PTR;
   1522          	} else {
   1523          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(p_bma2x2->dev_addr,
   1524                                                            BMA2x2_MODE_CTRL_REG, &data_u8, 1);
   1525          		com_rslt += p_bma2x2->BMA2x2_BUS_READ_FUNC(p_bma2x2->dev_addr,
   1526                                                             BMA2x2_LOW_POWER_MODE_REG, &data2_u8, 1);
   1527                  
   1528          		/* write the previous FIFO mode and data select*/
   1529          		pre_fifo_config_data = p_bma2x2->fifo_config;
   1530          		pre_fifo_config_data |= 0x0C;
   1531                  
   1532          		com_rslt += bma2x2_set_mode_value(power_mode_u8);
   1533          		mode_ctr_eleven_reg = p_bma2x2->ctrl_mode_reg;
   1534          		mode_ctr_twel_reg =  p_bma2x2->low_mode_reg;
   1535                  
   1536          		/* write the power mode to the register 0x12*/
   1537          		data2_u8  = BMA2x2_SET_BITSLICE(data2_u8, BMA2x2_LOW_POWER_MODE,
   1538                                                  mode_ctr_twel_reg);
   1539          		com_rslt += bma2x2_write_reg(BMA2x2_LOW_POWER_MODE_REG,
   1540                                               &data2_u8, 1);
   1541                  
   1542          		/*A minimum delay of atleast 450us is required for
   1543          		the low power modes, as per the data sheet.*/
   1544          		p_bma2x2->delay_msec(BMA2x2_INTERFACE_IDLE_TIME_DELAY);
   1545                  
   1546          		if (((p_bma2x2->power_mode_u8 == BMA2x2_MODE_LOWPOWER1) ||
   1547                       (p_bma2x2->power_mode_u8 == BMA2x2_MODE_LOWPOWER2)) &&
   1548                      (power_mode_u8 == BMA2x2_MODE_NORMAL)) {
   1549          				/* Enter the power mode to suspend*/
   1550          				data_u8  = BMA2x2_SET_BITSLICE(data_u8,
   1551                                                         BMA2x2_MODE_CTRL, BMA2x2_SHIFT_FOUR_BITS);
   1552          				/* write the power mode to suspend*/
   1553          				com_rslt += bma2x2_write_reg(
   1554                                                       BMA2x2_MODE_CTRL_REG, &data_u8,
   1555                                                       BMA2x2_GEN_READ_WRITE_LENGTH);
   1556          				/*re-write FIFO_CONFIG_0 register*/
   1557          				com_rslt += bma2x2_write_reg(
   1558                                                       BMA2x2_FIFO_MODE_REG, &pre_fifo_config_data, 1);
   1559          			}
   1560                  
   1561          		/* write the power mode to 0x11 register*/
   1562          		data_u8  = BMA2x2_SET_BITSLICE(data_u8, BMA2x2_MODE_CTRL,
   1563                                                 mode_ctr_eleven_reg);
   1564          		com_rslt += bma2x2_write_reg(BMA2x2_MODE_CTRL_REG, &data_u8, 1);
   1565          		/*A minimum delay of atleast 450us is required for
   1566          		the low power modes, as per the data sheet.*/
   1567          		p_bma2x2->delay_msec(BMA2x2_INTERFACE_IDLE_TIME_DELAY);
   1568                  
   1569          		com_rslt += bma2x2_write_reg(BMA2x2_FIFO_MODE_REG,
   1570                                               &pre_fifo_config_data, 1);
   1571                  
   1572          		/*Assigning the power mode to the global variable*/
   1573          		p_bma2x2->power_mode_u8 = power_mode_u8;
   1574          	}
   1575          	return com_rslt;
   1576          }
   1577          /*!
   1578          *	@brief This API is used to assign the power mode values
   1579          *	modes of the sensor in the register 0x11 and 0x12
   1580          *	@note Register 0x11 - bit from 5 to 7
   1581          *	@note Register 0x12 - bit from 5 and 6
   1582          *
   1583          *
   1584          *  @param power_mode_u8 : The value of power mode
   1585          *	power_mode_u8           |value  |   0x11  |   0x12
   1586          *  ------------------------- |-------| --------|--------
   1587          *  BMA2x2_MODE_NORMAL        |  0    |  0x00   |  0x00
   1588          *  BMA2x2_MODE_LOWPOWER1     |  1    |  0x02   |  0x00
   1589          *  BMA2x2_MODE_SUSPEND       |  2    |  0x06   |  0x00
   1590          *  BMA2x2_MODE_DEEP_SUSPEND  |  3    |  0x01   |  0x00
   1591          *  BMA2x2_MODE_LOWPOWER2     |  4    |  0x02   |  0x01
   1592          *  BMA2x2_MODE_STANDBY       |  5    |  0x04   |  0x00
   1593          *
   1594          *
   1595          *
   1596          *	@return results of bus communication function
   1597          *	@retval 0 -> Success
   1598          *	@retval -1 -> Error
   1599          *
   1600          *
   1601          */
   1602          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_mode_value(u8 power_mode_u8)
   1603          {
   1604          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = SUCCESS;
   1605              
   1606          	if (p_bma2x2 == BMA2x2_NULL) {
   1607          		/* Check the struct p_bma2x2 is empty */
   1608          		com_rslt = E_BMA2x2_NULL_PTR;
   1609          	} else {
   1610                  if (power_mode_u8 < BMA2x2_POWER_MODE_RANGE) {
   1611                      switch (power_mode_u8)	{
   1612                        case BMA2x2_MODE_NORMAL:
   1613                          p_bma2x2->ctrl_mode_reg =
   1614                              BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK;
   1615                          p_bma2x2->low_mode_reg =
   1616                              BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK;
   1617                          break;
   1618                        case BMA2x2_MODE_LOWPOWER1:
   1619                          p_bma2x2->ctrl_mode_reg =
   1620                              BMA2x2_POWER_MODE_HEX_ZERO_TWO_MASK;
   1621                          p_bma2x2->low_mode_reg =
   1622                              BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK;
   1623                          break;
   1624                        case BMA2x2_MODE_LOWPOWER2:
   1625                          p_bma2x2->ctrl_mode_reg =
   1626                              BMA2x2_POWER_MODE_HEX_ZERO_TWO_MASK;
   1627                          p_bma2x2->low_mode_reg =
   1628                              BMA2x2_POWER_MODE_HEX_ZERO_ONE_MASK;
   1629                          break;
   1630                        case BMA2x2_MODE_SUSPEND:
   1631                          p_bma2x2->ctrl_mode_reg =
   1632                              BMA2x2_POWER_MODE_HEX_ZERO_FOUR_MASK;
   1633                          p_bma2x2->low_mode_reg =
   1634                              BMA2x2_POWER_MODE_HEX_ZERO_ZERO_MASK;
   1635                          break;
   1636                        case BMA2x2_MODE_STANDBY:
   1637                          p_bma2x2->ctrl_mode_reg =
   1638                              BMA2x2_POWER_MODE_HEX_ZERO_FOUR_MASK;
   1639                          p_bma2x2->low_mode_reg =
   1640                              BMA2x2_POWER_MODE_HEX_ZERO_ONE_MASK;
   1641                          break;
   1642                        case BMA2x2_MODE_DEEP_SUSPEND:
   1643                          p_bma2x2->ctrl_mode_reg =
   1644                              BMA2x2_POWER_MODE_HEX_ZERO_ONE_MASK;
   1645                          break;
   1646                      }
   1647          		} else {
   1648          			com_rslt = E_OUT_OF_RANGE;
   1649          		}
   1650          	}
   1651          	return com_rslt;
   1652          }
   1653          /*!
   1654          *	@brief This API is used to get
   1655          *	the sleep duration of the sensor in the register 0x11
   1656          *	Register 0x11 - bit from 0 to 3
   1657          *
   1658          *
   1659          *  @param  sleep_durn_u8 : The value of sleep duration time
   1660          *         sleep_durn_u8 |   result
   1661          *       ----------------- | ----------------------
   1662          *              0x05       | BMA2x2_SLEEP_DURN_0_5MS
   1663          *              0x06       | BMA2x2_SLEEP_DURN_1MS
   1664          *              0x07       | BMA2x2_SLEEP_DURN_2MS
   1665          *              0x08       | BMA2x2_SLEEP_DURN_4MS
   1666          *              0x09       | BMA2x2_SLEEP_DURN_6MS
   1667          *              0x0A       | BMA2x2_SLEEP_DURN_10MS
   1668          *              0x0B       | BMA2x2_SLEEP_DURN_25MS
   1669          *              0x0C       | BMA2x2_SLEEP_DURN_50MS
   1670          *              0x0D       | BMA2x2_SLEEP_DURN_100MS
   1671          *              0x0E       | BMA2x2_SLEEP_DURN_500MS
   1672          *              0x0F       | BMA2x2_SLEEP_DURN_1S
   1673          *
   1674          *
   1675          *
   1676          *	@return results of bus communication function
   1677          *	@retval 0 -> Success
   1678          *	@retval -1 -> Error
   1679          *
   1680          *
   1681          */
   1682          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_sleep_durn(u8 *sleep_durn_u8)
   1683          {
   1684          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1685          	/*  Variable used to return value of
   1686          	communication routine*/
   1687          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1688              
   1689          	if (p_bma2x2 == BMA2x2_NULL) {
   1690          		/* Check the struct p_bma2x2 is empty */
   1691          		return E_BMA2x2_NULL_PTR;
   1692              } else {
   1693                  /* read the sleep duration */
   1694                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1695          			(p_bma2x2->dev_addr, BMA2x2_SLEEP_DURN_REG,
   1696                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1697                  *sleep_durn_u8 = BMA2x2_GET_BITSLICE
   1698          			(data_u8, BMA2x2_SLEEP_DURN);
   1699              }
   1700          	return com_rslt;
   1701          }
   1702          /*!
   1703          *	@brief This API is used to set
   1704          *	the sleep duration of the sensor in the register 0x11
   1705          *	Register 0x11 - bit from 0 to 3
   1706          *
   1707          *
   1708          *
   1709          *
   1710          *  @param  sleep_durn_u8 : The value of sleep duration time
   1711          *        sleep_durn_u8  |   result
   1712          *       ----------------- | ----------------------
   1713          *              0x05       | BMA2x2_SLEEP_DURN_0_5MS
   1714          *              0x06       | BMA2x2_SLEEP_DURN_1MS
   1715          *              0x07       | BMA2x2_SLEEP_DURN_2MS
   1716          *              0x08       | BMA2x2_SLEEP_DURN_4MS
   1717          *              0x09       | BMA2x2_SLEEP_DURN_6MS
   1718          *              0x0A       | BMA2x2_SLEEP_DURN_10MS
   1719          *              0x0B       | BMA2x2_SLEEP_DURN_25MS
   1720          *              0x0C       | BMA2x2_SLEEP_DURN_50MS
   1721          *              0x0D       | BMA2x2_SLEEP_DURN_100MS
   1722          *              0x0E       | BMA2x2_SLEEP_DURN_500MS
   1723          *              0x0F       | BMA2x2_SLEEP_DURN_1S
   1724          *
   1725          *
   1726          *
   1727          *	@return results of bus communication function
   1728          *	@retval 0 -> Success
   1729          *	@retval -1 -> Error
   1730          *
   1731          *
   1732          */
   1733          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_sleep_durn(u8 sleep_durn_u8)
   1734          {
   1735          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1736          	/*  Variable used to return value of
   1737          	communication routine*/
   1738          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1739          	u8 data_sleep_durn_u8 = BMA2x2_INIT_VALUE;
   1740              
   1741          	if (p_bma2x2 == BMA2x2_NULL) {
   1742          		/* Check the struct p_bma2x2 is empty */
   1743          		return E_BMA2x2_NULL_PTR;
   1744              } else {
   1745          		if (sleep_durn_u8 > BMA2x2_SLEEP_DURN_MIN_RANGE &&
   1746                      sleep_durn_u8 < BMA2x2_SLEEP_DURN_MAX_RANGE) {
   1747                          switch (sleep_durn_u8) {
   1748                            case BMA2x2_SLEEP_DURN_0_5MS:
   1749                              data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_0_5MS;
   1750                              
   1751                              /*  0.5 MS   */
   1752                              break;
   1753                            case BMA2x2_SLEEP_DURN_1MS:
   1754                              data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_1MS;
   1755                              
   1756                              /*  1 MS  */
   1757                              break;
   1758                            case BMA2x2_SLEEP_DURN_2MS:
   1759                              data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_2MS;
   1760                              
   1761                              /*  2 MS  */
   1762                              break;
   1763                            case BMA2x2_SLEEP_DURN_4MS:
   1764                              data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_4MS;
   1765                              
   1766                              /*  4 MS   */
   1767                              break;
   1768                            case BMA2x2_SLEEP_DURN_6MS:
   1769                              data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_6MS;
   1770                              
   1771                              /*  6 MS  */
   1772                              break;
   1773                            case BMA2x2_SLEEP_DURN_10MS:
   1774                              data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_10MS;
   1775                              
   1776                              /*  10 MS  */
   1777                              break;
   1778                            case BMA2x2_SLEEP_DURN_25MS:
   1779                              data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_25MS;
   1780                              
   1781                              /*  25 MS  */
   1782                              break;
   1783                            case BMA2x2_SLEEP_DURN_50MS:
   1784                              data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_50MS;
   1785                              
   1786                              /*  50 MS   */
   1787                              break;
   1788                            case BMA2x2_SLEEP_DURN_100MS:
   1789                              data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_100MS;
   1790                              
   1791                              /*  100 MS  */
   1792                              break;
   1793                            case BMA2x2_SLEEP_DURN_500MS:
   1794                              data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_500MS;
   1795                              
   1796                              /*  500 MS   */
   1797                              break;
   1798                            case BMA2x2_SLEEP_DURN_1S:
   1799                              data_sleep_durn_u8 = BMA2x2_SLEEP_DURN_1S;
   1800                              
   1801                              /*!  1 SECS   */
   1802                              break;
   1803                            default:
   1804                              break;
   1805                          }
   1806                          /* write the sleep duration */
   1807                          com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1808                              (p_bma2x2->dev_addr, BMA2x2_SLEEP_DURN_REG,
   1809                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1810                          data_u8 = BMA2x2_SET_BITSLICE
   1811                              (data_u8, BMA2x2_SLEEP_DURN, data_sleep_durn_u8);
   1812                          com_rslt += bma2x2_write_reg(BMA2x2_SLEEP_DURN_REG,
   1813                                                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1814                      } else {
   1815                          com_rslt = E_OUT_OF_RANGE;
   1816                      }
   1817          	}
   1818          	return com_rslt;
   1819          }
   1820          /*!
   1821          * @brief This API is used to get the sleep timer mode
   1822          *	in the register 0x12 bit 5
   1823          *
   1824          *
   1825          *
   1826          *
   1827          *  @param  sleep_timer_u8 : The value of sleep timer mode
   1828          *        sleep_timer_u8 |   result
   1829          *       ----------------- | ----------------------
   1830          *              0          | enable EventDrivenSampling(EDT)
   1831          *              1          | enable Equidistant sampling mode(EST)
   1832          *
   1833          *
   1834          *	@return results of bus communication function
   1835          *	@retval 0 -> Success
   1836          *	@retval -1 -> Error
   1837          *
   1838          *
   1839          */
   1840          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_sleep_timer_mode(
   1841                                                                  u8 *sleep_timer_u8)
   1842          {
   1843          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1844          	/*  Variable used to return value of
   1845          	communication routine*/
   1846          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1847              
   1848          	if (p_bma2x2 == BMA2x2_NULL) {
   1849          		/* Check the struct p_bma2x2 is empty */
   1850          		return E_BMA2x2_NULL_PTR;
   1851              } else {
   1852                  /*Read the SLEEP TIMER MODE*/
   1853                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1854          			(p_bma2x2->dev_addr, BMA2x2_SLEEP_TIMER_REG,
   1855                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1856                  *sleep_timer_u8 = BMA2x2_GET_BITSLICE
   1857          			(data_u8, BMA2x2_SLEEP_TIMER);
   1858              }
   1859          	return com_rslt;
   1860          }
   1861          /*!
   1862          * @brief This API is used to set the sleep timer mode
   1863          *	in the register 0x12 bit 5
   1864          *
   1865          *
   1866          *
   1867          *
   1868          *  @param  sleep_timer_u8 : The value of sleep timer mode
   1869          *        sleep_timer_u8 |   result
   1870          *       ----------------- | ----------------------
   1871          *              0          | enable EventDrivenSampling(EDT)
   1872          *              1          | enable Equidistant sampling mode(EST)
   1873          *
   1874          *
   1875          *	@return results of bus communication function
   1876          *	@retval 0 -> Success
   1877          *	@retval -1 -> Error
   1878          *
   1879          *
   1880          */
   1881          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_sleep_timer_mode(u8 sleep_timer_u8)
   1882          {
   1883          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1884          	/*  Variable used to return value of
   1885          	communication routine*/
   1886          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1887              
   1888          	if (p_bma2x2 == BMA2x2_NULL) {
   1889          		/* Check the struct p_bma2x2 is empty */
   1890          		return E_BMA2x2_NULL_PTR;
   1891              } else {
   1892          		if (sleep_timer_u8 < BMA2x2_SLEEP_TIMER_MODE_RANGE) {
   1893          			/* write the SLEEP TIMER MODE*/
   1894          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1895                          (p_bma2x2->dev_addr, BMA2x2_SLEEP_TIMER_REG,
   1896                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1897          			data_u8 = BMA2x2_SET_BITSLICE
   1898                          (data_u8, BMA2x2_SLEEP_TIMER, sleep_timer_u8);
   1899          			com_rslt += bma2x2_write_reg(BMA2x2_SLEEP_TIMER_REG,
   1900                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1901          		} else {
   1902                      com_rslt = E_OUT_OF_RANGE;
   1903          		}
   1904          	}
   1905          	return com_rslt;
   1906          }
   1907          /*!
   1908          * @brief This API is used to get high bandwidth
   1909          *		in the register 0x13 bit 7
   1910          *
   1911          *  @param  high_bw_u8 : The value of high bandwidth
   1912          *         high_bw_u8    |   result
   1913          *       ----------------- | ----------------------
   1914          *              0          | Unfiltered High Bandwidth
   1915          *              1          | Filtered Low Bandwidth
   1916          *
   1917          *
   1918          *	@return results of bus communication function
   1919          *	@retval 0 -> Success
   1920          *	@retval -1 -> Error
   1921          *
   1922          *
   1923          */
   1924          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_high_bw(u8 *high_bw_u8)
   1925          {
   1926          	/*  Variable used to return value of
   1927          	communication routine*/
   1928          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1929          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1930              
   1931          	if (p_bma2x2 == BMA2x2_NULL) {
   1932          		return  E_BMA2x2_NULL_PTR;
   1933              } else {
   1934                  /* Read the high bandwidth*/
   1935                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1936          			(p_bma2x2->dev_addr, BMA2x2_ENABLE_DATA_HIGH_BW_REG,
   1937                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1938                  *high_bw_u8 = BMA2x2_GET_BITSLICE
   1939          			(data_u8, BMA2x2_ENABLE_DATA_HIGH_BW);
   1940              }
   1941          	return com_rslt;
   1942          }
   1943          /*!
   1944          * @brief This API is used to write high bandwidth
   1945          *		in the register 0x13 bit 7
   1946          *
   1947          *  @param  high_bw_u8 : The value of high bandwidth
   1948          *         high_bw_u8    |   result
   1949          *       ----------------- | ----------------------
   1950          *              0          | Unfiltered High Bandwidth
   1951          *              1          | Filtered Low Bandwidth
   1952          *
   1953          *
   1954          *	@return results of bus communication function
   1955          *	@retval 0 -> Success
   1956          *	@retval -1 -> Error
   1957          *
   1958          *
   1959          */
   1960          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_high_bw(u8 high_bw_u8)
   1961          {
   1962          	/*  Variable used to return value of
   1963          	communication routine*/
   1964          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   1965          	u8 data_u8 = BMA2x2_INIT_VALUE;
   1966              
   1967          	if (p_bma2x2 == BMA2x2_NULL) {
   1968          		return  E_BMA2x2_NULL_PTR;
   1969              }  else {
   1970                  /* Write the high bandwidth*/
   1971                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   1972          			(p_bma2x2->dev_addr, BMA2x2_ENABLE_DATA_HIGH_BW_REG,
   1973                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1974                  data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   1975                                                BMA2x2_ENABLE_DATA_HIGH_BW, high_bw_u8);
   1976                  com_rslt += bma2x2_write_reg(
   1977                                               BMA2x2_ENABLE_DATA_HIGH_BW_REG,
   1978                                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   1979              }
   1980          	return com_rslt;
   1981          }
   1982          /*!
   1983          *	@brief This API is used to get shadow dis
   1984          *	in the register 0x13 bit 6
   1985          *
   1986          *  @param  shadow_dis_u8 : The value of shadow dis
   1987          *        shadow_dis_u8  |   result
   1988          *       ----------------- | ------------------
   1989          *              0          | MSB is Locked
   1990          *              1          | No MSB Locking
   1991          *
   1992          *
   1993          *
   1994          *	@return results of bus communication function
   1995          *	@retval 0 -> Success
   1996          *	@retval -1 -> Error
   1997          *
   1998          *
   1999          */
   2000          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_shadow_dis(u8 *shadow_dis_u8)
   2001          {
   2002          	/*  Variable used to return value of
   2003          	communication routine*/
   2004          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2005          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2006              
   2007          	if (p_bma2x2 == BMA2x2_NULL) {
   2008          		return  E_BMA2x2_NULL_PTR;
   2009              } else {
   2010                  /*Read the shadow dis*/
   2011                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2012          			(p_bma2x2->dev_addr,
   2013                       BMA2x2_DIS_SHADOW_PROC_REG,
   2014                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2015                  *shadow_dis_u8 = BMA2x2_GET_BITSLICE
   2016          			(data_u8, BMA2x2_DIS_SHADOW_PROC);
   2017              }
   2018          	return com_rslt;
   2019          }
   2020          /*!
   2021          *	@brief This API is used to set shadow dis
   2022          *	in the register 0x13 bit 6
   2023          *
   2024          *  @param  shadow_dis_u8 : The value of shadow dis
   2025          *        shadow_dis_u8  |   result
   2026          *       ----------------- | ------------------
   2027          *              0          | MSB is Locked
   2028          *              1          | No MSB Locking
   2029          *
   2030          *
   2031          *
   2032          *	@return results of bus communication function
   2033          *	@retval 0 -> Success
   2034          *	@retval -1 -> Error
   2035          *
   2036          *
   2037          */
   2038          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_shadow_dis(u8 shadow_dis_u8)
   2039          {
   2040          	/*  Variable used to return value of
   2041          	communication routine*/
   2042          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2043          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2044              
   2045          	if (p_bma2x2 == BMA2x2_NULL) {
   2046          		return  E_BMA2x2_NULL_PTR;
   2047              } else {
   2048                  /* Write the shadow dis*/
   2049                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2050          			(p_bma2x2->dev_addr, BMA2x2_DIS_SHADOW_PROC_REG,
   2051                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2052                  data_u8 = BMA2x2_SET_BITSLICE
   2053          			(data_u8, BMA2x2_DIS_SHADOW_PROC, shadow_dis_u8);
   2054                  com_rslt += bma2x2_write_reg(BMA2x2_DIS_SHADOW_PROC_REG,
   2055                                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2056              }
   2057          	return com_rslt;
   2058          }
   2059          /*!
   2060          *	@brief This function is used for the soft reset
   2061          *	The soft reset register will be written
   2062          *	with 0xB6 in the register 0x14.
   2063          *
   2064          *
   2065          *
   2066          *  \param : None
   2067          *
   2068          *	@return results of bus communication function
   2069          *	@retval 0 -> Success
   2070          *	@retval -1 -> Error
   2071          *
   2072          *
   2073          */
   2074          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_soft_rst(void)
   2075          {
   2076          	/*  Variable used to return value of
   2077          	communication routine*/
   2078          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2079          	u8 data_u8 = BMA2x2_ENABLE_SOFT_RESET_VALUE;
   2080              
   2081          	if (p_bma2x2 == BMA2x2_NULL) {
   2082          		/* Check the struct p_bma2x2 is empty */
   2083          		return E_BMA2x2_NULL_PTR;
   2084              }  else {
   2085                  /*! To reset the sensor
   2086                  0xB6 value_u8 will be written */
   2087                  com_rslt = bma2x2_write_reg(BMA2x2_RST_ADDR,
   2088                                              &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2089              }
   2090          	return com_rslt;
   2091          }
   2092          /*!
   2093          * @brief This API is used to update the register values
   2094          *
   2095          *
   2096          *
   2097          *
   2098          *  @param : None
   2099          *
   2100          *
   2101          *
   2102          *	@return results of bus communication function
   2103          *	@retval 0 -> Success
   2104          *	@retval -1 -> Error
   2105          *
   2106          *
   2107          */
   2108          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_update_image(void)
   2109          {
   2110          	/*  Variable used to return value of
   2111          	communication routine*/
   2112          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2113          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2114              
   2115          	if (p_bma2x2 == BMA2x2_NULL) {
   2116          		return  E_BMA2x2_NULL_PTR;
   2117              } else {
   2118                  /* Write the update image*/
   2119                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2120          			(p_bma2x2->dev_addr, BMA2x2_UPDATE_IMAGE_REG,
   2121                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2122                  data_u8 = BMA2x2_SET_BITSLICE
   2123          			(data_u8, BMA2x2_UPDATE_IMAGE,
   2124                       BMA2x2_GEN_READ_WRITE_LENGTH);
   2125                  com_rslt += bma2x2_write_reg(BMA2x2_UPDATE_IMAGE_REG,
   2126                                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2127              }
   2128          	return com_rslt;
   2129          }
   2130          /*!
   2131          *	@brief This API is used to get
   2132          *  interrupt enable bits of the sensor in the registers 0x16 and 0x17
   2133          *	@note It reads the flat enable, orient enable,
   2134          *	@note single tap enable, double tap enable
   2135          *	@note slope-x enable, slope-y enable, slope-z enable,
   2136          *	@note fifo watermark enable,
   2137          *	@note fifo full enable, data enable, low-g enable,
   2138          *	@note high-z enable, high-y enable
   2139          *	@note high-z enable
   2140          *
   2141          *
   2142          *
   2143          *  @param intr_type_u8: The value of interrupts
   2144          *        intr_type_u8   |   result
   2145          *       ----------------- | ------------------
   2146          *              0          | BMA2x2_LOW_G_INTR
   2147          *              1          | BMA2x2_HIGH_G_X_INTR
   2148          *              2          | BMA2x2_HIGH_G_Y_INTR
   2149          *              3          | BMA2x2_HIGH_G_Z_INTR
   2150          *              4          | BMA2x2_DATA_ENABLE
   2151          *              5          | SLOPE_X_INTR
   2152          *              6          | SLOPE_Y_INTR
   2153          *              7          | SLOPE_Z_INTR
   2154          *              8          | SINGLE_TAP_INTR
   2155          *              9          | SINGLE_TAP_INTR
   2156          *              10         | ORIENT_INT
   2157          *              11         | FLAT_INT
   2158          *
   2159          *  @param value_u8 : The value of interrupts enable
   2160          *        value_u8       |   result
   2161          *       ----------------- | ------------------
   2162          *              0x00       | INTR_DISABLE
   2163          *              0x01       | INTR_ENABLE
   2164          *
   2165          *
   2166          *
   2167          *
   2168          *	@return results of bus communication function
   2169          *	@retval 0 -> Success
   2170          *	@retval -1 -> Error
   2171          *
   2172          *
   2173          */
   2174          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_enable(u8 intr_type_u8,
   2175                                                             u8 *value_u8)
   2176          {
   2177          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2178              /*  Variable used to return value of
   2179          	communication routine*/
   2180          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2181              
   2182          	if (p_bma2x2 == BMA2x2_NULL) {
   2183          		/* Check the struct p_bma2x2 is empty */
   2184          		return E_BMA2x2_NULL_PTR;
   2185              } else {
   2186          		switch (intr_type_u8) {
   2187                    case BMA2x2_LOW_G_INTR:
   2188          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2189                          (p_bma2x2->dev_addr,
   2190                           BMA2x2_ENABLE_LOW_G_INTR_REG,
   2191                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2192          			*value_u8 = BMA2x2_GET_BITSLICE
   2193                          (data_u8, BMA2x2_ENABLE_LOW_G_INTR);
   2194                      break;
   2195                    case BMA2x2_HIGH_G_X_INTR:
   2196          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2197                          (p_bma2x2->dev_addr,
   2198                           BMA2x2_ENABLE_HIGH_G_X_INTR_REG,
   2199                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2200          			*value_u8 = BMA2x2_GET_BITSLICE
   2201                          (data_u8, BMA2x2_ENABLE_HIGH_G_X_INTR);
   2202                      break;
   2203                    case BMA2x2_HIGH_G_Y_INTR:
   2204          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2205                          (p_bma2x2->dev_addr,
   2206                           BMA2x2_ENABLE_HIGH_G_Y_INTR_REG,
   2207                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2208          			*value_u8 = BMA2x2_GET_BITSLICE
   2209                          (data_u8, BMA2x2_ENABLE_HIGH_G_Y_INTR);
   2210                      break;
   2211                    case BMA2x2_HIGH_G_Z_INTR:
   2212          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2213                          (p_bma2x2->dev_addr,
   2214                           BMA2x2_ENABLE_HIGH_G_Z_INTR_REG,
   2215                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2216          			*value_u8 = BMA2x2_GET_BITSLICE
   2217                          (data_u8, BMA2x2_ENABLE_HIGH_G_Z_INTR);
   2218                      break;
   2219                    case BMA2x2_DATA_ENABLE:
   2220          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2221                          (p_bma2x2->dev_addr,
   2222                           BMA2x2_ENABLE_NEW_DATA_INTR_REG,
   2223                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2224          			*value_u8 = BMA2x2_GET_BITSLICE
   2225                          (data_u8, BMA2x2_ENABLE_NEW_DATA_INTR);
   2226                      break;
   2227                    case BMA2x2_SLOPE_X_INTR:
   2228          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2229                          (p_bma2x2->dev_addr,
   2230                           BMA2x2_ENABLE_SLOPE_X_INTR_REG,
   2231                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2232          			*value_u8 = BMA2x2_GET_BITSLICE
   2233                          (data_u8, BMA2x2_ENABLE_SLOPE_X_INTR);
   2234                      break;
   2235                    case BMA2x2_SLOPE_Y_INTR:
   2236          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2237                          (p_bma2x2->dev_addr,
   2238                           BMA2x2_ENABLE_SLOPE_Y_INTR_REG,
   2239                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2240          			*value_u8 = BMA2x2_GET_BITSLICE
   2241                          (data_u8, BMA2x2_ENABLE_SLOPE_Y_INTR);
   2242                      break;
   2243                    case BMA2x2_SLOPE_Z_INTR:
   2244          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2245                          (p_bma2x2->dev_addr,
   2246                           BMA2x2_ENABLE_SLOPE_Z_INTR_REG,
   2247                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2248          			*value_u8 = BMA2x2_GET_BITSLICE
   2249                          (data_u8, BMA2x2_ENABLE_SLOPE_Z_INTR);
   2250                      break;
   2251                    case BMA2x2_SINGLE_TAP_INTR:
   2252          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2253                          (p_bma2x2->dev_addr,
   2254                           BMA2x2_ENABLE_SINGLE_TAP_INTR_REG,
   2255                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2256          			*value_u8 = BMA2x2_GET_BITSLICE
   2257                          (data_u8, BMA2x2_ENABLE_SINGLE_TAP_INTR);
   2258                      break;
   2259                    case BMA2x2_DOUBLE_TAP_INTR:
   2260          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2261                          (p_bma2x2->dev_addr,
   2262                           BMA2x2_ENABLE_DOUBLE_TAP_INTR_REG,
   2263                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2264          			*value_u8 = BMA2x2_GET_BITSLICE
   2265                          (data_u8, BMA2x2_ENABLE_DOUBLE_TAP_INTR);
   2266                      break;
   2267                    case BMA2x2_ORIENT_INTR:
   2268          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2269                          (p_bma2x2->dev_addr,
   2270                           BMA2x2_ENABLE_ORIENT_INTR_REG,
   2271                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2272          			*value_u8 = BMA2x2_GET_BITSLICE
   2273                          (data_u8, BMA2x2_ENABLE_ORIENT_INTR);
   2274                      break;
   2275                    case BMA2x2_FLAT_INTR:
   2276          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2277                          (p_bma2x2->dev_addr,
   2278                           BMA2x2_ENABLE_FLAT_INTR_REG,
   2279                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2280          			*value_u8 = BMA2x2_GET_BITSLICE
   2281                          (data_u8, BMA2x2_ENABLE_FLAT_INTR);
   2282                      break;
   2283                    default:
   2284                      com_rslt = E_OUT_OF_RANGE;
   2285                      break;
   2286          		}
   2287          	}
   2288          	return com_rslt;
   2289          }
   2290          /*!
   2291          *	@brief This API is used to set
   2292          *  interrupt enable bits of the sensor in the registers 0x16 and 0x17
   2293          *	@note It reads the flat enable, orient enable,
   2294          *	@note single tap enable, double tap enable
   2295          *	@note slope-x enable, slope-y enable, slope-z enable,
   2296          *	@note fifo watermark enable,
   2297          *	@note fifo full enable, data enable, low-g enable,
   2298          *	@note high-z enable, high-y enable
   2299          *	@note high-z enable
   2300          *
   2301          *
   2302          *
   2303          *  @param intr_type_u8: The value of interrupts
   2304          *        intr_type_u8   |   result
   2305          *       ----------------- | ------------------
   2306          *              0          | BMA2x2_LOW_G_INTR
   2307          *              1          | BMA2x2_HIGH_G_X_INTR
   2308          *              2          | BMA2x2_HIGH_G_Y_INTR
   2309          *              3          | BMA2x2_HIGH_G_Z_INTR
   2310          *              4          | BMA2x2_DATA_ENABLE
   2311          *              5          | SLOPE_X_INTR
   2312          *              6          | SLOPE_Y_INTR
   2313          *              7          | SLOPE_Z_INTR
   2314          *              8          | SINGLE_TAP_INTR
   2315          *              9          | SINGLE_TAP_INTR
   2316          *              10         | ORIENT_INT
   2317          *              11         | FLAT_INT
   2318          *
   2319          *  @param value_u8 : The value of interrupts enable
   2320          *        value_u8       |   result
   2321          *       ----------------- | ------------------
   2322          *              0x00       | INTR_DISABLE
   2323          *              0x01       | INTR_ENABLE
   2324          *
   2325          *
   2326          *
   2327          *
   2328          *	@return results of bus communication function
   2329          *	@retval 0 -> Success
   2330          *	@retval -1 -> Error
   2331          *
   2332          *
   2333          */
   2334          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_enable(u8 intr_type_u8,
   2335                                                             u8 value_u8)
   2336          {
   2337              /*  Variable used to return value of
   2338          	communication routine*/
   2339          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2340          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2341          	u8 data2_u8 = BMA2x2_INIT_VALUE;
   2342              
   2343          	if (p_bma2x2 == BMA2x2_NULL) {
   2344          		/* Check the struct p_bma2x2 is empty */
   2345          		return E_BMA2x2_NULL_PTR;
   2346              } else {
   2347          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2348                      (p_bma2x2->dev_addr, BMA2x2_INTR_ENABLE1_ADDR,
   2349                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2350          		com_rslt += p_bma2x2->BMA2x2_BUS_READ_FUNC
   2351                      (p_bma2x2->dev_addr, BMA2x2_INTR_ENABLE2_ADDR,
   2352                       &data2_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2353          		value_u8 = value_u8 & BMA2x2_GEN_READ_WRITE_LENGTH;
   2354          		switch (intr_type_u8) {
   2355                    case BMA2x2_LOW_G_INTR:
   2356          			/* Low G Interrupt  */
   2357          			data2_u8 = BMA2x2_SET_BITSLICE(data2_u8,
   2358                                                     BMA2x2_ENABLE_LOW_G_INTR, value_u8);
   2359                      break;
   2360                    case BMA2x2_HIGH_G_X_INTR:
   2361          			/* High G X Interrupt */
   2362          			data2_u8 = BMA2x2_SET_BITSLICE(data2_u8,
   2363                                                     BMA2x2_ENABLE_HIGH_G_X_INTR, value_u8);
   2364                      break;
   2365                    case BMA2x2_HIGH_G_Y_INTR:
   2366          			/* High G Y Interrupt */
   2367          			data2_u8 = BMA2x2_SET_BITSLICE(data2_u8,
   2368                                                     BMA2x2_ENABLE_HIGH_G_Y_INTR, value_u8);
   2369                      break;
   2370                    case BMA2x2_HIGH_G_Z_INTR:
   2371          			/* High G Z Interrupt */
   2372          			data2_u8 = BMA2x2_SET_BITSLICE(data2_u8,
   2373                                                     BMA2x2_ENABLE_HIGH_G_Z_INTR, value_u8);
   2374                      break;
   2375                    case BMA2x2_DATA_ENABLE:
   2376          			/*Data En Interrupt  */
   2377          			data2_u8 = BMA2x2_SET_BITSLICE(data2_u8,
   2378                                                     BMA2x2_ENABLE_NEW_DATA_INTR, value_u8);
   2379                      break;
   2380                    case BMA2x2_SLOPE_X_INTR:
   2381          			/* Slope X Interrupt */
   2382          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   2383                                                    BMA2x2_ENABLE_SLOPE_X_INTR, value_u8);
   2384                      break;
   2385                    case BMA2x2_SLOPE_Y_INTR:
   2386          			/* Slope Y Interrupt */
   2387          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   2388                                                    BMA2x2_ENABLE_SLOPE_Y_INTR, value_u8);
   2389                      break;
   2390                    case BMA2x2_SLOPE_Z_INTR:
   2391          			/* Slope Z Interrupt */
   2392          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   2393                                                    BMA2x2_ENABLE_SLOPE_Z_INTR, value_u8);
   2394                      break;
   2395                    case BMA2x2_SINGLE_TAP_INTR:
   2396          			/* Single Tap Interrupt */
   2397          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   2398                                                    BMA2x2_ENABLE_SINGLE_TAP_INTR, value_u8);
   2399                      break;
   2400                    case BMA2x2_DOUBLE_TAP_INTR:
   2401          			/* Double Tap Interrupt */
   2402          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   2403                                                    BMA2x2_ENABLE_DOUBLE_TAP_INTR, value_u8);
   2404                      break;
   2405                    case BMA2x2_ORIENT_INTR:
   2406          			/* Orient Interrupt  */
   2407          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   2408                                                    BMA2x2_ENABLE_ORIENT_INTR, value_u8);
   2409                      break;
   2410                    case BMA2x2_FLAT_INTR:
   2411          			/* Flat Interrupt */
   2412          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   2413                                                    BMA2x2_ENABLE_FLAT_INTR, value_u8);
   2414                      break;
   2415                    default:
   2416          			com_rslt = E_OUT_OF_RANGE;
   2417                      break;
   2418          		}
   2419          		/* write the interrupt*/
   2420          		com_rslt += bma2x2_write_reg
   2421                      (BMA2x2_INTR_ENABLE1_ADDR,
   2422                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2423          		com_rslt += bma2x2_write_reg
   2424                      (BMA2x2_INTR_ENABLE2_ADDR,
   2425                       &data2_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2426          	}
   2427          	return com_rslt;
   2428          }
   2429          /*!
   2430          *	@brief This API is used to get
   2431          *	the interrupt fifo full enable interrupt status
   2432          *	in the register 0x17 bit 5
   2433          *
   2434          *
   2435          *  @param fifo_full_u8 The value of fifo full interrupt enable
   2436          *        fifo_full_u8   |   result
   2437          *       ----------------- | ------------------
   2438          *              0x00       | INTR_DISABLE
   2439          *              0x01       | INTR_ENABLE
   2440          *
   2441          *
   2442          *
   2443          *	@return results of bus communication function
   2444          *	@retval 0 -> Success
   2445          *	@retval -1 -> Error
   2446          *
   2447          *
   2448          */
   2449          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_fifo_full(u8 *fifo_full_u8)
   2450          {
   2451          	/*  Variable used to return value of
   2452          	communication routine*/
   2453          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2454          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2455              
   2456          	if (p_bma2x2 == BMA2x2_NULL) {
   2457          		/* Check the struct p_bma2x2 is empty */
   2458          		return E_BMA2x2_NULL_PTR;
   2459              } else {
   2460                  /* Read fifo full interrupt */
   2461                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2462          			(p_bma2x2->dev_addr,
   2463                       BMA2x2_INTR_FIFO_FULL_ENABLE_INTR_REG,
   2464                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2465                  *fifo_full_u8 = BMA2x2_GET_BITSLICE(data_u8,
   2466                                                      BMA2x2_INTR_FIFO_FULL_ENABLE_INTR);
   2467              }
   2468          	return com_rslt;
   2469          }
   2470          /*!
   2471          *	@brief This API is used to set
   2472          *	the interrupt fifo full enable interrupt status
   2473          *	in the register 0x17 bit 5
   2474          *
   2475          *
   2476          *  @param fifo_full_u8 The value of fifo full interrupt enable
   2477          *        fifo_full_u8   |   result
   2478          *       ----------------- | ------------------
   2479          *              0x00       | INTR_DISABLE
   2480          *              0x01       | INTR_ENABLE
   2481          *
   2482          *
   2483          *
   2484          *	@return results of bus communication function
   2485          *	@retval 0 -> Success
   2486          *	@retval -1 -> Error
   2487          *
   2488          *
   2489          */
   2490          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_fifo_full(u8 fifo_full_u8)
   2491          {
   2492          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2493              /*  Variable used to return value of
   2494          	communication routine*/
   2495          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2496              
   2497          	if (p_bma2x2 == BMA2x2_NULL) {
   2498          		/* Check the struct p_bma2x2 is empty */
   2499          		return E_BMA2x2_NULL_PTR;
   2500              } else {
   2501          		if (fifo_full_u8 < BMA2x2_FIFO_MODE_STATUS_RANGE) {
   2502          			/* Write fifo full interrupt */
   2503          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2504                          (p_bma2x2->dev_addr,
   2505                           BMA2x2_INTR_FIFO_FULL_ENABLE_INTR_REG,
   2506                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2507          			data_u8 = BMA2x2_SET_BITSLICE
   2508                          (data_u8, BMA2x2_INTR_FIFO_FULL_ENABLE_INTR,
   2509                           fifo_full_u8);
   2510          			com_rslt += bma2x2_write_reg(
   2511                                                   BMA2x2_INTR_FIFO_FULL_ENABLE_INTR_REG,
   2512                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2513          		} else {
   2514                      com_rslt = E_OUT_OF_RANGE;
   2515          		}
   2516          	}
   2517          	return com_rslt;
   2518          }
   2519          /*!
   2520          * @brief This API is used to get
   2521          *	the interrupt fifo watermark enable interrupt status
   2522          *	in the register 0x17 bit 6
   2523          *
   2524          *
   2525          *
   2526          *
   2527          *  @param fifo_wm_u8 : the value FIFO Water Mark
   2528          *        fifo_wm_u8     |   result
   2529          *       ----------------- | ------------------
   2530          *              0x00       | INTR_DISABLE
   2531          *              0x01       | INTR_ENABLE
   2532          *
   2533          *
   2534          *
   2535          *	@return results of bus communication function
   2536          *	@retval 0 -> Success
   2537          *	@retval -1 -> Error
   2538          *
   2539          *
   2540          */
   2541          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_fifo_wm(u8 *fifo_wm_u8)
   2542          {
   2543          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2544              /*  Variable used to return value of
   2545          	communication routine*/
   2546          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2547              
   2548          	if (p_bma2x2 == BMA2x2_NULL) {
   2549          		/* Check the struct p_bma2x2 is empty */
   2550          		return E_BMA2x2_NULL_PTR;
   2551              } else {
   2552                  /* Read the fifo water mark*/
   2553                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2554          			(p_bma2x2->dev_addr,
   2555                       BMA2x2_INTR_FIFO_WM_ENABLE_INTR_REG,
   2556                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2557                  *fifo_wm_u8 = BMA2x2_GET_BITSLICE
   2558          			(data_u8, BMA2x2_INTR_FIFO_WM_ENABLE_INTR);
   2559              }
   2560          	return com_rslt;
   2561          }
   2562          /*!
   2563          * @brief This API is used to set
   2564          *	the interrupt fifo watermark enable interrupt status
   2565          *	in the register 0x17 bit 6
   2566          *
   2567          *
   2568          *
   2569          *
   2570          *  @param fifo_wm_u8 : the value FIFO Water Mark
   2571          *        fifo_wm_u8     |   result
   2572          *       ----------------- | ------------------
   2573          *              0x00       | INTR_DISABLE
   2574          *              0x01       | INTR_ENABLE
   2575          *
   2576          *
   2577          *
   2578          *	@return results of bus communication function
   2579          *	@retval 0 -> Success
   2580          *	@retval -1 -> Error
   2581          *
   2582          *
   2583          */
   2584          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_fifo_wm(u8 fifo_wm_u8)
   2585          {
   2586          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2587              /*  Variable used to return value of
   2588          	communication routine*/
   2589          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2590              
   2591          	if (p_bma2x2 == BMA2x2_NULL) {
   2592          		/* Check the struct p_bma2x2 is empty */
   2593          		return E_BMA2x2_NULL_PTR;
   2594              } else {
   2595          		if (fifo_wm_u8 < BMA2x2_FIFO_MODE_STATUS_RANGE) {
   2596          			/* Write the fifo water mark interrupt*/
   2597          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2598                          (p_bma2x2->dev_addr,
   2599                           BMA2x2_INTR_FIFO_WM_ENABLE_INTR_REG,
   2600                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2601          			data_u8 = BMA2x2_SET_BITSLICE
   2602                          (data_u8, BMA2x2_INTR_FIFO_WM_ENABLE_INTR,
   2603                           fifo_wm_u8);
   2604          			com_rslt += bma2x2_write_reg(
   2605                                                   BMA2x2_INTR_FIFO_WM_ENABLE_INTR_REG,
   2606                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2607          		} else {
   2608                      com_rslt = E_OUT_OF_RANGE;
   2609          		}
   2610          	}
   2611          	return com_rslt;
   2612          }
   2613          /*!
   2614          * @brief This API is used to get
   2615          * the interrupt status of slow/no motion select and slow no motion
   2616          * enable xyz interrupt in the register 0x18 bit from 0 to 3
   2617          *
   2618          *
   2619          *  @param  channel_u8 : The value of slow/no motion select
   2620          *        channel_u8     |   result
   2621          *       ----------------- | ------------------
   2622          *              0          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_X
   2623          *              1          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_Y
   2624          *              2          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_Z
   2625          *              3          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_SEL
   2626          *
   2627          *	@param slow_no_motion_u8 : The value of slow no motion interrupt enable
   2628          *        slow_no_motion_u8     |   result
   2629          *       ------------------------ | ------------------
   2630          *              0x00              | INTR_DISABLE
   2631          *              0x01              | INTR_ENABLE
   2632          *
   2633          *
   2634          *	@return results of bus communication function
   2635          *	@retval 0 -> Success
   2636          *	@retval -1 -> Error
   2637          *
   2638          *
   2639          */
   2640          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_slow_no_motion(u8 channel_u8,
   2641                                                                u8 *slow_no_motion_u8)
   2642          {
   2643          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2644              /*  Variable used to return value of
   2645          	communication routine*/
   2646          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2647              
   2648          	if (p_bma2x2 == BMA2x2_NULL) {
   2649          		/* Check the struct p_bma2x2 is empty */
   2650          		return E_BMA2x2_NULL_PTR;
   2651              } else {
   2652          		/* Read the slow no motion interrupt */
   2653          		switch (channel_u8) {
   2654                    case BMA2x2_SLOW_NO_MOTION_ENABLE_X:
   2655          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2656                          (p_bma2x2->dev_addr,
   2657                           BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_X_INTR_REG,
   2658                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2659          			*slow_no_motion_u8 = BMA2x2_GET_BITSLICE
   2660                          (data_u8, BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_X_INTR);
   2661                      break;
   2662                    case BMA2x2_SLOW_NO_MOTION_ENABLE_Y:
   2663          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2664                          (p_bma2x2->dev_addr,
   2665                           BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Y_INTR_REG,
   2666                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2667          			*slow_no_motion_u8 = BMA2x2_GET_BITSLICE
   2668                          (data_u8, BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Y_INTR);
   2669                      break;
   2670                    case BMA2x2_SLOW_NO_MOTION_ENABLE_Z:
   2671          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2672                          (p_bma2x2->dev_addr,
   2673                           BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Z_INTR_REG,
   2674                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2675          			*slow_no_motion_u8 = BMA2x2_GET_BITSLICE
   2676                          (data_u8, BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Z_INTR);
   2677                      break;
   2678                    case BMA2x2_SLOW_NO_MOTION_ENABLE_SELECT:
   2679          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2680                          (p_bma2x2->dev_addr,
   2681                           BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_SELECT_INTR_REG,
   2682                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2683          			*slow_no_motion_u8 = BMA2x2_GET_BITSLICE
   2684                          (data_u8,
   2685                           BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_SELECT_INTR);
   2686                      break;
   2687                    default:
   2688          			com_rslt = E_OUT_OF_RANGE;
   2689                      break;
   2690          		}
   2691          	}
   2692          	return com_rslt;
   2693          }
   2694          /*!
   2695          * @brief This API is used to set
   2696          * the interrupt status of slow/no motion select and slow no motion
   2697          * enable xyz interrupt in the register 0x18 bit from 0 to 3
   2698          *
   2699          *
   2700          *  @param  channel_u8 : The value of slow/no motion select
   2701          *        channel_u8     |   result
   2702          *       ----------------- | ------------------
   2703          *              0          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_X
   2704          *              1          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_Y
   2705          *              2          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_Z
   2706          *              3          | BMA2x2_ACCEL_SLOW_NO_MOTION_ENABLE_SEL
   2707          *
   2708          *	@param slow_no_motion_u8 : The value of slow no motion
   2709          *      interrupt enable
   2710          *        slow_no_motion_u8     |   result
   2711          *       ------------------------ | ------------------
   2712          *              0x00              | INTR_DISABLE
   2713          *              0x01              | INTR_ENABLE
   2714          *
   2715          *
   2716          *	@return results of bus communication function
   2717          *	@retval 0 -> Success
   2718          *	@retval -1 -> Error
   2719          *
   2720          *
   2721          */
   2722          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_slow_no_motion(u8 channel_u8,
   2723                                                                u8 slow_no_motion_u8)
   2724          {
   2725          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2726              /*  Variable used to return value of
   2727          	communication routine*/
   2728          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2729              
   2730          	if (p_bma2x2 == BMA2x2_NULL) {
   2731          		/* Check the struct p_bma2x2 is empty */
   2732          		return E_BMA2x2_NULL_PTR;
   2733              } else {
   2734          		/* Write the slow no motion interrupt*/
   2735          		switch (channel_u8) {
   2736                    case BMA2x2_SLOW_NO_MOTION_ENABLE_X:
   2737          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2738                          (p_bma2x2->dev_addr,
   2739                           BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_X_INTR_REG,
   2740                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2741          			data_u8 = BMA2x2_SET_BITSLICE
   2742                          (data_u8,
   2743                           BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_X_INTR,
   2744                           slow_no_motion_u8);
   2745          			com_rslt += bma2x2_write_reg(
   2746                                                   BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_X_INTR_REG,
   2747                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2748                      break;
   2749                    case BMA2x2_SLOW_NO_MOTION_ENABLE_Y:
   2750          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2751                          (p_bma2x2->dev_addr,
   2752                           BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Y_INTR_REG,
   2753                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2754          			data_u8 = BMA2x2_SET_BITSLICE
   2755                          (data_u8,
   2756                           BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Y_INTR,
   2757                           slow_no_motion_u8);
   2758          			com_rslt += bma2x2_write_reg(
   2759                                                   BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Y_INTR_REG,
   2760                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2761                      break;
   2762                    case BMA2x2_SLOW_NO_MOTION_ENABLE_Z:
   2763          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2764                          (p_bma2x2->dev_addr,
   2765                           BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Z_INTR_REG,
   2766                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2767          			data_u8 = BMA2x2_SET_BITSLICE
   2768                          (data_u8,
   2769                           BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Z_INTR,
   2770                           slow_no_motion_u8);
   2771          			com_rslt += bma2x2_write_reg(
   2772                                                   BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_Z_INTR_REG,
   2773                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2774                      break;
   2775                    case BMA2x2_SLOW_NO_MOTION_ENABLE_SELECT:
   2776          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2777                          (p_bma2x2->dev_addr,
   2778                           BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_SELECT_INTR_REG,
   2779                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2780          			data_u8 = BMA2x2_SET_BITSLICE
   2781                          (data_u8,
   2782                           BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_SELECT_INTR,
   2783                           slow_no_motion_u8);
   2784          			com_rslt += bma2x2_write_reg(
   2785                                                   BMA2x2_INTR_SLOW_NO_MOTION_ENABLE_SELECT_INTR_REG,
   2786                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2787                      break;
   2788                    default:
   2789          			com_rslt = E_OUT_OF_RANGE;
   2790                      break;
   2791          		}
   2792          	}
   2793          	return com_rslt;
   2794          }
   2795          /*!
   2796          * @brief  This API is used to get
   2797          * the interrupt enable of low_g interrupt in the register 0x19 and 0x1B
   2798          * @note INTR1_Low_g -> register 0x19 bit 0
   2799          * @note INTR2_Low_g -> register 0x1B bit 0
   2800          *
   2801          *
   2802          *
   2803          *
   2804          * @param channel_u8 : The value of low interrupt selection channel
   2805          *        channel_u8     |   result
   2806          *       ----------------- | ------------------
   2807          *              0          | BMA2x2_ACCEL_INTR1_LOW_G
   2808          *              1          | BMA2x2_ACCEL_INTR2_LOW_G
   2809          *
   2810          * @param intr_low_g_u8 : the value of low_g interrupt
   2811          *        intr_low_u8           |   result
   2812          *       ------------------------ | ------------------
   2813          *              0x00              | INTR_DISABLE
   2814          *              0x01              | INTR_ENABLE
   2815          *
   2816          *
   2817          *
   2818          *	@return results of bus communication function
   2819          *	@retval 0 -> Success
   2820          *	@retval -1 -> Error
   2821          *
   2822          *
   2823          */
   2824          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_low_g(u8 channel_u8,
   2825                                                            u8 *intr_low_g_u8)
   2826          {
   2827          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2828          	/*  Variable used to return value of
   2829          	communication routine*/
   2830          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2831              
   2832          	if (p_bma2x2 == BMA2x2_NULL) {
   2833          		/* Check the struct p_bma2x2 is empty */
   2834          		return E_BMA2x2_NULL_PTR;
   2835              } else {
   2836          		switch (channel_u8) {
   2837                      /* Read the low_g interrupt*/
   2838                    case BMA2x2_INTR1_LOW_G:
   2839          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2840                          (p_bma2x2->dev_addr,
   2841                           BMA2x2_ENABLE_INTR1_PAD_LOW_G_REG,
   2842                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2843          			*intr_low_g_u8 = BMA2x2_GET_BITSLICE
   2844                          (data_u8, BMA2x2_ENABLE_INTR1_PAD_LOW_G);
   2845                      break;
   2846                    case BMA2x2_INTR2_LOW_G:
   2847          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2848                          (p_bma2x2->dev_addr,
   2849                           BMA2x2_ENABLE_INTR2_PAD_LOW_G_REG,
   2850                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2851          			*intr_low_g_u8 = BMA2x2_GET_BITSLICE
   2852                          (data_u8, BMA2x2_ENABLE_INTR2_PAD_LOW_G);
   2853                      break;
   2854                    default:
   2855          			com_rslt = E_OUT_OF_RANGE;
   2856                      break;
   2857          		}
   2858          	}
   2859          	return com_rslt;
   2860          }
   2861          /*!
   2862          * @brief  This API is used to set
   2863          * the interrupt enable of low_g interrupt in the register 0x19 and 0x1B
   2864          * @note INTR1_Low_g -> register 0x19 bit 0
   2865          * @note INTR2_Low_g -> register 0x1B bit 0
   2866          *
   2867          *
   2868          *
   2869          *
   2870          * @param channel_u8 : The value of low interrupt selection channel
   2871          *        channel_u8     |   result
   2872          *       ----------------- | ------------------
   2873          *              0          | BMA2x2_ACCEL_INTR1_LOW_G
   2874          *              1          | BMA2x2_ACCEL_INTR2_LOW_G
   2875          *
   2876          * @param intr_low_u8 : the value of low_g interrupt
   2877          *        intr_low_u8           |   result
   2878          *       ------------------------ | ------------------
   2879          *              0x00              | INTR_DISABLE
   2880          *              0x01              | INTR_ENABLE
   2881          *
   2882          *
   2883          *
   2884          *	@return results of bus communication function
   2885          *	@retval 0 -> Success
   2886          *	@retval -1 -> Error
   2887          *
   2888          *
   2889          */
   2890          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_low_g(u8 channel_u8,
   2891                                                            u8 intr_low_u8)
   2892          {
   2893          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2894              /*  Variable used to return value of
   2895          	communication routine*/
   2896          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2897              
   2898          	if (p_bma2x2 == BMA2x2_NULL) {
   2899          		/* Check the struct p_bma2x2 is empty */
   2900          		return E_BMA2x2_NULL_PTR;
   2901              } else {
   2902          		switch (channel_u8) {
   2903                    case BMA2x2_INTR1_LOW_G:
   2904          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2905                          (p_bma2x2->dev_addr,
   2906                           BMA2x2_ENABLE_INTR1_PAD_LOW_G_REG,
   2907                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2908          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   2909                                                    BMA2x2_ENABLE_INTR1_PAD_LOW_G, intr_low_u8);
   2910          			com_rslt += bma2x2_write_reg(
   2911                                                   BMA2x2_ENABLE_INTR1_PAD_LOW_G_REG,
   2912                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2913                      break;
   2914                    case BMA2x2_INTR2_LOW_G:
   2915          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2916                          (p_bma2x2->dev_addr,
   2917                           BMA2x2_ENABLE_INTR2_PAD_LOW_G_REG,
   2918                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2919          			data_u8 = BMA2x2_SET_BITSLICE
   2920                          (data_u8, BMA2x2_ENABLE_INTR2_PAD_LOW_G,
   2921                           intr_low_u8);
   2922          			com_rslt += bma2x2_write_reg(
   2923                                                   BMA2x2_ENABLE_INTR2_PAD_LOW_G_REG,
   2924                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2925                      break;
   2926                    default:
   2927          			com_rslt = E_OUT_OF_RANGE;
   2928                      break;
   2929          		}
   2930          	}
   2931          	return com_rslt;
   2932          }
   2933          /*!
   2934          * @brief This API is used to get
   2935          * the interrupt enable of high_g interrupt in the register 0x19 and 0x1B
   2936          * @note INTR1_high_g -> register 0x19 bit 1
   2937          * @note INTR2_high_g -> register 0x1B bit 1
   2938          *
   2939          *
   2940          *  @param  channel_u8: The value of high_g interrupt selection
   2941          *        channel_u8     |   result
   2942          *       ----------------- | ------------------
   2943          *              0          | BMA2x2_ACCEL_INTR1_HIGH_G
   2944          *              1          | BMA2x2_ACCEL_INTR2_HIGH_G
   2945          *
   2946          * @param intr_high_g_u8 : the value of high_g interrupt
   2947          *        intr_high_g_u8        |   result
   2948          *       ------------------------ | ------------------
   2949          *              0x00              | INTR_DISABLE
   2950          *              0x01              | INTR_ENABLE
   2951          *
   2952          *
   2953          *	@return results of bus communication function
   2954          *	@retval 0 -> Success
   2955          *	@retval -1 -> Error
   2956          *
   2957          *
   2958          */
   2959          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_high_g(u8 channel_u8,
   2960                                                             u8 *intr_high_g_u8)
   2961          {
   2962          	u8 data_u8 = BMA2x2_INIT_VALUE;
   2963          	/*  Variable used to return value of
   2964          	communication routine*/
   2965          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   2966              
   2967          	if (p_bma2x2 == BMA2x2_NULL) {
   2968          		/* Check the struct p_bma2x2 is empty */
   2969          		return E_BMA2x2_NULL_PTR;
   2970              } else {
   2971          		switch (channel_u8) {
   2972                      /* read the high_g interrupt*/
   2973                    case BMA2x2_INTR1_HIGH_G:
   2974          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2975                          (p_bma2x2->dev_addr,
   2976                           BMA2x2_ENABLE_INTR1_PAD_HIGH_G_REG,
   2977                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2978          			*intr_high_g_u8 = BMA2x2_GET_BITSLICE
   2979                          (data_u8, BMA2x2_ENABLE_INTR1_PAD_HIGH_G);
   2980                      break;
   2981                    case BMA2x2_INTR2_HIGH_G:
   2982          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   2983                          (p_bma2x2->dev_addr,
   2984                           BMA2x2_ENABLE_INTR2_PAD_HIGH_G_REG,
   2985                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   2986          			*intr_high_g_u8 = BMA2x2_GET_BITSLICE
   2987                          (data_u8, BMA2x2_ENABLE_INTR2_PAD_HIGH_G);
   2988                      break;
   2989                    default:
   2990                      com_rslt = E_OUT_OF_RANGE;
   2991                      break;
   2992          		}
   2993          	}
   2994          	return com_rslt;
   2995          }
   2996          /*!
   2997          * @brief This API is used to set
   2998          * the interrupt enable of high_g interrupt in the register 0x19 and 0x1B
   2999          * @note INTR1_high_g -> register 0x19 bit 1
   3000          * @note INTR2_high_g -> register 0x1B bit 1
   3001          *
   3002          *
   3003          *  @param  channel_u8: The value of high_g interrupt selection
   3004          *        channel_u8     |   result
   3005          *       ----------------- | ------------------
   3006          *              0          | BMA2x2_ACCEL_INTR1_HIGH_G
   3007          *              1          | BMA2x2_ACCEL_INTR2_HIGH_G
   3008          *
   3009          * @param intr_high_g_u8 : the value of high_g interrupt
   3010          *        intr_high_g_u8        |   result
   3011          *       ------------------------ | ------------------
   3012          *              0x00              | INTR_DISABLE
   3013          *              0x01              | INTR_ENABLE
   3014          *
   3015          *
   3016          *	@return results of bus communication function
   3017          *	@retval 0 -> Success
   3018          *	@retval -1 -> Error
   3019          *
   3020          *
   3021          */
   3022          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_high_g(u8 channel_u8,
   3023                                                             u8 intr_high_g_u8)
   3024          {
   3025          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3026          	/*  Variable used to return value of
   3027          	communication routine*/
   3028          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3029              
   3030          	if (p_bma2x2 == BMA2x2_NULL) {
   3031          		/* Check the struct p_bma2x2 is empty */
   3032          		return E_BMA2x2_NULL_PTR;
   3033              } else {
   3034          		/* write the high_g interrupt*/
   3035          		switch (channel_u8) {
   3036                    case BMA2x2_INTR1_HIGH_G:
   3037          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3038                          (p_bma2x2->dev_addr,
   3039                           BMA2x2_ENABLE_INTR1_PAD_HIGH_G_REG,
   3040                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3041          			data_u8 = BMA2x2_SET_BITSLICE
   3042                          (data_u8, BMA2x2_ENABLE_INTR1_PAD_HIGH_G,
   3043                           intr_high_g_u8);
   3044          			com_rslt += bma2x2_write_reg(
   3045                                                   BMA2x2_ENABLE_INTR1_PAD_HIGH_G_REG,
   3046                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3047                      break;
   3048                    case BMA2x2_INTR2_HIGH_G:
   3049          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3050                          (p_bma2x2->dev_addr,
   3051                           BMA2x2_ENABLE_INTR2_PAD_HIGH_G_REG,
   3052                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3053          			data_u8 = BMA2x2_SET_BITSLICE
   3054                          (data_u8, BMA2x2_ENABLE_INTR2_PAD_HIGH_G,
   3055                           intr_high_g_u8);
   3056          			com_rslt += bma2x2_write_reg(
   3057                                                   BMA2x2_ENABLE_INTR2_PAD_HIGH_G_REG,
   3058                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3059                      break;
   3060                    default:
   3061                      com_rslt = E_OUT_OF_RANGE;
   3062                      break;
   3063          		}
   3064          	}
   3065          	return com_rslt;
   3066          }
   3067          /*!
   3068          * @brief This API is used to get
   3069          * the interrupt enable of slope interrupt in the register 0x19 and 0x1B
   3070          * @note INTR1_slope -> register 0x19 bit 2
   3071          * @note INTR2_slope -> register 0x1B bit 2
   3072          *
   3073          *
   3074          *
   3075          * @param channel_u8: the value of slope channel select
   3076          *        channel_u8     |   result
   3077          *       ----------------- | ------------------
   3078          *              0          | BMA2x2_ACCEL_INTR1_SLOPE
   3079          *              1          | BMA2x2_ACCEL_INTR2_SLOPE
   3080          *
   3081          * @param intr_slope_u8 : The slope value enable value
   3082          *        intr_slope_u8         |   result
   3083          *       ------------------------ | ------------------
   3084          *              0x00              | INTR_DISABLE
   3085          *              0x01              | INTR_ENABLE
   3086          *
   3087          *
   3088          *
   3089          *	@return results of bus communication function
   3090          *	@retval 0 -> Success
   3091          *	@retval -1 -> Error
   3092          *
   3093          *
   3094          */
   3095          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_slope(u8 channel_u8,
   3096                                                            u8 *intr_slope_u8)
   3097          {
   3098          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3099              /*  Variable used to return value of
   3100          	communication routine*/
   3101          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3102              
   3103          	if (p_bma2x2 == BMA2x2_NULL) {
   3104          		/* Check the struct p_bma2x2 is empty */
   3105          		return E_BMA2x2_NULL_PTR;
   3106              } else {
   3107          		/* Read the slope value */
   3108          		switch (channel_u8) {
   3109                    case BMA2x2_INTR1_SLOPE:
   3110          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3111                          (p_bma2x2->dev_addr,
   3112                           BMA2x2_ENABLE_INTR1_PAD_SLOPE_REG,
   3113                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3114          			*intr_slope_u8 = BMA2x2_GET_BITSLICE
   3115                          (data_u8, BMA2x2_ENABLE_INTR1_PAD_SLOPE);
   3116                      break;
   3117                    case BMA2x2_INTR2_SLOPE:
   3118          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3119                          (p_bma2x2->dev_addr,
   3120                           BMA2x2_ENABLE_INTR2_PAD_SLOPE_REG,
   3121                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3122          			*intr_slope_u8 = BMA2x2_GET_BITSLICE
   3123                          (data_u8, BMA2x2_ENABLE_INTR2_PAD_SLOPE);
   3124                      break;
   3125                    default:
   3126                      com_rslt = E_OUT_OF_RANGE;
   3127                      break;
   3128          		}
   3129          	}
   3130          	return com_rslt;
   3131          }
   3132          /*!
   3133          * @brief This API is used to set
   3134          * the interrupt enable of slope interrupt in the register 0x19 and 0x1B
   3135          * @note INTR1_slope -> register 0x19 bit 2
   3136          * @note INTR2_slope -> register 0x1B bit 2
   3137          *
   3138          *
   3139          *
   3140          * @param channel_u8: the value of slope channel select
   3141          *        channel_u8     |   result
   3142          *       ----------------- | ------------------
   3143          *              0          | BMA2x2_ACCEL_INTR1_SLOPE
   3144          *              1          | BMA2x2_ACCEL_INTR2_SLOPE
   3145          *
   3146          * @param intr_slope_u8 : The slope value enable value
   3147          *        intr_slope_u8         |   result
   3148          *       ------------------------ | ------------------
   3149          *              0x00              | INTR_DISABLE
   3150          *              0x01              | INTR_ENABLE
   3151          *
   3152          *
   3153          *
   3154          *	@return results of bus communication function
   3155          *	@retval 0 -> Success
   3156          *	@retval -1 -> Error
   3157          *
   3158          *
   3159          */
   3160          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_slope(u8 channel_u8,
   3161                                                            u8 intr_slope_u8)
   3162          {
   3163          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3164              /*  Variable used to return value of
   3165          	communication routine*/
   3166          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3167              
   3168          	if (p_bma2x2 == BMA2x2_NULL) {
   3169          		/* Check the struct p_bma2x2 is empty */
   3170          		return E_BMA2x2_NULL_PTR;
   3171              } else {
   3172          		switch (channel_u8) {
   3173                      /* Write the slope value */
   3174                    case BMA2x2_INTR1_SLOPE:
   3175          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3176                          (p_bma2x2->dev_addr,
   3177                           BMA2x2_ENABLE_INTR1_PAD_SLOPE_REG,
   3178                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3179          			data_u8 = BMA2x2_SET_BITSLICE
   3180                          (data_u8, BMA2x2_ENABLE_INTR1_PAD_SLOPE,
   3181                           intr_slope_u8);
   3182          			com_rslt += bma2x2_write_reg(
   3183                                                   BMA2x2_ENABLE_INTR1_PAD_SLOPE_REG,
   3184                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3185                      break;
   3186                    case BMA2x2_INTR2_SLOPE:
   3187          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3188                          (p_bma2x2->dev_addr,
   3189                           BMA2x2_ENABLE_INTR2_PAD_SLOPE_REG,
   3190                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3191          			data_u8 = BMA2x2_SET_BITSLICE
   3192                          (data_u8, BMA2x2_ENABLE_INTR2_PAD_SLOPE,
   3193                           intr_slope_u8);
   3194          			com_rslt += bma2x2_write_reg(
   3195                                                   BMA2x2_ENABLE_INTR2_PAD_SLOPE_REG,
   3196                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3197                      break;
   3198                    default:
   3199          			com_rslt = E_OUT_OF_RANGE;
   3200                      break;
   3201          		}
   3202          	}
   3203          	return com_rslt;
   3204          }
   3205          /*!
   3206          * @brief This API is used to get
   3207          * the interrupt enable of slow/no motion interrupt in
   3208          * the register 0x19 and 0x1B
   3209          * @note INTR1_slow_no_motion -> register 0x19 bit 3
   3210          * @note INTR2_slow_no_motion -> register 0x1B bit 3
   3211          *
   3212          *
   3213          *
   3214          *
   3215          *  @param channel_u8 : The value of slow/no motion selection
   3216          *        channel_u8     |   result
   3217          *       ----------------- | ------------------
   3218          *              0          | BMA2x2_INTR1_SLOW_NO_MOTION
   3219          *              1          | BMA2x2_INTR2_SLOW_NO_MOTION
   3220          *
   3221          *  @param intr_slow_no_motion_u8:  the slow_no_motion enable value
   3222          *       intr_slow_no_motion_u8 |   result
   3223          *       ------------------------ | ------------------
   3224          *              0x00              | INTR_DISABLE
   3225          *              0x01              | INTR_ENABLE
   3226          *
   3227          *
   3228          *	@return results of bus communication function
   3229          *	@retval 0 -> Success
   3230          *	@retval -1 -> Error
   3231          *
   3232          *
   3233          */
   3234          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_slow_no_motion(u8 channel_u8,
   3235                                                                     u8 *intr_slow_no_motion_u8)
   3236          {
   3237          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3238              /*  Variable used to return value of
   3239          	communication routine*/
   3240          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3241              
   3242          	if (p_bma2x2 == BMA2x2_NULL) {
   3243          		/* Check the struct p_bma2x2 is empty */
   3244          		return E_BMA2x2_NULL_PTR;
   3245              } else {
   3246          		/* Read the slow no motion interrupt */
   3247          		switch (channel_u8) {
   3248                    case BMA2x2_INTR1_SLOW_NO_MOTION:
   3249          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3250                          (p_bma2x2->dev_addr,
   3251                           BMA2x2_ENABLE_INTR1_PAD_SLOW_NO_MOTION_REG,
   3252                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3253          			*intr_slow_no_motion_u8 = BMA2x2_GET_BITSLICE
   3254                          (data_u8, BMA2x2_ENABLE_INTR1_PAD_SLOW_NO_MOTION);
   3255                      break;
   3256                    case BMA2x2_INTR2_SLOW_NO_MOTION:
   3257          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3258                          (p_bma2x2->dev_addr,
   3259                           BMA2x2_ENABLE_INTR2_PAD_SLOW_NO_MOTION_REG,
   3260                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3261          			*intr_slow_no_motion_u8 = BMA2x2_GET_BITSLICE
   3262                          (data_u8, BMA2x2_ENABLE_INTR2_PAD_SLOW_NO_MOTION);
   3263                      break;
   3264                    default:
   3265          			com_rslt = E_OUT_OF_RANGE;
   3266                      break;
   3267          		}
   3268          	}
   3269          	return com_rslt;
   3270          }
   3271          /*!
   3272          * @brief This API is used to set
   3273          * the interrupt enable of slow/no motion interrupt in
   3274          * the register 0x19 and 0x1B
   3275          * @note INTR1_slow_no_motion -> register 0x19 bit 3
   3276          * @note INTR2_slow_no_motion -> register 0x1B bit 3
   3277          *
   3278          *
   3279          *
   3280          *
   3281          *  @param channel_u8 : The value of slow/no motion selection
   3282          *        channel_u8     |   result
   3283          *       ----------------- | ------------------
   3284          *              0          | BMA2x2_INTR1_SLOW_NO_MOTION
   3285          *              1          | BMA2x2_INTR2_SLOW_NO_MOTION
   3286          *
   3287          *  @param intr_slow_no_motion_u8:  the slow_no_motion enable value
   3288          *       intr_slow_no_motion_u8 |   result
   3289          *       ------------------------ | ------------------
   3290          *              0x00              | INTR_DISABLE
   3291          *              0x01              | INTR_ENABLE
   3292          *
   3293          *
   3294          *	@return results of bus communication function
   3295          *	@retval 0 -> Success
   3296          *	@retval -1 -> Error
   3297          *
   3298          *
   3299          */
   3300          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_slow_no_motion(u8 channel_u8,
   3301                                                                     u8 intr_slow_no_motion_u8)
   3302          {
   3303          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3304          	/*  Variable used to return value of
   3305          	communication routine*/
   3306          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3307              
   3308          	if (p_bma2x2 == BMA2x2_NULL) {
   3309          		/* Check the struct p_bma2x2 is empty */
   3310          		return E_BMA2x2_NULL_PTR;
   3311              } else {
   3312          		switch (channel_u8) {
   3313                      /* Write the slow no motion interrupt */
   3314                    case BMA2x2_INTR1_SLOW_NO_MOTION:
   3315          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3316                          (p_bma2x2->dev_addr,
   3317                           BMA2x2_ENABLE_INTR1_PAD_SLOW_NO_MOTION_REG,
   3318                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3319          			data_u8 = BMA2x2_SET_BITSLICE
   3320                          (data_u8,
   3321                           BMA2x2_ENABLE_INTR1_PAD_SLOW_NO_MOTION,
   3322                           intr_slow_no_motion_u8);
   3323          			com_rslt += bma2x2_write_reg(
   3324                                                   BMA2x2_ENABLE_INTR1_PAD_SLOW_NO_MOTION_REG,
   3325                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3326                      break;
   3327                    case BMA2x2_INTR2_SLOW_NO_MOTION:
   3328          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3329                          (p_bma2x2->dev_addr,
   3330                           BMA2x2_ENABLE_INTR2_PAD_SLOW_NO_MOTION_REG,
   3331                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3332          			data_u8 = BMA2x2_SET_BITSLICE
   3333                          (data_u8,
   3334                           BMA2x2_ENABLE_INTR2_PAD_SLOW_NO_MOTION,
   3335                           intr_slow_no_motion_u8);
   3336          			com_rslt += bma2x2_write_reg(
   3337                                                   BMA2x2_ENABLE_INTR2_PAD_SLOW_NO_MOTION_REG,
   3338                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3339                      break;
   3340                    default:
   3341          			com_rslt = E_OUT_OF_RANGE;
   3342                      break;
   3343          		}
   3344          	}
   3345          	return com_rslt;
   3346          }
   3347          /*!
   3348          * @brief This API is used to get
   3349          * the interrupt enable of double tap interrupt
   3350          * in the register 0x19 and 0x1B
   3351          * @note INTR1_double -> register 0x19 bit 4
   3352          * @note INTR2_double -> register 0x1B bit 4
   3353          *
   3354          *
   3355          *
   3356          *
   3357          *  @param channel_u8: The value of double tap selection
   3358          *        channel_u8     |   result
   3359          *       ----------------- | ------------------
   3360          *              0          | BMA2x2_ACCEL_INTR1_DOUBLE_TAP
   3361          *              1          | BMA2x2_ACCEL_INTR2_DOUBLE_TAP
   3362          *
   3363          *	@param intr_double_tap_u8: The double tap interrupt enable value
   3364          *       intr_double_tap_u8     |   result
   3365          *       ------------------------ | ------------------
   3366          *              0x00              | INTR_DISABLE
   3367          *              0x01              | INTR_ENABLE
   3368          *
   3369          *	@return results of bus communication function
   3370          *	@retval 0 -> Success
   3371          *	@retval -1 -> Error
   3372          *
   3373          *
   3374          */
   3375          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_double_tap(u8 channel_u8,
   3376                                                                 u8 *intr_double_tap_u8)
   3377          {
   3378          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3379              /*  Variable used to return value of
   3380          	communication routine*/
   3381          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3382              
   3383          	if (p_bma2x2 == BMA2x2_NULL) {
   3384          		/* Check the struct p_bma2x2 is empty */
   3385          		return E_BMA2x2_NULL_PTR;
   3386              } else {
   3387          		/* read the double tap*/
   3388          		switch (channel_u8) {
   3389                    case BMA2x2_INTR1_DOUBLE_TAP:
   3390          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3391                          (p_bma2x2->dev_addr,
   3392                           BMA2x2_ENABLE_INTR1_PAD_DOUBLE_TAP_REG,
   3393                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3394          			*intr_double_tap_u8 = BMA2x2_GET_BITSLICE
   3395                          (data_u8, BMA2x2_ENABLE_INTR1_PAD_DOUBLE_TAP);
   3396                      break;
   3397                    case BMA2x2_INTR2_DOUBLE_TAP:
   3398          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3399                          (p_bma2x2->dev_addr,
   3400                           BMA2x2_ENABLE_INTR2_PAD_DOUBLE_TAP_REG,
   3401                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3402          			*intr_double_tap_u8 = BMA2x2_GET_BITSLICE
   3403                          (data_u8, BMA2x2_ENABLE_INTR2_PAD_DOUBLE_TAP);
   3404                      break;
   3405                    default:
   3406          			com_rslt = E_OUT_OF_RANGE;
   3407                      break;
   3408          		}
   3409          	}
   3410          	return com_rslt;
   3411          }
   3412          /*!
   3413          * @brief This API is used to set
   3414          * the interrupt enable of double tap interrupt
   3415          * in the register 0x19 and 0x1B
   3416          * @note INTR1_double -> register 0x19 bit 4
   3417          * @note INTR2_double -> register 0x1B bit 4
   3418          *
   3419          *
   3420          *
   3421          *
   3422          *  @param channel_u8: The value of double tap selection
   3423          *        channel_u8     |   result
   3424          *       ----------------- | ------------------
   3425          *              0          | BMA2x2_ACCEL_INTR1_DOUBLE_TAP
   3426          *              1          | BMA2x2_ACCEL_INTR2_DOUBLE_TAP
   3427          *
   3428          *	@param intr_double_tap_u8: The double tap interrupt enable value
   3429          *       intr_double_tap_u8     |   result
   3430          *       ------------------------ | ------------------
   3431          *              0x00              | INTR_DISABLE
   3432          *              0x01              | INTR_ENABLE
   3433          *
   3434          *	@return results of bus communication function
   3435          *	@retval 0 -> Success
   3436          *	@retval -1 -> Error
   3437          *
   3438          *
   3439          */
   3440          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_double_tap(u8 channel_u8,
   3441                                                                 u8 intr_double_tap_u8)
   3442          {
   3443          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3444              /*  Variable used to return value of
   3445          	communication routine*/
   3446          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3447              
   3448          	if (p_bma2x2 == BMA2x2_NULL) {
   3449          		/* Check the struct p_bma2x2 is empty */
   3450          		return E_BMA2x2_NULL_PTR;
   3451              } else {
   3452          		switch (channel_u8) {
   3453                      /* write the double tap*/
   3454                    case BMA2x2_INTR1_DOUBLE_TAP:
   3455          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3456                          (p_bma2x2->dev_addr,
   3457                           BMA2x2_ENABLE_INTR1_PAD_DOUBLE_TAP_REG,
   3458                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3459          			data_u8 = BMA2x2_SET_BITSLICE
   3460                          (data_u8,
   3461                           BMA2x2_ENABLE_INTR1_PAD_DOUBLE_TAP,
   3462                           intr_double_tap_u8);
   3463          			com_rslt += bma2x2_write_reg(
   3464                                                   BMA2x2_ENABLE_INTR1_PAD_DOUBLE_TAP_REG,
   3465                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3466                      break;
   3467                    case BMA2x2_INTR2_DOUBLE_TAP:
   3468          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3469                          (p_bma2x2->dev_addr,
   3470                           BMA2x2_ENABLE_INTR2_PAD_DOUBLE_TAP_REG,
   3471                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3472          			data_u8 = BMA2x2_SET_BITSLICE
   3473                          (data_u8,
   3474                           BMA2x2_ENABLE_INTR2_PAD_DOUBLE_TAP,
   3475                           intr_double_tap_u8);
   3476          			com_rslt += bma2x2_write_reg(
   3477                                                   BMA2x2_ENABLE_INTR2_PAD_DOUBLE_TAP_REG,
   3478                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3479                      break;
   3480                    default:
   3481                      com_rslt = E_OUT_OF_RANGE;
   3482                      break;
   3483          		}
   3484          	}
   3485          	return com_rslt;
   3486          }
   3487          /*!
   3488          * @brief This API is used to get
   3489          * the interrupt enable of single tap
   3490          * interrupt in the register 0x19 and 0x1B
   3491          * @note INTR1_single_tap -> register 0x19 bit 5
   3492          * @note INTR2_single_tap -> register 0x1B bit 5
   3493          *
   3494          *
   3495          *  @param channel_u8: The value of single tap interrupt select
   3496          *        channel_u8     |   result
   3497          *       ----------------- | ------------------
   3498          *              0          | BMA2x2_ACCEL_INTR1_SINGLE_TAP
   3499          *              1          | BMA2x2_ACCEL_INTR2_SINGLE_TAP
   3500          *
   3501          *  @param intr_single_tap_u8: The single tap interrupt enable value
   3502          *       intr_single_tap_u8     |   result
   3503          *       ------------------------ | ------------------
   3504          *              0x00              | INTR_DISABLE
   3505          *              0x01              | INTR_ENABLE
   3506          *
   3507          *
   3508          *	@return results of bus communication function
   3509          *	@retval 0 -> Success
   3510          *	@retval -1 -> Error
   3511          *
   3512          *
   3513          */
   3514          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_single_tap(u8 channel_u8,
   3515                                                                 u8 *intr_single_tap_u8)
   3516          {
   3517          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3518              /*  Variable used to return value of
   3519          	communication routine*/
   3520          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3521              
   3522          	if (p_bma2x2 == BMA2x2_NULL) {
   3523          		/* Check the struct p_bma2x2 is empty */
   3524          		return E_BMA2x2_NULL_PTR;
   3525              } else {
   3526          		switch (channel_u8) {
   3527                      /* Read the single tap value*/
   3528                    case BMA2x2_INTR1_SINGLE_TAP:
   3529          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3530                          (p_bma2x2->dev_addr,
   3531                           BMA2x2_ENABLE_INTR1_PAD_SINGLE_TAP_REG,
   3532                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3533          			*intr_single_tap_u8 = BMA2x2_GET_BITSLICE
   3534                          (data_u8, BMA2x2_ENABLE_INTR1_PAD_SINGLE_TAP);
   3535                      break;
   3536                    case BMA2x2_INTR2_SINGLE_TAP:
   3537          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3538                          (p_bma2x2->dev_addr,
   3539                           BMA2x2_ENABLE_INTR2_PAD_SINGLE_TAP_REG,
   3540                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3541          			*intr_single_tap_u8 = BMA2x2_GET_BITSLICE
   3542                          (data_u8, BMA2x2_ENABLE_INTR2_PAD_SINGLE_TAP);
   3543                      break;
   3544                    default:
   3545          			com_rslt = E_OUT_OF_RANGE;
   3546                      break;
   3547          		}
   3548          	}
   3549          	return com_rslt;
   3550          }
   3551          /*!
   3552          * @brief This API is used to set
   3553          * the interrupt enable of single tap
   3554          * interrupt in the register 0x19 and 0x1B
   3555          * @note INTR1_single_tap -> register 0x19 bit 5
   3556          * @note INTR2_single_tap -> register 0x1B bit 5
   3557          *
   3558          *
   3559          *  @param channel_u8: The value of single tap interrupt select
   3560          *        channel_u8     |   result
   3561          *       ----------------- | ------------------
   3562          *              0          | BMA2x2_ACCEL_INTR1_SINGLE_TAP
   3563          *              1          | BMA2x2_ACCEL_INTR2_SINGLE_TAP
   3564          *
   3565          *  @param intr_single_tap_u8: The single tap interrupt enable value
   3566          *       intr_single_tap_u8     |   result
   3567          *       ------------------------ | ------------------
   3568          *              0x00              | INTR_DISABLE
   3569          *              0x01              | INTR_ENABLE
   3570          *
   3571          *
   3572          *	@return results of bus communication function
   3573          *	@retval 0 -> Success
   3574          *	@retval -1 -> Error
   3575          *
   3576          *
   3577          */
   3578          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_single_tap(u8 channel_u8,
   3579                                                                 u8 intr_single_tap_u8)
   3580          {
   3581          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3582              /*  Variable used to return value of
   3583          	communication routine*/
   3584          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3585              
   3586          	if (p_bma2x2 == BMA2x2_NULL) {
   3587          		/* Check the struct p_bma2x2 is empty */
   3588          		return E_BMA2x2_NULL_PTR;
   3589              } else {
   3590          		switch (channel_u8) {
   3591                      /* write the single tap value*/
   3592                    case BMA2x2_INTR1_SINGLE_TAP:
   3593          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3594                          (p_bma2x2->dev_addr,
   3595                           BMA2x2_ENABLE_INTR1_PAD_SINGLE_TAP_REG,
   3596                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3597          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   3598                                                    BMA2x2_ENABLE_INTR1_PAD_SINGLE_TAP,
   3599                                                    intr_single_tap_u8);
   3600          			com_rslt += bma2x2_write_reg(
   3601                                                   BMA2x2_ENABLE_INTR1_PAD_SINGLE_TAP_REG,
   3602                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3603                      break;
   3604                    case BMA2x2_INTR2_SINGLE_TAP:
   3605          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3606                          (p_bma2x2->dev_addr,
   3607                           BMA2x2_ENABLE_INTR2_PAD_SINGLE_TAP_REG,
   3608                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3609          			data_u8 = BMA2x2_SET_BITSLICE
   3610                          (data_u8,
   3611                           BMA2x2_ENABLE_INTR2_PAD_SINGLE_TAP,
   3612                           intr_single_tap_u8);
   3613          			com_rslt += bma2x2_write_reg(
   3614                                                   BMA2x2_ENABLE_INTR2_PAD_SINGLE_TAP_REG,
   3615                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3616                      break;
   3617                    default:
   3618          			com_rslt = E_OUT_OF_RANGE;
   3619                      break;
   3620          		}
   3621          	}
   3622          	return com_rslt;
   3623          }
   3624          /*!
   3625          * @brief This API is used to get
   3626          * the interrupt status of orient interrupt in the register 0x19 and 0x1B
   3627          * @note INTR1_orient -> register 0x19 bit 6
   3628          * @note INTR2_orient -> register 0x1B bit 6
   3629          *
   3630          *
   3631          * @param channel_u8: The value of orient interrupt select
   3632          *        channel_u8     |   result
   3633          *       ----------------- | ------------------
   3634          *              0          | BMA2x2_ACCEL_INTR1_ORIENT
   3635          *              1          | BMA2x2_ACCEL_INTR2_ORIENT
   3636          *
   3637          *  @param intr_orient_u8: The value of orient interrupt enable
   3638          *       intr_orient_u8         |   result
   3639          *       ------------------------ | ------------------
   3640          *              0x00              | INTR_DISABLE
   3641          *              0x01              | INTR_ENABLE
   3642          *
   3643          *
   3644          *	@return results of bus communication function
   3645          *	@retval 0 -> Success
   3646          *	@retval -1 -> Error
   3647          *
   3648          *
   3649          */
   3650          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_orient(u8 channel_u8,
   3651                                                             u8 *intr_orient_u8)
   3652          {
   3653          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3654              /*  Variable used to return value of
   3655          	communication routine*/
   3656          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3657              
   3658          	if (p_bma2x2 == BMA2x2_NULL) {
   3659          		/* Check the struct p_bma2x2 is empty */
   3660          		return E_BMA2x2_NULL_PTR;
   3661              } else {
   3662          		switch (channel_u8) {
   3663                      /* Read orient interrupt*/
   3664                    case BMA2x2_INTR1_ORIENT:
   3665          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3666                          (p_bma2x2->dev_addr,
   3667                           BMA2x2_ENABLE_INTR1_PAD_ORIENT_REG,
   3668                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3669          			*intr_orient_u8 = BMA2x2_GET_BITSLICE
   3670                          (data_u8, BMA2x2_ENABLE_INTR1_PAD_ORIENT);
   3671                      break;
   3672                    case BMA2x2_INTR2_ORIENT:
   3673          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3674                          (p_bma2x2->dev_addr,
   3675                           BMA2x2_ENABLE_INTR2_PAD_ORIENT_REG,
   3676                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3677          			*intr_orient_u8 = BMA2x2_GET_BITSLICE
   3678                          (data_u8, BMA2x2_ENABLE_INTR2_PAD_ORIENT);
   3679                      break;
   3680                    default:
   3681          			com_rslt = E_OUT_OF_RANGE;
   3682                      break;
   3683          		}
   3684          	}
   3685          	return com_rslt;
   3686          }
   3687          /*!
   3688          * @brief This API is used to set
   3689          * the interrupt status of orient interrupt in the register 0x19 and 0x1B
   3690          * @note INTR1_orient -> register 0x19 bit 6
   3691          * @note INTR2_orient -> register 0x1B bit 6
   3692          *
   3693          *
   3694          * @param channel_u8: The value of orient interrupt select
   3695          *        channel_u8     |   result
   3696          *       ----------------- | ------------------
   3697          *              0          | BMA2x2_ACCEL_INTR1_ORIENT
   3698          *              1          | BMA2x2_ACCEL_INTR2_ORIENT
   3699          *
   3700          *  @param intr_orient_u8: The value of orient interrupt enable
   3701          *       intr_orient_u8         |   result
   3702          *       ------------------------ | ------------------
   3703          *              0x00              | INTR_DISABLE
   3704          *              0x01              | INTR_ENABLE
   3705          *
   3706          *
   3707          *	@return results of bus communication function
   3708          *	@retval 0 -> Success
   3709          *	@retval -1 -> Error
   3710          *
   3711          *
   3712          */
   3713          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_orient(u8 channel_u8,
   3714                                                             u8 intr_orient_u8)
   3715          {
   3716          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3717          	/*  Variable used to return value of
   3718          	communication routine*/
   3719          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3720              
   3721          	if (p_bma2x2 == BMA2x2_NULL) {
   3722          		/* Check the struct p_bma2x2 is empty */
   3723          		return E_BMA2x2_NULL_PTR;
   3724              } else {
   3725          		switch (channel_u8) {
   3726                      /* Write orient interrupt */
   3727                    case BMA2x2_INTR1_ORIENT:
   3728          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3729                          (p_bma2x2->dev_addr,
   3730                           BMA2x2_ENABLE_INTR1_PAD_ORIENT_REG,
   3731                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3732          			data_u8 = BMA2x2_SET_BITSLICE
   3733                          (data_u8,
   3734                           BMA2x2_ENABLE_INTR1_PAD_ORIENT, intr_orient_u8);
   3735          			com_rslt += bma2x2_write_reg(
   3736                                                   BMA2x2_ENABLE_INTR1_PAD_ORIENT_REG,
   3737                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3738                      break;
   3739                    case BMA2x2_INTR2_ORIENT:
   3740          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3741                          (p_bma2x2->dev_addr,
   3742                           BMA2x2_ENABLE_INTR2_PAD_ORIENT_REG,
   3743                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3744          			data_u8 = BMA2x2_SET_BITSLICE
   3745                          (data_u8,
   3746                           BMA2x2_ENABLE_INTR2_PAD_ORIENT, intr_orient_u8);
   3747          			com_rslt += bma2x2_write_reg(
   3748                                                   BMA2x2_ENABLE_INTR2_PAD_ORIENT_REG,
   3749                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3750                      break;
   3751                    default:
   3752          			com_rslt = E_OUT_OF_RANGE;
   3753                      break;
   3754          		}
   3755          	}
   3756          	return com_rslt;
   3757          }
   3758          /*!
   3759          * @brief This API is used to get
   3760          * the interrupt enable of flat interrupt in the register 0x19 and 0x1B
   3761          * @note INTR1_flat -> register 0x19 bit 7
   3762          * @note INTR2_flat -> register 0x1B bit 7
   3763          *
   3764          *
   3765          *
   3766          *
   3767          * @param channel_u8: The value of flat interrupt select
   3768          *        channel_u8     |   result
   3769          *       ----------------- | ------------------
   3770          *              0          | BMA2x2_ACCEL_INTR1_FLAT
   3771          *              1          | BMA2x2_ACCEL_INTR2_FLAT
   3772          *
   3773          * @param intr_flat_u8: The flat interrupt enable value
   3774          *       intr_flat_u8           |   result
   3775          *       ------------------------ | ------------------
   3776          *              0x00              | INTR_DISABLE
   3777          *              0x01              | INTR_ENABLE
   3778          *
   3779          *
   3780          *	@return results of bus communication function
   3781          *	@retval 0 -> Success
   3782          *	@retval -1 -> Error
   3783          *
   3784          *
   3785          */
   3786          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_flat(u8 channel_u8,
   3787                                                           u8 *intr_flat_u8)
   3788          {
   3789          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3790              /*  Variable used to return value of
   3791          	communication routine*/
   3792          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3793              
   3794          	if (p_bma2x2 == BMA2x2_NULL) {
   3795          		/* Check the struct p_bma2x2 is empty */
   3796          		return E_BMA2x2_NULL_PTR;
   3797              } else {
   3798          		switch (channel_u8) {
   3799                      /* Read flat interrupt */
   3800                    case BMA2x2_INTR1_FLAT:
   3801          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3802                          (p_bma2x2->dev_addr,
   3803                           BMA2x2_ENABLE_INTR1_PAD_FLAT_REG,
   3804                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3805          			*intr_flat_u8 = BMA2x2_GET_BITSLICE
   3806                          (data_u8, BMA2x2_ENABLE_INTR1_PAD_FLAT);
   3807                      break;
   3808                    case BMA2x2_INTR2_FLAT:
   3809          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3810                          (p_bma2x2->dev_addr,
   3811                           BMA2x2_ENABLE_INTR2_PAD_FLAT_REG,
   3812                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3813          			*intr_flat_u8 = BMA2x2_GET_BITSLICE
   3814                          (data_u8, BMA2x2_ENABLE_INTR2_PAD_FLAT);
   3815                      break;
   3816                    default:
   3817          			com_rslt = E_OUT_OF_RANGE;
   3818                      break;
   3819          		}
   3820          	}
   3821          	return com_rslt;
   3822          }
   3823          /*!
   3824          * @brief This API is used to set
   3825          * the interrupt enable of flat interrupt in the register 0x19 and 0x1B
   3826          * @note INTR1_flat -> register 0x19 bit 7
   3827          * @note INTR2_flat -> register 0x1B bit 7
   3828          *
   3829          *
   3830          *
   3831          *
   3832          * @param channel_u8: The value of flat interrupt select
   3833          *        channel_u8     |   result
   3834          *       ----------------- | ------------------
   3835          *              0          | BMA2x2_ACCEL_INTR1_FLAT
   3836          *              1          | BMA2x2_ACCEL_INTR2_FLAT
   3837          *
   3838          * @param intr_flat_u8: The flat interrupt enable value
   3839          *       intr_flat_u8           |   result
   3840          *       ------------------------ | ------------------
   3841          *              0x00              | INTR_DISABLE
   3842          *              0x01              | INTR_ENABLE
   3843          *
   3844          *
   3845          *	@return results of bus communication function
   3846          *	@retval 0 -> Success
   3847          *	@retval -1 -> Error
   3848          *
   3849          *
   3850          */
   3851          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_flat(u8 channel_u8,
   3852                                                           u8 intr_flat_u8)
   3853          {
   3854          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3855          	/*  Variable used to return value of
   3856          	communication routine*/
   3857          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3858              
   3859          	if (p_bma2x2 == BMA2x2_NULL) {
   3860          		/* Check the struct p_bma2x2 is empty */
   3861          		return E_BMA2x2_NULL_PTR;
   3862              } else {
   3863          		switch (channel_u8) {
   3864                      /* write flat interrupt */
   3865                    case BMA2x2_INTR1_FLAT:
   3866          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3867                          (p_bma2x2->dev_addr,
   3868                           BMA2x2_ENABLE_INTR1_PAD_FLAT_REG,
   3869                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3870          			data_u8 = BMA2x2_SET_BITSLICE
   3871                          (data_u8,
   3872                           BMA2x2_ENABLE_INTR1_PAD_FLAT, intr_flat_u8);
   3873          			com_rslt += bma2x2_write_reg(
   3874                                                   BMA2x2_ENABLE_INTR1_PAD_FLAT_REG,
   3875                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3876                      break;
   3877                    case BMA2x2_INTR2_FLAT:
   3878          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3879                          (p_bma2x2->dev_addr,
   3880                           BMA2x2_ENABLE_INTR2_PAD_FLAT_REG,
   3881                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3882          			data_u8 = BMA2x2_SET_BITSLICE
   3883                          (data_u8,
   3884                           BMA2x2_ENABLE_INTR2_PAD_FLAT, intr_flat_u8);
   3885          			com_rslt += bma2x2_write_reg(
   3886                                                   BMA2x2_ENABLE_INTR2_PAD_FLAT_REG,
   3887                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3888                      break;
   3889                    default:
   3890          			com_rslt = E_OUT_OF_RANGE;
   3891                      break;
   3892          		}
   3893          	}
   3894          	return com_rslt;
   3895          }
   3896          /*!
   3897          * @brief This API is used to get
   3898          * the interrupt status of new data in the register 0x19
   3899          * @note INTR1_data -> register 0x19 bit 0
   3900          * @note INTR2_data -> register 0x19 bit 7
   3901          *
   3902          *
   3903          *
   3904          *  @param channel_u8: The value of new data interrupt select
   3905          *        channel_u8     |   result
   3906          *       ----------------- | ------------------
   3907          *              0          | BMA2x2_ACCEL_INTR1_NEWDATA
   3908          *              1          | BMA2x2_ACCEL_INTR2_NEWDATA
   3909          *
   3910          *	@param intr_newdata_u8: The new data interrupt enable value
   3911          *       intr_newdata_u8          |    result
   3912          *       ------------------------ | ------------------
   3913          *              0x00              | INTR_DISABLE
   3914          *              0x01              | INTR_ENABLE
   3915          *
   3916          *
   3917          *	@return results of bus communication function
   3918          *	@retval 0 -> Success
   3919          *	@retval -1 -> Error
   3920          *
   3921          *
   3922          */
   3923          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_new_data(u8 channel_u8,
   3924                                                          u8 *intr_newdata_u8)
   3925          {
   3926          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3927              /*  Variable used to return value of
   3928          	communication routine*/
   3929          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3930              
   3931          	if (p_bma2x2 == BMA2x2_NULL) {
   3932          		/* Check the struct p_bma2x2 is empty */
   3933          		return E_BMA2x2_NULL_PTR;
   3934              } else {
   3935          		switch (channel_u8) {
   3936                      /* Read the data interrupt*/
   3937                    case BMA2x2_INTR1_NEWDATA:
   3938          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3939                          (p_bma2x2->dev_addr,
   3940                           BMA2x2_ENABLE_INTR1_PAD_NEWDATA_REG,
   3941                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3942          			*intr_newdata_u8 = BMA2x2_GET_BITSLICE
   3943                          (data_u8, BMA2x2_ENABLE_INTR1_PAD_NEWDATA);
   3944                      break;
   3945                    case BMA2x2_INTR2_NEWDATA:
   3946          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   3947                          (p_bma2x2->dev_addr,
   3948                           BMA2x2_ENABLE_INTR2_PAD_NEWDATA_REG,
   3949                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   3950          			*intr_newdata_u8 = BMA2x2_GET_BITSLICE
   3951                          (data_u8, BMA2x2_ENABLE_INTR2_PAD_NEWDATA);
   3952                      break;
   3953                    default:
   3954          			com_rslt = E_OUT_OF_RANGE;
   3955                      break;
   3956          		}
   3957          	}
   3958          	return com_rslt;
   3959          }
   3960          /*!
   3961          * @brief This API is used to set
   3962          * the interrupt status of new data in the register 0x19
   3963          * @note INTR1_data -> register 0x19 bit 0
   3964          * @note INTR2_data -> register 0x19 bit 7
   3965          *
   3966          *
   3967          *
   3968          *  @param channel_u8: The value of new data interrupt select
   3969          *        channel_u8     |   result
   3970          *       ----------------- | ------------------
   3971          *              0          | BMA2x2_ACCEL_INTR1_NEWDATA
   3972          *              1          | BMA2x2_ACCEL_INTR2_NEWDATA
   3973          *
   3974          *	@param intr_newdata_u8: The new data interrupt enable value
   3975          *       intr_newdata_u8          |    result
   3976          *       ------------------------ | ------------------
   3977          *              0x00              | INTR_DISABLE
   3978          *              0x01              | INTR_ENABLE
   3979          *
   3980          *
   3981          *	@return results of bus communication function
   3982          *	@retval 0 -> Success
   3983          *	@retval -1 -> Error
   3984          *
   3985          *
   3986          */
   3987          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_new_data(u8 channel_u8,
   3988                                                          u8 intr_newdata_u8)
   3989          {
   3990          	u8 data_u8 = BMA2x2_INIT_VALUE;
   3991          	/*  Variable used to return value of
   3992          	communication routine*/
   3993          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   3994              
   3995          	if (p_bma2x2 == BMA2x2_NULL) {
   3996          		/* Check the struct p_bma2x2 is empty */
   3997          		return E_BMA2x2_NULL_PTR;
   3998              } else {
   3999          		switch (channel_u8) {
   4000                      /* write the new data interrupt */
   4001                    case BMA2x2_INTR1_NEWDATA:
   4002          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4003                          (p_bma2x2->dev_addr,
   4004                           BMA2x2_ENABLE_INTR1_PAD_NEWDATA_REG,
   4005                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4006          			data_u8 = BMA2x2_SET_BITSLICE
   4007                          (data_u8,
   4008                           BMA2x2_ENABLE_INTR1_PAD_NEWDATA, intr_newdata_u8);
   4009          			com_rslt += bma2x2_write_reg(
   4010                                                   BMA2x2_ENABLE_INTR1_PAD_NEWDATA_REG,
   4011                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4012                      break;
   4013                    case BMA2x2_INTR2_NEWDATA:
   4014          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4015                          (p_bma2x2->dev_addr,
   4016                           BMA2x2_ENABLE_INTR2_PAD_NEWDATA_REG,
   4017                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4018          			data_u8 = BMA2x2_SET_BITSLICE
   4019                          (data_u8,
   4020                           BMA2x2_ENABLE_INTR2_PAD_NEWDATA, intr_newdata_u8);
   4021          			com_rslt += bma2x2_write_reg(
   4022                                                   BMA2x2_ENABLE_INTR2_PAD_NEWDATA_REG,
   4023                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4024                      break;
   4025                    default:
   4026          			com_rslt = E_OUT_OF_RANGE;
   4027                      break;
   4028          		}
   4029          	}
   4030          	return com_rslt;
   4031          }
   4032          /*!
   4033          * @brief This API is used to get the fifo watermark interrupt1 data
   4034          * in the register 0x1A bit 1
   4035          *
   4036          *  @param  intr1_fifo_wm_u8 : The value of interrupt1 FIFO watermark enable
   4037          *       intr1_fifo_wm_u8       |    result
   4038          *       ------------------------ | ------------------
   4039          *              0x00              | INTR_DISABLE
   4040          *              0x01              | INTR_ENABLE
   4041          *
   4042          *
   4043          *
   4044          *	@return results of bus communication function
   4045          *	@retval 0 -> Success
   4046          *	@retval -1 -> Error
   4047          *
   4048          *
   4049          */
   4050          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr1_fifo_wm(u8 *intr1_fifo_wm_u8)
   4051          {
   4052          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4053              /*  Variable used to return value of
   4054          	communication routine*/
   4055          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4056              
   4057          	if (p_bma2x2 == BMA2x2_NULL) {
   4058          		/* Check the struct p_bma2x2 is empty */
   4059          		return E_BMA2x2_NULL_PTR;
   4060              } else {
   4061                  /* read the fifo watermark interrupt */
   4062                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4063          			(p_bma2x2->dev_addr,
   4064                       BMA2x2_ENABLE_INTR1_PAD_FIFO_WM_REG,
   4065                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4066                  *intr1_fifo_wm_u8 = BMA2x2_GET_BITSLICE
   4067          			(data_u8, BMA2x2_ENABLE_INTR1_PAD_FIFO_WM);
   4068              }
   4069          	return com_rslt;
   4070          }
   4071          /*!
   4072          * @brief This API is used to set the fifo watermark interrupt1 data
   4073          * in the register 0x1A bit 1
   4074          *
   4075          *  @param  intr1_fifo_wm_u8 : The value of interrupt1 FIFO watermark enable
   4076          *       intr1_fifo_wm_u8       |    result
   4077          *       ------------------------ | ------------------
   4078          *              0x00              | INTR_DISABLE
   4079          *              0x01              | INTR_ENABLE
   4080          *
   4081          *
   4082          *
   4083          *	@return results of bus communication function
   4084          *	@retval 0 -> Success
   4085          *	@retval -1 -> Error
   4086          *
   4087          *
   4088          */
   4089          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr1_fifo_wm(u8 intr1_fifo_wm_u8)
   4090          {
   4091          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4092          	/*  Variable used to return value of
   4093          	communication routine*/
   4094          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4095              
   4096          	if (p_bma2x2 == BMA2x2_NULL) {
   4097          		/* Check the struct p_bma2x2 is empty */
   4098          		return E_BMA2x2_NULL_PTR;
   4099              } else {
   4100          		if (intr1_fifo_wm_u8 <
   4101                      BMA2x2_FIFO_MODE_STATUS_RANGE) {
   4102                          /* write the fifo watermark interrupt */
   4103                          com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4104                              (p_bma2x2->dev_addr,
   4105                               BMA2x2_ENABLE_INTR1_PAD_FIFO_WM_REG,
   4106                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4107                          data_u8 = BMA2x2_SET_BITSLICE
   4108                              (data_u8,
   4109                               BMA2x2_ENABLE_INTR1_PAD_FIFO_WM, intr1_fifo_wm_u8);
   4110                          com_rslt += bma2x2_write_reg(
   4111                                                       BMA2x2_ENABLE_INTR1_PAD_FIFO_WM_REG,
   4112                                                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4113                      } else {
   4114                          com_rslt = E_OUT_OF_RANGE;
   4115                      }
   4116          	}
   4117          	return com_rslt;
   4118          }
   4119          /*!
   4120          * @brief This API is used to get the fifo watermark interrupt2 data
   4121          * in the register 0x1A bit 6
   4122          *
   4123          *  @param  intr2_fifo_wm_u8 : The value of interrupt1 FIFO watermark enable
   4124          *       intr2_fifo_wm_u8       |    result
   4125          *       ------------------------ | ------------------
   4126          *              0x00              | INTR_DISABLE
   4127          *              0x01              | INTR_ENABLE
   4128          *
   4129          *
   4130          *
   4131          *	@return results of bus communication function
   4132          *	@retval 0 -> Success
   4133          *	@retval -1 -> Error
   4134          *
   4135          *
   4136          */
   4137          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr2_fifo_wm(u8 *intr2_fifo_wm_u8)
   4138          {
   4139          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4140              /*  Variable used to return value of
   4141          	communication routine*/
   4142          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4143              
   4144          	if (p_bma2x2 == BMA2x2_NULL) {
   4145          		/* Check the struct p_bma2x2 is empty */
   4146          		return E_BMA2x2_NULL_PTR;
   4147              } else {
   4148                  /* read the fifo watermark interrupt2*/
   4149                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4150          			(p_bma2x2->dev_addr,
   4151                       BMA2x2_ENABLE_INTR2_PAD_FIFO_WM_REG,
   4152                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4153                  *intr2_fifo_wm_u8 = BMA2x2_GET_BITSLICE
   4154          			(data_u8, BMA2x2_ENABLE_INTR2_PAD_FIFO_WM);
   4155              }
   4156          	return com_rslt;
   4157          }
   4158          /*!
   4159          * @brief This API is used to set the fifo watermark interrupt2 data
   4160          * in the register 0x1A bit 6
   4161          *
   4162          *  @param  intr2_fifo_wm_u8 : The value of interrupt1 FIFO watermark enable
   4163          *       intr2_fifo_wm_u8       |    result
   4164          *       ------------------------ | ------------------
   4165          *              0x00              | INTR_DISABLE
   4166          *              0x01              | INTR_ENABLE
   4167          *
   4168          *
   4169          *
   4170          *	@return results of bus communication function
   4171          *	@retval 0 -> Success
   4172          *	@retval -1 -> Error
   4173          *
   4174          *
   4175          */
   4176          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr2_fifo_wm(u8 intr2_fifo_wm_u8)
   4177          {
   4178          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4179          	/*  Variable used to return value of
   4180          	communication routine*/
   4181          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4182              
   4183          	if (p_bma2x2 == BMA2x2_NULL) {
   4184          		/* Check the struct p_bma2x2 is empty */
   4185          		return E_BMA2x2_NULL_PTR;
   4186              } else {
   4187          		if (intr2_fifo_wm_u8 <
   4188                      BMA2x2_FIFO_MODE_STATUS_RANGE) {
   4189                          /* write the fifo watermark interrupt2*/
   4190                          com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4191                              (p_bma2x2->dev_addr,
   4192                               BMA2x2_ENABLE_INTR2_PAD_FIFO_WM_REG,
   4193                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4194                          data_u8 = BMA2x2_SET_BITSLICE
   4195                              (data_u8,
   4196                               BMA2x2_ENABLE_INTR2_PAD_FIFO_WM, intr2_fifo_wm_u8);
   4197                          com_rslt += bma2x2_write_reg(
   4198                                                       BMA2x2_ENABLE_INTR2_PAD_FIFO_WM_REG,
   4199                                                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4200                      } else {
   4201                          com_rslt = E_OUT_OF_RANGE;
   4202                      }
   4203          	}
   4204          	return com_rslt;
   4205          }
   4206          /*!
   4207          *	@brief This API is used to get
   4208          *	the fifo full interrupt1 in the register 0x1A bit 2
   4209          *
   4210          *
   4211          *
   4212          *  @param intr1_fifo_full_u8 : The value of fifo full interrupt enable
   4213          *       intr1_fifo_full_u8     |    result
   4214          *       ------------------------ | ------------------
   4215          *              0x00              | INTR_DISABLE
   4216          *              0x01              | INTR_ENABLE
   4217          *
   4218          *
   4219          *
   4220          *	@return results of bus communication function
   4221          *	@retval 0 -> Success
   4222          *	@retval -1 -> Error
   4223          *
   4224          *
   4225          */
   4226          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr1_fifo_full(u8 *intr1_fifo_full_u8)
   4227          {
   4228          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4229              /*  Variable used to return value of
   4230          	communication routine*/
   4231          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4232              
   4233          	if (p_bma2x2 == BMA2x2_NULL) {
   4234          		/* Check the struct p_bma2x2 is empty */
   4235          		return E_BMA2x2_NULL_PTR;
   4236              } else {
   4237                  /* read the fifo full interrupt1*/
   4238                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4239          			(p_bma2x2->dev_addr,
   4240                       BMA2x2_ENABLE_INTR1_PAD_FIFO_FULL_REG,
   4241                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4242                  *intr1_fifo_full_u8 = BMA2x2_GET_BITSLICE
   4243          			(data_u8, BMA2x2_ENABLE_INTR1_PAD_FIFO_FULL);
   4244              }
   4245          	return com_rslt;
   4246          }
   4247          /*!
   4248          *	@brief This API is used to set
   4249          *	the fifo full interrupt1 in the register 0x1A bit 2
   4250          *
   4251          *
   4252          *
   4253          *  @param intr1_fifo_full_u8 : The value of fifo full interrupt enable
   4254          *       intr1_fifo_full_u8     |    result
   4255          *       ------------------------ | ------------------
   4256          *              0x00              | INTR_DISABLE
   4257          *              0x01              | INTR_ENABLE
   4258          *
   4259          *
   4260          *
   4261          *	@return results of bus communication function
   4262          *	@retval 0 -> Success
   4263          *	@retval -1 -> Error
   4264          *
   4265          *
   4266          */
   4267          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr1_fifo_full(u8 intr1_fifo_full_u8)
   4268          {
   4269          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4270              /*  Variable used to return value of
   4271          	communication routine*/
   4272          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4273              
   4274          	if (p_bma2x2 == BMA2x2_NULL) {
   4275          		/* Check the struct p_bma2x2 is empty */
   4276          		return E_BMA2x2_NULL_PTR;
   4277              } else {
   4278          		if (intr1_fifo_full_u8 <
   4279                      BMA2x2_FIFO_MODE_STATUS_RANGE) {
   4280                          /* write the fifo full interrupt1*/
   4281                          com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4282                              (p_bma2x2->dev_addr,
   4283                               BMA2x2_ENABLE_INTR1_PAD_FIFO_FULL_REG,
   4284                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4285                          data_u8 = BMA2x2_SET_BITSLICE
   4286                              (data_u8, BMA2x2_ENABLE_INTR1_PAD_FIFO_FULL,
   4287                               intr1_fifo_full_u8);
   4288                          com_rslt += bma2x2_write_reg(
   4289                                                       BMA2x2_ENABLE_INTR1_PAD_FIFO_FULL_REG,
   4290                                                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4291          			} else {
   4292                          com_rslt = E_OUT_OF_RANGE;
   4293                      }
   4294          	}
   4295          	return com_rslt;
   4296          }
   4297          /*!
   4298          *	@brief This API is used to get
   4299          *	the fifo full interrupt2 in the register 0x1A bit 5
   4300          *
   4301          *
   4302          *
   4303          *  @param intr2_fifo_full_u8 : Thee vale of fifo full enable
   4304          *       intr2_fifo_full_u8     |    result
   4305          *       ------------------------ | ------------------
   4306          *              0x00              | INTR_DISABLE
   4307          *              0x01              | INTR_ENABLE
   4308          *
   4309          *
   4310          *
   4311          *	@return results of bus communication function
   4312          *	@retval 0 -> Success
   4313          *	@retval -1 -> Error
   4314          *
   4315          *
   4316          *
   4317          */
   4318          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr2_fifo_full(u8 *intr2_fifo_full_u8)
   4319          {
   4320          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4321              /*  Variable used to return value of
   4322          	communication routine*/
   4323          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4324              
   4325          	if (p_bma2x2 == BMA2x2_NULL) {
   4326          		/* Check the struct p_bma2x2 is empty */
   4327          		return E_BMA2x2_NULL_PTR;
   4328              } else {
   4329                  /* read the fifo full interrupt2*/
   4330                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4331          			(p_bma2x2->dev_addr,
   4332                       BMA2x2_ENABLE_INTR2_PAD_FIFO_FULL_REG,
   4333                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4334                  *intr2_fifo_full_u8 = BMA2x2_GET_BITSLICE
   4335          			(data_u8, BMA2x2_ENABLE_INTR2_PAD_FIFO_FULL);
   4336              }
   4337          	return com_rslt;
   4338          }
   4339          /*!
   4340          *	@brief This API is used to set
   4341          *	the fifo full interrupt2 in the register 0x1A bit 5
   4342          *
   4343          *
   4344          *
   4345          *  @param intr2_fifo_full_u8 : Thee vale of fifo full enable
   4346          *       intr2_fifo_full_u8     |    result
   4347          *       ------------------------ | ------------------
   4348          *              0x00              | INTR_DISABLE
   4349          *              0x01              | INTR_ENABLE
   4350          *
   4351          *
   4352          *
   4353          *	@return results of bus communication function
   4354          *	@retval 0 -> Success
   4355          *	@retval -1 -> Error
   4356          *
   4357          *
   4358          *
   4359          */
   4360          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr2_fifo_full(u8 intr2_fifo_full_u8)
   4361          {
   4362          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4363          	/*  Variable used to return value of
   4364          	communication routine*/
   4365          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4366              
   4367          	if (p_bma2x2 == BMA2x2_NULL) {
   4368          		/* Check the struct p_bma2x2 is empty */
   4369          		return E_BMA2x2_NULL_PTR;
   4370              } else {
   4371          		if (intr2_fifo_full_u8 <
   4372                      BMA2x2_FIFO_MODE_STATUS_RANGE) {
   4373                          /* write the fifo full interrupt2*/
   4374                          com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4375                              (p_bma2x2->dev_addr,
   4376                               BMA2x2_ENABLE_INTR2_PAD_FIFO_FULL_REG,
   4377                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4378                          data_u8 = BMA2x2_SET_BITSLICE
   4379                              (data_u8,
   4380                               BMA2x2_ENABLE_INTR2_PAD_FIFO_FULL,
   4381                               intr2_fifo_full_u8);
   4382                          com_rslt += bma2x2_write_reg(
   4383                                                       BMA2x2_ENABLE_INTR2_PAD_FIFO_FULL_REG,
   4384                                                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4385          			} else {
   4386                          com_rslt = E_OUT_OF_RANGE;
   4387          			}
   4388              }
   4389          	return com_rslt;
   4390          }
   4391          /*!
   4392          *	@brief This API is used to get
   4393          *	the source data status of source data,
   4394          *	source slow no motion, source slope, source high
   4395          *	and source low in the register 0x1E bit from 0 to 5
   4396          *
   4397          *
   4398          *
   4399          *  @param channel_u8 : The value of source select
   4400          *       channel_u8     |    result
   4401          *       -----------------| ------------------
   4402          *               0        | BMA2x2_ACCEL_SOURCE_LOW_G
   4403          *               1        | BMA2x2_ACCEL_SOURCE_HIGH_G
   4404          *               2        | BMA2x2_ACCEL_SOURCE_SLOPE
   4405          *               3        | BMA2x2_ACCEL_SOURCE_SLOW_NO_MOTION
   4406          *               4        | BMA2x2_ACCEL_SOURCE_TAP
   4407          *               5        | BMA2x2_ACCEL_SOURCE_DATA
   4408          *
   4409          *	@param intr_source_u8: The source status enable value
   4410          *       intr_source_u8         |    result
   4411          *       ------------------------ | ------------------
   4412          *              0x00              | INTR_DISABLE
   4413          *              0x01              | INTR_ENABLE
   4414          *
   4415          *	@return results of bus communication function
   4416          *	@retval 0 -> Success
   4417          *	@retval -1 -> Error
   4418          *
   4419          */
   4420          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_source(u8 channel_u8,
   4421                                                        u8 *intr_source_u8)
   4422          {
   4423          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4424          	/*  Variable used to return value of
   4425          	communication routine*/
   4426          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4427              
   4428          	if (p_bma2x2 == BMA2x2_NULL) {
   4429          		return  E_BMA2x2_NULL_PTR;
   4430              } else {
   4431          		/* read the source interrupt register */
   4432          		switch (channel_u8) {
   4433                    case BMA2x2_SOURCE_LOW_G:
   4434          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4435                          (p_bma2x2->dev_addr,
   4436                           BMA2x2_UNFILT_INTR_SOURCE_LOW_G_REG,
   4437                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4438          			*intr_source_u8 = BMA2x2_GET_BITSLICE
   4439                          (data_u8, BMA2x2_UNFILT_INTR_SOURCE_LOW_G);
   4440                      break;
   4441                    case BMA2x2_SOURCE_HIGH_G:
   4442          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4443                          (p_bma2x2->dev_addr,
   4444                           BMA2x2_UNFILT_INTR_SOURCE_HIGH_G_REG,
   4445                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4446          			*intr_source_u8 = BMA2x2_GET_BITSLICE
   4447                          (data_u8, BMA2x2_UNFILT_INTR_SOURCE_HIGH_G);
   4448                      break;
   4449                    case BMA2x2_SOURCE_SLOPE:
   4450          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4451                          (p_bma2x2->dev_addr,
   4452                           BMA2x2_UNFILT_INTR_SOURCE_SLOPE_REG,
   4453                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4454          			*intr_source_u8 = BMA2x2_GET_BITSLICE
   4455                          (data_u8, BMA2x2_UNFILT_INTR_SOURCE_SLOPE);
   4456                      break;
   4457                    case BMA2x2_SOURCE_SLOW_NO_MOTION:
   4458          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4459                          (p_bma2x2->dev_addr,
   4460                           BMA2x2_UNFILT_INTR_SOURCE_SLOW_NO_MOTION_REG,
   4461                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4462          			*intr_source_u8 = BMA2x2_GET_BITSLICE
   4463                          (data_u8, BMA2x2_UNFILT_INTR_SOURCE_SLOW_NO_MOTION);
   4464                      break;
   4465                    case BMA2x2_SOURCE_TAP:
   4466          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4467                          (p_bma2x2->dev_addr,
   4468                           BMA2x2_UNFILT_INTR_SOURCE_TAP_REG,
   4469                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4470          			*intr_source_u8 = BMA2x2_GET_BITSLICE
   4471                          (data_u8, BMA2x2_UNFILT_INTR_SOURCE_TAP);
   4472                      break;
   4473                    case BMA2x2_SOURCE_DATA:
   4474          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4475                          (p_bma2x2->dev_addr,
   4476                           BMA2x2_UNFILT_INTR_SOURCE_DATA_REG,
   4477                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4478          			*intr_source_u8 = BMA2x2_GET_BITSLICE
   4479                          (data_u8, BMA2x2_UNFILT_INTR_SOURCE_DATA);
   4480                      break;
   4481                    default:
   4482          			com_rslt = E_OUT_OF_RANGE;
   4483                      break;
   4484                  }
   4485              }
   4486          	return com_rslt;
   4487          }
   4488          /*!
   4489          *	@brief This API is used to set
   4490          *	the source data status of source data,
   4491          *	source slow no motion, source slope, source high
   4492          *	and source low in the register 0x1E bit from 0 to 5
   4493          *
   4494          *
   4495          *
   4496          *  @param channel_u8 : The value of source select
   4497          *       channel_u8     |    result
   4498          *       -----------------| ------------------
   4499          *               0        | BMA2x2_ACCEL_SOURCE_LOW_G
   4500          *               1        | BMA2x2_ACCEL_SOURCE_HIGH_G
   4501          *               2        | BMA2x2_ACCEL_SOURCE_SLOPE
   4502          *               3        | BMA2x2_ACCEL_SOURCE_SLOW_NO_MOTION
   4503          *               4        | BMA2x2_ACCEL_SOURCE_TAP
   4504          *               5        | BMA2x2_ACCEL_SOURCE_DATA
   4505          *
   4506          *	@param intr_source_u8: The source status enable value
   4507          *       intr_source_u8         |    result
   4508          *       ------------------------ | ------------------
   4509          *              0x00              | INTR_DISABLE
   4510          *              0x01              | INTR_ENABLE
   4511          *
   4512          *	@return results of bus communication function
   4513          *	@retval 0 -> Success
   4514          *	@retval -1 -> Error
   4515          *
   4516          */
   4517          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_source(u8 channel_u8,
   4518                                                        u8 intr_source_u8)
   4519          {
   4520          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4521          	/*  Variable used to return value of
   4522          	communication routine*/
   4523          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4524              if (p_bma2x2 == BMA2x2_NULL) {
   4525                  com_rslt = E_BMA2x2_NULL_PTR;
   4526              } else {
   4527          		switch (channel_u8) {
   4528                      /* write the source interrupt register*/
   4529                    case BMA2x2_SOURCE_LOW_G:
   4530          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4531                          (p_bma2x2->dev_addr,
   4532                           BMA2x2_UNFILT_INTR_SOURCE_LOW_G_REG,
   4533                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4534          			data_u8 = BMA2x2_SET_BITSLICE
   4535                          (data_u8,
   4536                           BMA2x2_UNFILT_INTR_SOURCE_LOW_G, intr_source_u8);
   4537          			com_rslt += bma2x2_write_reg(
   4538                                                   BMA2x2_UNFILT_INTR_SOURCE_LOW_G_REG,
   4539                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4540                      break;
   4541                    case BMA2x2_SOURCE_HIGH_G:
   4542          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4543                          (p_bma2x2->dev_addr,
   4544                           BMA2x2_UNFILT_INTR_SOURCE_HIGH_G_REG,
   4545                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4546          			data_u8 = BMA2x2_SET_BITSLICE
   4547                          (data_u8,
   4548                           BMA2x2_UNFILT_INTR_SOURCE_HIGH_G, intr_source_u8);
   4549          			com_rslt += bma2x2_write_reg(
   4550                                                   BMA2x2_UNFILT_INTR_SOURCE_HIGH_G_REG,
   4551                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4552                      break;
   4553                    case BMA2x2_SOURCE_SLOPE:
   4554          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4555                          (p_bma2x2->dev_addr,
   4556                           BMA2x2_UNFILT_INTR_SOURCE_SLOPE_REG,
   4557                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4558          			data_u8 = BMA2x2_SET_BITSLICE
   4559                          (data_u8,
   4560                           BMA2x2_UNFILT_INTR_SOURCE_SLOPE, intr_source_u8);
   4561          			com_rslt += bma2x2_write_reg(
   4562                                                   BMA2x2_UNFILT_INTR_SOURCE_SLOPE_REG,
   4563                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4564                      break;
   4565                    case BMA2x2_SOURCE_SLOW_NO_MOTION:
   4566          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4567                          (p_bma2x2->dev_addr,
   4568                           BMA2x2_UNFILT_INTR_SOURCE_SLOW_NO_MOTION_REG,
   4569                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4570          			data_u8 = BMA2x2_SET_BITSLICE
   4571                          (data_u8,
   4572                           BMA2x2_UNFILT_INTR_SOURCE_SLOW_NO_MOTION,
   4573                           intr_source_u8);
   4574          			com_rslt += bma2x2_write_reg(
   4575                                                   BMA2x2_UNFILT_INTR_SOURCE_SLOW_NO_MOTION_REG,
   4576                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4577                      break;
   4578                    case BMA2x2_SOURCE_TAP:
   4579          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4580                          (p_bma2x2->dev_addr,
   4581                           BMA2x2_UNFILT_INTR_SOURCE_TAP_REG,
   4582                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4583          			data_u8 = BMA2x2_SET_BITSLICE
   4584                          (data_u8, BMA2x2_UNFILT_INTR_SOURCE_TAP,
   4585                           intr_source_u8);
   4586          			com_rslt += bma2x2_write_reg(
   4587                                                   BMA2x2_UNFILT_INTR_SOURCE_TAP_REG,
   4588                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4589                      break;
   4590                    case BMA2x2_SOURCE_DATA:
   4591          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4592                          (p_bma2x2->dev_addr,
   4593                           BMA2x2_UNFILT_INTR_SOURCE_DATA_REG,
   4594                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4595          			data_u8 = BMA2x2_SET_BITSLICE
   4596                          (data_u8, BMA2x2_UNFILT_INTR_SOURCE_DATA,
   4597                           intr_source_u8);
   4598          			com_rslt += bma2x2_write_reg(
   4599                                                   BMA2x2_UNFILT_INTR_SOURCE_DATA_REG,
   4600                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4601                      break;
   4602                    default:
   4603          			com_rslt = E_OUT_OF_RANGE;
   4604                      break;
   4605          		}
   4606          	}
   4607          	return com_rslt;
   4608          }
   4609          /*!
   4610          *	@brief This API is used to get
   4611          *	the interrupt output type in the register 0x20.
   4612          *	@note INTR1 -> bit 1
   4613          *	@note INTR2 -> bit 3
   4614          *
   4615          *  @param channel_u8: The value of output type select
   4616          *       channel_u8     |    result
   4617          *       -----------------| ------------------
   4618          *               0        | BMA2x2_ACCEL_INTR1_OUTPUT
   4619          *               1        | BMA2x2_ACCEL_INTR2_OUTPUT
   4620          *
   4621          *	@param intr_output_type_u8: The value of output type select
   4622          *       intr_source_u8         |    result
   4623          *       ------------------------ | ------------------
   4624          *              0x01              | OPEN_DRAIN
   4625          *              0x00              | PUSS_PULL
   4626          *
   4627          *
   4628          *
   4629          *	@return results of bus communication function
   4630          *	@retval 0 -> Success
   4631          *	@retval -1 -> Error
   4632          *
   4633          *
   4634          */
   4635          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_output_type(u8 channel_u8,
   4636                                                                  u8 *intr_output_type_u8)
   4637          {
   4638              u8 data_u8 = BMA2x2_INIT_VALUE;
   4639              /*  Variable used to return value of
   4640              communication routine*/
   4641              BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4642              
   4643              if (p_bma2x2 == BMA2x2_NULL) {
   4644                  com_rslt = E_BMA2x2_NULL_PTR;
   4645              } else {
   4646          		switch (channel_u8) {
   4647                      /* read the output type */
   4648                    case BMA2x2_INTR1_OUTPUT:
   4649          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4650                          (p_bma2x2->dev_addr,
   4651                           BMA2x2_INTR1_PAD_OUTPUT_TYPE_REG,
   4652                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4653          			*intr_output_type_u8 = BMA2x2_GET_BITSLICE
   4654                          (data_u8, BMA2x2_INTR1_PAD_OUTPUT_TYPE);
   4655                      break;
   4656                    case BMA2x2_INTR2_OUTPUT:
   4657          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4658                          (p_bma2x2->dev_addr,
   4659                           BMA2x2_INTR2_PAD_OUTPUT_TYPE_REG,
   4660                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4661          			*intr_output_type_u8 = BMA2x2_GET_BITSLICE
   4662                          (data_u8, BMA2x2_INTR2_PAD_OUTPUT_TYPE);
   4663                      break;
   4664                    default:
   4665          			com_rslt = E_OUT_OF_RANGE;
   4666                      break;
   4667          		}
   4668          	}
   4669          	return com_rslt;
   4670          }
   4671          /*!
   4672          *	@brief This API is used to set
   4673          *	the interrupt output type in the register 0x20.
   4674          *	@note INTR1 -> bit 1
   4675          *	@note INTR2 -> bit 3
   4676          *
   4677          *  @param channel_u8: The value of output type select
   4678          *         channel_u8   |    result
   4679          *       -----------------| ------------------
   4680          *               0        | BMA2x2_ACCEL_INTR1_OUTPUT
   4681          *               1        | BMA2x2_ACCEL_INTR2_OUTPUT
   4682          *
   4683          *	@param intr_output_type_u8: The value of output type select
   4684          *       intr_source_u8         |    result
   4685          *       ------------------------ | ------------------
   4686          *              0x01              | OPEN_DRAIN
   4687          *              0x00              | PUSS_PULL
   4688          *
   4689          *
   4690          *
   4691          *	@return results of bus communication function
   4692          *	@retval 0 -> Success
   4693          *	@retval -1 -> Error
   4694          *
   4695          *
   4696          */
   4697          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_output_type(u8 channel_u8,
   4698                                                                  u8 intr_output_type_u8)
   4699          {
   4700              u8 data_u8 = BMA2x2_INIT_VALUE;
   4701              /*  Variable used to return value of
   4702              communication routine*/
   4703              BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4704              
   4705              if (p_bma2x2 == BMA2x2_NULL) {
   4706                  com_rslt = E_BMA2x2_NULL_PTR;
   4707              }  else {
   4708          		switch (channel_u8) {
   4709                      /* write the output type*/
   4710                    case BMA2x2_INTR1_OUTPUT:
   4711          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4712                          (p_bma2x2->dev_addr,
   4713                           BMA2x2_INTR1_PAD_OUTPUT_TYPE_REG,
   4714                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4715          			data_u8 = BMA2x2_SET_BITSLICE
   4716                          (data_u8,
   4717                           BMA2x2_INTR1_PAD_OUTPUT_TYPE, intr_output_type_u8);
   4718          			com_rslt += bma2x2_write_reg(
   4719                                                   BMA2x2_INTR1_PAD_OUTPUT_TYPE_REG,
   4720                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4721                      break;
   4722                    case BMA2x2_INTR2_OUTPUT:
   4723          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4724                          (p_bma2x2->dev_addr,
   4725                           BMA2x2_INTR2_PAD_OUTPUT_TYPE_REG,
   4726                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4727          			data_u8 = BMA2x2_SET_BITSLICE
   4728                          (data_u8,
   4729                           BMA2x2_INTR2_PAD_OUTPUT_TYPE, intr_output_type_u8);
   4730          			com_rslt += bma2x2_write_reg(
   4731                                                   BMA2x2_INTR2_PAD_OUTPUT_TYPE_REG,
   4732                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4733                      break;
   4734                    default:
   4735          			com_rslt = E_OUT_OF_RANGE;
   4736                      break;
   4737          		}
   4738          	}
   4739          	return com_rslt;
   4740          }
   4741          /*!
   4742          *	@brief This API is used to get
   4743          *	Active Level status in the register 0x20
   4744          *	@note INTR1 -> bit 0
   4745          *	@note INTR2 -> bit 2
   4746          *
   4747          *  @param channel_u8: The value of Active Level select
   4748          *       channel_u8     |    result
   4749          *       -----------------| ------------------
   4750          *               0        | BMA2x2_ACCEL_INTR1_LEVEL
   4751          *               1        | BMA2x2_ACCEL_INTR2_LEVEL
   4752          *
   4753          *  @param intr_level_u8: The Active Level status enable value
   4754          *        intr_level_u8         |    result
   4755          *       ------------------------ | ------------------
   4756          *              0x01              | ACTIVE_HIGH
   4757          *              0x00              | ACTIVE_LOW
   4758          *
   4759          *
   4760          *	@return results of bus communication function
   4761          *	@retval 0 -> Success
   4762          *	@retval -1 -> Error
   4763          *
   4764          *
   4765          */
   4766          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_intr_level(u8 channel_u8,
   4767                                                            u8 *intr_level_u8)
   4768          {
   4769              u8 data_u8 = BMA2x2_INIT_VALUE;
   4770              /*  Variable used to return value of
   4771              communication routine*/
   4772              BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4773              
   4774              if (p_bma2x2 == BMA2x2_NULL) {
   4775                  com_rslt = E_BMA2x2_NULL_PTR;
   4776              } else {
   4777          		switch (channel_u8) {
   4778                      /* read the active level*/
   4779                    case BMA2x2_INTR1_LEVEL:
   4780          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4781                          (p_bma2x2->dev_addr,
   4782                           BMA2x2_INTR1_PAD_ACTIVE_LEVEL_REG,
   4783                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4784          			*intr_level_u8 = BMA2x2_GET_BITSLICE
   4785                          (data_u8, BMA2x2_INTR1_PAD_ACTIVE_LEVEL);
   4786                      break;
   4787                    case BMA2x2_INTR2_LEVEL:
   4788          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4789                          (p_bma2x2->dev_addr,
   4790                           BMA2x2_INTR2_PAD_ACTIVE_LEVEL_REG,
   4791                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4792          			*intr_level_u8 = BMA2x2_GET_BITSLICE
   4793                          (data_u8, BMA2x2_INTR2_PAD_ACTIVE_LEVEL);
   4794                      break;
   4795                    default:
   4796          			com_rslt = E_OUT_OF_RANGE;
   4797                      break;
   4798          		}
   4799          	}
   4800          	return com_rslt;
   4801          }
   4802          /*!
   4803          *	@brief This API is used to set
   4804          *	Active Level status in the register 0x20
   4805          *	@note INTR1 -> bit 0
   4806          *	@note INTR2 -> bit 2
   4807          *
   4808          *  @param channel_u8: The value of Active Level select
   4809          *       channel_u8     |    result
   4810          *       -----------------| ------------------
   4811          *               0        | BMA2x2_ACCEL_INTR1_LEVEL
   4812          *               1        | BMA2x2_ACCEL_INTR2_LEVEL
   4813          *
   4814          *  @param intr_level_u8: The Active Level status enable value
   4815          *       intr_level_u8          |    result
   4816          *       ------------------------ | ------------------
   4817          *              0x01              | ACTIVE_HIGH
   4818          *              0x00              | ACTIVE_LOW
   4819          *
   4820          *
   4821          *	@return results of bus communication function
   4822          *	@retval 0 -> Success
   4823          *	@retval -1 -> Error
   4824          *
   4825          *
   4826          */
   4827          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_intr_level(u8 channel_u8,
   4828                                                            u8 intr_level_u8)
   4829          {
   4830              u8 data_u8 = BMA2x2_INIT_VALUE;
   4831              /*  Variable used to return value of
   4832              communication routine*/
   4833              BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4834              
   4835              if (p_bma2x2 == BMA2x2_NULL) {
   4836                  com_rslt = E_BMA2x2_NULL_PTR;
   4837              } else {
   4838          		switch (channel_u8) {
   4839                      /* write the active level */
   4840                    case BMA2x2_INTR1_LEVEL:
   4841          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4842                          (p_bma2x2->dev_addr,
   4843                           BMA2x2_INTR1_PAD_ACTIVE_LEVEL_REG,
   4844                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4845          			data_u8 = BMA2x2_SET_BITSLICE
   4846                          (data_u8,
   4847                           BMA2x2_INTR1_PAD_ACTIVE_LEVEL, intr_level_u8);
   4848          			com_rslt += bma2x2_write_reg(
   4849                                                   BMA2x2_INTR1_PAD_ACTIVE_LEVEL_REG,
   4850                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4851                      break;
   4852                    case BMA2x2_INTR2_LEVEL:
   4853          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4854                          (p_bma2x2->dev_addr,
   4855                           BMA2x2_INTR2_PAD_ACTIVE_LEVEL_REG,
   4856                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4857          			data_u8 = BMA2x2_SET_BITSLICE
   4858                          (data_u8,
   4859                           BMA2x2_INTR2_PAD_ACTIVE_LEVEL, intr_level_u8);
   4860          			com_rslt += bma2x2_write_reg(
   4861                                                   BMA2x2_INTR2_PAD_ACTIVE_LEVEL_REG,
   4862                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4863                      break;
   4864                    default:
   4865          			com_rslt = E_OUT_OF_RANGE;
   4866                      break;
   4867          		}
   4868          	}
   4869          	return com_rslt;
   4870          }
   4871          /*!
   4872          *	@brief This API is used to set
   4873          *	the reset interrupt in the register 0x21 bit 7
   4874          *
   4875          *
   4876          *
   4877          *  @param  rst_intr_u8: The value of reset interrupt
   4878          *          rst_intr_u8         |  result
   4879          *       ------------------------ | ------------------
   4880          *              0x01              | clear any latch interrupt
   4881          *              0x00              | keep latch interrupt active
   4882          *
   4883          *
   4884          *	@return results of bus communication function
   4885          *	@retval 0 -> Success
   4886          *	@retval -1 -> Error
   4887          *
   4888          *
   4889          */
   4890          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_rst_intr(u8 rst_intr_u8)
   4891          {
   4892          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4893              /*  Variable used to return value of
   4894          	communication routine*/
   4895          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4896              
   4897          	if (p_bma2x2 == BMA2x2_NULL) {
   4898          		/* Check the struct p_bma2x2 is empty */
   4899          		return E_BMA2x2_NULL_PTR;
   4900              } else {
   4901                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4902          			(p_bma2x2->dev_addr, BMA2x2_RESET_INTR_REG,
   4903                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4904                  data_u8 = BMA2x2_SET_BITSLICE
   4905          			(data_u8, BMA2x2_RESET_INTR, rst_intr_u8);
   4906                  com_rslt += bma2x2_write_reg(BMA2x2_RESET_INTR_REG,
   4907                                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4908              }
   4909          	return com_rslt;
   4910          }
   4911          /*!
   4912          *	@brief This API is used to get
   4913          *	the latch duration in the register 0x21 bit from 0 to 3
   4914          *
   4915          *	@param latch_intr_u8: The value of latch duration
   4916          *        latch_intr_u8 |  result
   4917          *       -----------------| ------------------
   4918          *               0x00     | BMA2x2_LATCH_DURN_NON_LATCH
   4919          *               0x01     | BMA2x2_LATCH_DURN_250MS
   4920          *               0x02     | BMA2x2_LATCH_DURN_500MS
   4921          *               0x03     | BMA2x2_LATCH_DURN_1S
   4922          *               0x04     | BMA2x2_LATCH_DURN_2S
   4923          *               0x05     | BMA2x2_LATCH_DURN_4S
   4924          *               0x06     | BMA2x2_LATCH_DURN_8S
   4925          *               0x07     | BMA2x2_LATCH_DURN_LATCH
   4926          *               0x08     | BMA2x2_LATCH_DURN_NON_LATCH1
   4927          *               0x09     | BMA2x2_LATCH_DURN_250US
   4928          *               0x0A     | BMA2x2_LATCH_DURN_500US
   4929          *               0x0B     | BMA2x2_LATCH_DURN_1MS
   4930          *               0x0C     | BMA2x2_LATCH_DURN_12_5MS
   4931          *               0x0D     | BMA2x2_LATCH_DURN_25MS
   4932          *               0x0E     | BMA2x2_LATCH_DURN_50MS
   4933          *               0x0F     | BMA2x2_LATCH_DURN_LATCH1
   4934          *
   4935          *
   4936          *
   4937          *	@return results of bus communication function
   4938          *	@retval 0 -> Success
   4939          *	@retval -1 -> Error
   4940          *
   4941          *
   4942          */
   4943          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_latch_intr(u8 *latch_intr_u8)
   4944          {
   4945          	u8 data_u8 = BMA2x2_INIT_VALUE;
   4946          	/*  Variable used to return value of
   4947          	communication routine*/
   4948          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   4949              
   4950          	if (p_bma2x2 == BMA2x2_NULL) {
   4951          		/* Check the struct p_bma2x2 is empty */
   4952          		return E_BMA2x2_NULL_PTR;
   4953              } else {
   4954                  /* read the latch duration */
   4955                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   4956          			(p_bma2x2->dev_addr, BMA2x2_LATCH_INTR_REG,
   4957                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   4958                  *latch_intr_u8 = BMA2x2_GET_BITSLICE
   4959          			(data_u8, BMA2x2_LATCH_INTR);
   4960              }
   4961          	return com_rslt;
   4962          }
   4963          /*!
   4964          *	@brief This API is used to set
   4965          *	the latch duration in the register 0x21 bit from 0 to 3
   4966          *
   4967          *	@param latch_intr_u8: The value of latch duration
   4968          *        latch_intr_u8 |  result
   4969          *       -----------------| ------------------
   4970          *               0x00     | BMA2x2_LATCH_DURN_NON_LATCH
   4971          *               0x01     | BMA2x2_LATCH_DURN_250MS
   4972          *               0x02     | BMA2x2_LATCH_DURN_500MS
   4973          *               0x03     | BMA2x2_LATCH_DURN_1S
   4974          *               0x04     | BMA2x2_LATCH_DURN_2S
   4975          *               0x05     | BMA2x2_LATCH_DURN_4S
   4976          *               0x06     | BMA2x2_LATCH_DURN_8S
   4977          *               0x07     | BMA2x2_LATCH_DURN_LATCH
   4978          *               0x08     | BMA2x2_LATCH_DURN_NON_LATCH1
   4979          *               0x09     | BMA2x2_LATCH_DURN_250US
   4980          *               0x0A     | BMA2x2_LATCH_DURN_500US
   4981          *               0x0B     | BMA2x2_LATCH_DURN_1MS
   4982          *               0x0C     | BMA2x2_LATCH_DURN_12_5MS
   4983          *               0x0D     | BMA2x2_LATCH_DURN_25MS
   4984          *               0x0E     | BMA2x2_LATCH_DURN_50MS
   4985          *               0x0F     | BMA2x2_LATCH_DURN_LATCH1
   4986          *
   4987          *
   4988          *
   4989          *	@return results of bus communication function
   4990          *	@retval 0 -> Success
   4991          *	@retval -1 -> Error
   4992          *
   4993          *
   4994          */
   4995          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_latch_intr(u8 latch_intr_u8)
   4996          {
   4997              u8 data_u8 = BMA2x2_INIT_VALUE;
   4998              /*  Variable used to return value of
   4999              communication routine*/
   5000              BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5001              u8 latch_durn_u8 = BMA2x2_INIT_VALUE;
   5002              if (p_bma2x2 == BMA2x2_NULL)  {
   5003          		/* Check the struct p_bma2x2 is empty */
   5004          		return E_BMA2x2_NULL_PTR;
   5005              } else  {
   5006          		if (latch_intr_u8 < BMA2x2_ACCEL_BW_MAX_RANGE) {
   5007          			switch (latch_intr_u8) {
   5008                        case BMA2x2_LATCH_DURN_NON_LATCH:
   5009          				latch_durn_u8 = BMA2x2_LATCH_DURN_NON_LATCH;
   5010                          
   5011          				/*  NON LATCH   */
   5012                          break;
   5013                        case BMA2x2_LATCH_DURN_250MS:
   5014          				latch_durn_u8 = BMA2x2_LATCH_DURN_250MS;
   5015                          
   5016          				/*  250 MS  */
   5017                          break;
   5018                        case BMA2x2_LATCH_DURN_500MS:
   5019          				latch_durn_u8 = BMA2x2_LATCH_DURN_500MS;
   5020                          
   5021          				/*  500 MS  */
   5022                          break;
   5023                        case BMA2x2_LATCH_DURN_1S:
   5024          				latch_durn_u8 = BMA2x2_LATCH_DURN_1S;
   5025                          
   5026          				/*  1 S   */
   5027                          break;
   5028                        case BMA2x2_LATCH_DURN_2S:
   5029          				latch_durn_u8 = BMA2x2_LATCH_DURN_2S;
   5030                          
   5031          				/*  2 S  */
   5032                          break;
   5033                        case BMA2x2_LATCH_DURN_4S:
   5034          				latch_durn_u8 = BMA2x2_LATCH_DURN_4S;
   5035                          
   5036          				/*  4 S  */
   5037                          break;
   5038                        case BMA2x2_LATCH_DURN_8S:
   5039          				latch_durn_u8 = BMA2x2_LATCH_DURN_8S;
   5040                          
   5041          				/*  8 S  */
   5042                          break;
   5043                        case BMA2x2_LATCH_DURN_LATCH:
   5044          				latch_durn_u8 = BMA2x2_LATCH_DURN_LATCH;
   5045                          
   5046          				/*  LATCH  */
   5047                          break;
   5048                        case BMA2x2_LATCH_DURN_NON_LATCH1:
   5049          				latch_durn_u8 = BMA2x2_LATCH_DURN_NON_LATCH1;
   5050                          
   5051          				/*  NON LATCH1  */
   5052                          break;
   5053                        case BMA2x2_LATCH_DURN_250US:
   5054          				latch_durn_u8 = BMA2x2_LATCH_DURN_250US;
   5055                          
   5056          				/*  250 US   */
   5057                          break;
   5058                        case BMA2x2_LATCH_DURN_500US:
   5059          				latch_durn_u8 = BMA2x2_LATCH_DURN_500US;
   5060                          
   5061          				/*  500 US   */
   5062                          break;
   5063                        case BMA2x2_LATCH_DURN_1MS:
   5064          				latch_durn_u8 = BMA2x2_LATCH_DURN_1MS;
   5065                          
   5066          				/*  1 MS   */
   5067                          break;
   5068                        case BMA2x2_LATCH_DURN_12_5MS:
   5069          				latch_durn_u8 = BMA2x2_LATCH_DURN_12_5MS;
   5070                          
   5071          				/*  12.5 MS   */
   5072                          break;
   5073                        case BMA2x2_LATCH_DURN_25MS:
   5074          				latch_durn_u8 = BMA2x2_LATCH_DURN_25MS;
   5075                          
   5076          				/*  25 MS   */
   5077                          break;
   5078                        case BMA2x2_LATCH_DURN_50MS:
   5079          				latch_durn_u8 = BMA2x2_LATCH_DURN_50MS;
   5080                          
   5081          				/*  50 MS   */
   5082                          break;
   5083                        case BMA2x2_LATCH_DURN_LATCH1:
   5084          				latch_durn_u8 = BMA2x2_LATCH_DURN_LATCH1;
   5085                          
   5086          				/*  LATCH1   */
   5087                          break;
   5088                        default:
   5089                          break;
   5090          			}
   5091          			/* write the latch duration */
   5092          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5093                          (p_bma2x2->dev_addr, BMA2x2_LATCH_INTR_REG,
   5094                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5095          			data_u8 = BMA2x2_SET_BITSLICE
   5096                          (data_u8, BMA2x2_LATCH_INTR, latch_durn_u8);
   5097          			com_rslt += bma2x2_write_reg(BMA2x2_LATCH_INTR_REG,
   5098                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5099          		} else {
   5100                      com_rslt = E_OUT_OF_RANGE;
   5101          		}
   5102          	}
   5103          	return com_rslt;
   5104          }
   5105          /*!
   5106          *	@brief This API is used to get the duration of
   5107          *	Low, High, Slope and slow no motion interrupts in the registers
   5108          *	@note LOW_DURN		-> register 0x22 bit form 0 to 7
   5109          *	@note HIGH_DURN		-> register 0x25 bit form 0 to 7
   5110          *	@note SLOPE_DURN		-> register 0x27 bit form 0 to 1
   5111          *	@note SLO_NO_MOT_DURN -> register 0x27 bit form 2 to 7
   5112          *
   5113          *  @param channel_u8: The value of duration select
   5114          *     channel_u8   | result
   5115          *   -----------------| ------------------
   5116          *               0    | BMA2x2_ACCEL_LOW_DURN
   5117          *               1    | BMA2x2_ACCEL_HIGH_DURN
   5118          *               2    | BMA2x2_ACCEL_SLOPE_DURN
   5119          *               3    | BMA2x2_ACCEL_SLOW_NO_MOTION_DURN
   5120          *
   5121          *	@param durn_u8: The value of duration
   5122          *
   5123          *	@note :
   5124          *     Duration           |    result
   5125          * -----------------------| ------------------
   5126          * BMA2x2_ACCEL_LOW_DURN  | Low-g interrupt trigger
   5127          *         -              | delay according to([durn_u8 +1]*2)ms
   5128          *         -              | range from 2ms to 512ms. default is 20ms
   5129          * BMA2x2_ACCEL_HIGH_DURN | high-g interrupt trigger
   5130          *         -              | delay according to([durn_u8 +1]*2)ms
   5131          *         -              | range from 2ms to 512ms. default is 32ms
   5132          * BMA2x2_ACCEL_SLOPE_DURN| slope interrupt trigger
   5133          *         -              | if[durn_u8<1:0>+1] consecutive data points
   5134          *         -              | are above the slope interrupt threshold
   5135          * SLO_NO_MOT_DURN        | Refer data sheet for clear information
   5136          *
   5137          *
   5138          *	@return results of bus communication function
   5139          *	@retval 0 -> Success
   5140          *	@retval -1 -> Error
   5141          *
   5142          *
   5143          */
   5144          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_durn(u8 channel_u8,
   5145                                                      u8 *durn_u8)
   5146          {
   5147          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5148          	/*  Variable used to return value of
   5149          	communication routine*/
   5150          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5151              
   5152          	if (p_bma2x2 == BMA2x2_NULL) {
   5153          		/* Check the struct p_bma2x2 is empty */
   5154          		return E_BMA2x2_NULL_PTR;
   5155              } else {
   5156          		/* write the duration data */
   5157          		switch (channel_u8) {
   5158                    case BMA2x2_LOW_DURN:
   5159          			/*LOW DURATION*/
   5160          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5161                          (p_bma2x2->dev_addr, BMA2x2_LOW_DURN_ADDR,
   5162                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5163          			*durn_u8 = data_u8;
   5164                      break;
   5165                    case BMA2x2_HIGH_DURN:
   5166          			/*HIGH DURATION*/
   5167          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5168                          (p_bma2x2->dev_addr, BMA2x2_HIGH_DURN_ADDR,
   5169                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5170          			*durn_u8 = data_u8;
   5171                      break;
   5172                    case BMA2x2_SLOPE_DURN:
   5173          			/*SLOPE DURATION*/
   5174          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5175                          (p_bma2x2->dev_addr, BMA2x2_SLOPE_DURN_REG,
   5176                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5177          			*durn_u8 = BMA2x2_GET_BITSLICE
   5178                          (data_u8, BMA2x2_SLOPE_DURN);
   5179                      break;
   5180                    case BMA2x2_SLOW_NO_MOTION_DURN:
   5181          			/*SLO NO MOT DURATION*/
   5182          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5183                          (p_bma2x2->dev_addr,
   5184                           BMA2x2_SLOW_NO_MOTION_DURN_REG,
   5185                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5186          			*durn_u8 = BMA2x2_GET_BITSLICE
   5187                          (data_u8, BMA2x2_SLOW_NO_MOTION_DURN);
   5188                      break;
   5189                    default:
   5190          			com_rslt = E_OUT_OF_RANGE;
   5191                      break;
   5192          		}
   5193          	}
   5194          	return com_rslt;
   5195          }
   5196          /*!
   5197          *	@brief This API is used to set the duration of
   5198          *	Low, High, Slope and slow no motion interrupts in the registers
   5199          *	@note LOW_DURN		-> register 0x22 bit form 0 to 7
   5200          *	@note HIGH_DURN		-> register 0x25 bit form 0 to 7
   5201          *	@note SLOPE_DURN		-> register 0x27 bit form 0 to 1
   5202          *	@note SLO_NO_MOT_DURN -> register 0x27 bit form 2 to 7
   5203          *
   5204          *  @param channel_u8: The value of duration select
   5205          *     channel_u8   | result
   5206          *   -----------------| ------------------
   5207          *               0    | BMA2x2_ACCEL_LOW_DURN
   5208          *               1    | BMA2x2_ACCEL_HIGH_DURN
   5209          *               2    | BMA2x2_ACCEL_SLOPE_DURN
   5210          *               3    | BMA2x2_ACCEL_SLOW_NO_MOTION_DURN
   5211          *
   5212          *	@param durn_u8: The value of duration
   5213          *
   5214          *	@note :
   5215          *     Duration           |    result
   5216          * -----------------------| ------------------
   5217          * BMA2x2_ACCEL_LOW_DURN  | Low-g interrupt trigger
   5218          *         -              | delay according to([durn_u8 +1]*2)ms
   5219          *         -              | range from 2ms to 512ms. default is 20ms
   5220          * BMA2x2_ACCEL_HIGH_DURN | high-g interrupt trigger
   5221          *         -              | delay according to([durn_u8 +1]*2)ms
   5222          *         -              | range from 2ms to 512ms. default is 32ms
   5223          * BMA2x2_ACCEL_SLOPE_DURN| slope interrupt trigger
   5224          *         -              | if[durn_u8<1:0>+1] consecutive data points
   5225          *         -              | are above the slope interrupt threshold
   5226          * SLO_NO_MOT_DURN        | Refer data sheet for clear information
   5227          *
   5228          *
   5229          *	@return results of bus communication function
   5230          *	@retval 0 -> Success
   5231          *	@retval -1 -> Error
   5232          *
   5233          *
   5234          */
   5235          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_durn(u8 channel_u8,
   5236                                                      u8 durn_u8)
   5237          {
   5238          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5239              /*  Variable used to return value of
   5240          	communication routine*/
   5241          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5242              
   5243          	if (p_bma2x2 == BMA2x2_NULL)  {
   5244          		/* Check the struct p_bma2x2 is empty */
   5245          		return E_BMA2x2_NULL_PTR;
   5246              }  else  {
   5247          		/* write duration data */
   5248          		switch (channel_u8)   {
   5249                    case BMA2x2_LOW_DURN:
   5250          			/*LOW DURATION*/
   5251          			data_u8 = durn_u8;
   5252          			com_rslt = bma2x2_write_reg(BMA2x2_LOW_DURN_ADDR,
   5253                                                  &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5254                      break;
   5255                    case BMA2x2_HIGH_DURN:
   5256          			/*HIGH DURATION*/
   5257          			data_u8 = durn_u8;
   5258          			com_rslt = bma2x2_write_reg(
   5259                                                  BMA2x2_HIGH_DURN_ADDR,
   5260                                                  &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5261                      break;
   5262                    case BMA2x2_SLOPE_DURN:
   5263          			/*SLOPE DURATION*/
   5264          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5265                          (p_bma2x2->dev_addr,
   5266                           BMA2x2_SLOPE_DURN_REG,
   5267                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5268          			data_u8 = BMA2x2_SET_BITSLICE
   5269                          (data_u8, BMA2x2_SLOPE_DURN, durn_u8);
   5270          			com_rslt += bma2x2_write_reg(
   5271                                                   BMA2x2_SLOPE_DURN_REG,
   5272                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5273                      break;
   5274                    case BMA2x2_SLOW_NO_MOTION_DURN:
   5275          			/*SLO NO MOT DURATION*/
   5276          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5277                          (p_bma2x2->dev_addr,
   5278                           BMA2x2_SLOW_NO_MOTION_DURN_REG,
   5279                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5280          			data_u8 = BMA2x2_SET_BITSLICE
   5281                          (data_u8, BMA2x2_SLOW_NO_MOTION_DURN, durn_u8);
   5282          			com_rslt += bma2x2_write_reg(
   5283                                                   BMA2x2_SLOW_NO_MOTION_DURN_REG,
   5284                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5285                      break;
   5286                    default:
   5287          			com_rslt = E_OUT_OF_RANGE;
   5288                      break;
   5289          		}
   5290          	}
   5291          	return com_rslt;
   5292          }
   5293          /*!
   5294          * @brief This API is used to get the threshold of
   5295          *	Low, High, Slope and slow no motion interrupts in the registers
   5296          *	@note LOW_THRES		-> register 0x23 bit form 0 to 7
   5297          *	@note HIGH_THRES		-> register 0x26 bit form 0 to 7
   5298          *	@note SLOPE_THRES		-> register 0x28 bit form 0 to 7
   5299          *	@note SLO_NO_MOT_THRES -> register 0x29 bit form 0 to 7
   5300          *
   5301          *  @param channel_u8: The value of threshold selection
   5302          *     channel_u8   | result
   5303          *   -----------------| ------------------
   5304          *               0    | BMA2x2_ACCEL_LOW_THRES
   5305          *               1    | BMA2x2_ACCEL_HIGH_THRES
   5306          *               2    | BMA2x2_ACCEL_SLOPE_THRES
   5307          *               3    | BMA2x2_ACCEL_SLOW_NO_MOTION_THRES
   5308          *
   5309          *  @param thres_u8: The threshold value of selected interrupts
   5310          *
   5311          *	@note : LOW-G THRESHOLD
   5312          *     Threshold                    |    result
   5313          * ---------------------------------| ------------------
   5314          * BMA2x2_ACCEL_LOW_THRES           | Low-threshold interrupt trigger
   5315          *                                  | according to(thres_u8 * 7.81) mg
   5316          *                                  | range from 0g to 1.992g
   5317          *                                  | default is 375mg
   5318          *	@note : HIGH-G THRESHOLD
   5319          *	@note Threshold of high-g interrupt according to accel g range
   5320          *    g-range           |      High-g threshold
   5321          *  --------------------|----------------------------
   5322          *     2g               |    (thres_u8 * 7.81) mg
   5323          *     4g               |    (thres_u8 * 15.63) mg
   5324          *     8g               |    (thres_u8 * 31.25) mg
   5325          *     16g              |    (thres_u8 * 62.5) mg
   5326          *
   5327          *	@note : SLOPE THRESHOLD
   5328          *	@note Threshold of slope interrupt according to accel g range
   5329          *    g-range           |      Slope threshold
   5330          *  --------------------|----------------------------
   5331          *     2g               |    (thres_u8 * 3.19) mg
   5332          *     4g               |    (thres_u8 * 7.81) mg
   5333          *     8g               |    (thres_u8 * 15.63) mg
   5334          *     16g              |    (thres_u8 * 31.25) mg
   5335          *
   5336          *	@note : SLOW NO MOTION THRESHOLD
   5337          *	@note Threshold of slow no motion interrupt according to accel g range
   5338          *    g-range           |   slow no motion threshold
   5339          *  --------------------|----------------------------
   5340          *     2g               |    (thres_u8 * 3.19) mg
   5341          *     4g               |    (thres_u8 * 7.81) mg
   5342          *     8g               |    (thres_u8 * 15.63) mg
   5343          *     16g              |    (thres_u8 * 31.25) mg
   5344          *
   5345          *
   5346          *
   5347          *	@return results of bus communication function
   5348          *	@retval 0 -> Success
   5349          *	@retval -1 -> Error
   5350          *
   5351          *
   5352          */
   5353          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_thres(u8 channel_u8,
   5354                                                       u8 *thres_u8)
   5355          {
   5356          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5357          	/*  Variable used to return value of
   5358          	communication routine*/
   5359          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5360              
   5361          	if (p_bma2x2 == BMA2x2_NULL) {
   5362          		/* Check the struct p_bma2x2 is empty */
   5363          		return E_BMA2x2_NULL_PTR;
   5364              } else {
   5365          		switch (channel_u8) {
   5366                      /* Read the threshold value */
   5367                    case BMA2x2_LOW_THRES:
   5368          			/*LOW THRESHOLD*/
   5369          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5370                          (p_bma2x2->dev_addr, BMA2x2_LOW_THRES_ADDR,
   5371                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5372          			*thres_u8 = data_u8;
   5373                      break;
   5374                    case BMA2x2_HIGH_THRES:
   5375          			/*HIGH THRESHOLD*/
   5376          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5377                          (p_bma2x2->dev_addr,
   5378                           BMA2x2_HIGH_THRES_ADDR,
   5379                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5380          			*thres_u8 = data_u8;
   5381                      break;
   5382                    case BMA2x2_SLOPE_THRES:
   5383          			/*SLOPE THRESHOLD*/
   5384          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5385                          (p_bma2x2->dev_addr,
   5386                           BMA2x2_SLOPE_THRES_ADDR,
   5387                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5388          			*thres_u8 = data_u8;
   5389                      break;
   5390                    case BMA2x2_SLOW_NO_MOTION_THRES:
   5391          			/*SLO NO MOT THRESHOLD*/
   5392          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5393                          (p_bma2x2->dev_addr,
   5394                           BMA2x2_SLOW_NO_MOTION_THRES_ADDR,
   5395                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5396          			*thres_u8 = data_u8;
   5397                      break;
   5398                    default:
   5399          			com_rslt = E_OUT_OF_RANGE;
   5400                      break;
   5401          		}
   5402          	}
   5403          	return com_rslt;
   5404          }
   5405          /*!
   5406          * @brief This API is used to set the threshold of
   5407          *	Low, High, Slope and slow no motion interrupts in the registers
   5408          *	@note LOW_THRES		-> register 0x23 bit form 0 to 7
   5409          *	@note HIGH_THRES		-> register 0x26 bit form 0 to 7
   5410          *	@note SLOPE_THRES		-> register 0x28 bit form 0 to 7
   5411          *	@note SLO_NO_MOT_THRES -> register 0x29 bit form 0 to 7
   5412          *
   5413          *  @param channel_u8: The value of threshold selection
   5414          *     channel_u8   | result
   5415          *   -----------------| ------------------
   5416          *               0    | BMA2x2_ACCEL_LOW_THRES
   5417          *               1    | BMA2x2_ACCEL_HIGH_THRES
   5418          *               2    | BMA2x2_ACCEL_SLOPE_THRES
   5419          *               3    | BMA2x2_ACCEL_SLOW_NO_MOTION_THRES
   5420          *
   5421          *  @param thres_u8: The threshold value of selected interrupts
   5422          *
   5423          *	@note : LOW-G THRESHOLD
   5424          *     Threshold                    |    result
   5425          * ---------------------------------| ------------------
   5426          * BMA2x2_ACCEL_LOW_THRES           | Low-threshold interrupt trigger
   5427          *                                  | according to(thres_u8 * 7.81) mg
   5428          *                                  | range from 0g to 1.992g
   5429          *                                  | default is 375mg
   5430          *	@note : HIGH-G THRESHOLD
   5431          *	@note Threshold of high-g interrupt according to accel g range
   5432          *    g-range           |      High-g threshold
   5433          *  --------------------|----------------------------
   5434          *     2g               |    (thres_u8 * 7.81) mg
   5435          *     4g               |    (thres_u8 * 15.63) mg
   5436          *     8g               |    (thres_u8 * 31.25) mg
   5437          *     16g              |    (thres_u8 * 62.5) mg
   5438          *
   5439          *	@note : SLOPE THRESHOLD
   5440          *	@note Threshold of slope interrupt according to accel g range
   5441          *    g-range           |      Slope threshold
   5442          *  --------------------|----------------------------
   5443          *     2g               |    (thres_u8 * 3.19) mg
   5444          *     4g               |    (thres_u8 * 7.81) mg
   5445          *     8g               |    (thres_u8 * 15.63) mg
   5446          *     16g              |    (thres_u8 * 31.25) mg
   5447          *
   5448          *	@note : SLOW NO MOTION THRESHOLD
   5449          *	@note Threshold of slow no motion interrupt according to accel g range
   5450          *    g-range           |   slow no motion threshold
   5451          *  --------------------|----------------------------
   5452          *     2g               |    (thres_u8 * 3.19) mg
   5453          *     4g               |    (thres_u8 * 7.81) mg
   5454          *     8g               |    (thres_u8 * 15.63) mg
   5455          *     16g              |    (thres_u8 * 31.25) mg
   5456          *
   5457          *
   5458          *
   5459          *	@return results of bus communication function
   5460          *	@retval 0 -> Success
   5461          *	@retval -1 -> Error
   5462          *
   5463          *
   5464          */
   5465          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_thres(u8 channel_u8, u8 thres_u8)
   5466          {
   5467          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5468          	/*  Variable used to return value of
   5469          	communication routine*/
   5470          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5471              
   5472          	if (p_bma2x2 == BMA2x2_NULL) {
   5473          		/* Check the struct p_bma2x2 is empty */
   5474          		return E_BMA2x2_NULL_PTR;
   5475              } else {
   5476          		switch (channel_u8) {
   5477                      /* write the threshold value*/
   5478                    case BMA2x2_LOW_THRES:
   5479          			/*LOW THRESHOLD*/
   5480          			data_u8 = thres_u8;
   5481          			com_rslt = bma2x2_write_reg(BMA2x2_LOW_THRES_ADDR, &data_u8,
   5482                                                  BMA2x2_GEN_READ_WRITE_LENGTH);
   5483                      break;
   5484                    case BMA2x2_HIGH_THRES:
   5485          			/*HIGH THRESHOLD*/
   5486          			data_u8 = thres_u8;
   5487          			com_rslt = bma2x2_write_reg(BMA2x2_HIGH_THRES_ADDR, &data_u8,
   5488                                                  BMA2x2_GEN_READ_WRITE_LENGTH);
   5489                      break;
   5490                    case BMA2x2_SLOPE_THRES:
   5491          			/*SLOPE THRESHOLD*/
   5492          			data_u8 = thres_u8;
   5493          			com_rslt = bma2x2_write_reg(BMA2x2_SLOPE_THRES_ADDR, &data_u8,
   5494                                                  BMA2x2_GEN_READ_WRITE_LENGTH);
   5495                      break;
   5496                    case BMA2x2_SLOW_NO_MOTION_THRES:
   5497          			/*SLO NO MOT THRESHOLD*/
   5498          			data_u8 = thres_u8;
   5499          			com_rslt = bma2x2_write_reg(BMA2x2_SLOW_NO_MOTION_THRES_ADDR,
   5500                                                  &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5501                      break;
   5502                    default:
   5503          			com_rslt = E_OUT_OF_RANGE;
   5504                      break;
   5505          		}
   5506          	}
   5507          	return com_rslt;
   5508          }
   5509          /*!
   5510          *	@brief This API is used to get
   5511          *	the low high hysteresis in the registers 0x24
   5512          *	@note LOW_G_HYST  -> bit form 0 to 1
   5513          *	@note HIGH_G_HYST  -> bit from 6 to 7
   5514          *
   5515          *  @param channel_u8: The value of hysteresis selection
   5516          *     channel_u8   | result
   5517          *   -----------------| ------------------
   5518          *           0        | BMA2x2_ACCEL_LOW_G_HYST
   5519          *           1        | BMA2x2_ACCEL_HIGH_G_HYST
   5520          *
   5521          *  @param hyst_u8: The hysteresis data
   5522          *
   5523          *	@note LOW HYSTERESIS
   5524          *	@note Hysteresis of low-g interrupt according to (hyst_u8 * 125)mg
   5525          *
   5526          *	@note HIGH HYSTERESIS
   5527          *	@note High hysteresis depends on the accel range selection
   5528          *    g-range           |    High Hysteresis
   5529          *  --------------------|----------------------------
   5530          *     2g               |    (thres_u8 * 125) mg
   5531          *     4g               |    (thres_u8 * 250) mg
   5532          *     8g               |    (thres_u8 * 500) mg
   5533          *     16g              |    (thres_u8 * 1000) mg
   5534          *
   5535          *	@return results of bus communication function
   5536          *	@retval 0 -> Success
   5537          *	@retval -1 -> Error
   5538          *
   5539          *
   5540          */
   5541          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_low_high_g_hyst(u8 channel_u8,
   5542                                                                 u8 *hyst_u8)
   5543          {
   5544          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5545          	/*  Variable used to return value of
   5546          	communication routine*/
   5547          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5548              
   5549          	if (p_bma2x2 == BMA2x2_NULL) {
   5550          		/* Check the struct p_bma2x2 is empty */
   5551          		return E_BMA2x2_NULL_PTR;
   5552              } else {
   5553          		switch (channel_u8) {
   5554                      /* read the hysteresis data */
   5555                    case BMA2x2_LOW_G_HYST:
   5556          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5557                          (p_bma2x2->dev_addr,
   5558                           BMA2x2_LOW_G_HYST_REG,
   5559                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5560          			*hyst_u8 = BMA2x2_GET_BITSLICE
   5561                          (data_u8, BMA2x2_LOW_G_HYST);
   5562                      break;
   5563                    case BMA2x2_HIGH_G_HYST:
   5564          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5565                          (p_bma2x2->dev_addr,
   5566                           BMA2x2_HIGH_G_HYST_REG,
   5567                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5568          			*hyst_u8 = BMA2x2_GET_BITSLICE
   5569                          (data_u8, BMA2x2_HIGH_G_HYST);
   5570                      break;
   5571                    default:
   5572          			com_rslt = E_OUT_OF_RANGE;
   5573                      break;
   5574          		}
   5575          	}
   5576          	return com_rslt;
   5577          }
   5578          /*!
   5579          *	@brief This API is used to set
   5580          *	the low high hysteresis in the registers 0x24
   5581          *	@note LOW_G_HYST  -> bit form 0 to 1
   5582          *	@note HIGH_G_HYST  -> bit from 6 to 7
   5583          *
   5584          *  @param channel_u8: The value of hysteresis selection
   5585          *     channel_u8   | result
   5586          *   -----------------| ------------------
   5587          *           0        | BMA2x2_ACCEL_LOW_G_HYST
   5588          *           1        | BMA2x2_ACCEL_HIGH_G_HYST
   5589          *
   5590          *  @param hyst_u8: The hysteresis data
   5591          *
   5592          *	@note LOW HYSTERESIS
   5593          *	@note Hysteresis of low-g interrupt according to (hyst_u8 * 125)mg
   5594          *
   5595          *	@note HIGH HYSTERESIS
   5596          *	@note High hysteresis depends on the accel range selection
   5597          *    g-range           |    High Hysteresis
   5598          *  --------------------|----------------------------
   5599          *     2g               |    (thres_u8 * 125) mg
   5600          *     4g               |    (thres_u8 * 250) mg
   5601          *     8g               |    (thres_u8 * 500) mg
   5602          *     16g              |    (thres_u8 * 1000) mg
   5603          *
   5604          *	@return results of bus communication function
   5605          *	@retval 0 -> Success
   5606          *	@retval -1 -> Error
   5607          *
   5608          *
   5609          */
   5610          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_low_high_g_hyst(u8 channel_u8,
   5611                                                                 u8 hyst_u8)
   5612          {
   5613          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5614          	/*  Variable used to return value of
   5615          	communication routine*/
   5616          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5617              
   5618          	if (p_bma2x2 == BMA2x2_NULL) {
   5619          		/* Check the struct p_bma2x2 is empty */
   5620          		return E_BMA2x2_NULL_PTR;
   5621              } else {
   5622          		switch (channel_u8) {
   5623                      /* write the hysteresis data  */
   5624                    case BMA2x2_LOW_G_HYST:
   5625          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5626                          (p_bma2x2->dev_addr, BMA2x2_LOW_G_HYST_REG,
   5627                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5628          			data_u8 = BMA2x2_SET_BITSLICE
   5629                          (data_u8, BMA2x2_LOW_G_HYST, hyst_u8);
   5630          			com_rslt += bma2x2_write_reg(
   5631                                                   BMA2x2_LOW_G_HYST_REG,
   5632                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5633                      break;
   5634                    case BMA2x2_HIGH_G_HYST:
   5635          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5636                          (p_bma2x2->dev_addr,
   5637                           BMA2x2_HIGH_G_HYST_REG, &data_u8,
   5638                           BMA2x2_GEN_READ_WRITE_LENGTH);
   5639          			data_u8 = BMA2x2_SET_BITSLICE
   5640                          (data_u8, BMA2x2_HIGH_G_HYST, hyst_u8);
   5641          			com_rslt += bma2x2_write_reg(
   5642                                                   BMA2x2_HIGH_G_HYST_REG,
   5643                                                   &data_u8,  BMA2x2_GEN_READ_WRITE_LENGTH);
   5644                      break;
   5645                    default:
   5646          			com_rslt = E_OUT_OF_RANGE;
   5647                      break;
   5648          		}
   5649          	}
   5650          	return com_rslt;
   5651          }
   5652          /*!
   5653          *	@brief This API is used to get
   5654          *	low_g  mode in the registers 0x24 bit 2
   5655          *
   5656          *
   5657          *	@param low_g_mode_u8: The value of Low_G mode
   5658          *      low_g_mode_u8   |  g-result
   5659          *  --------------------|----------------------------
   5660          *     0x00             | LOW_G_SINGLE_AXIS_MODE
   5661          *     0x01             | LOW_G_SUMMING_MODE
   5662          *
   5663          *
   5664          *	@return results of bus communication function
   5665          *	@retval 0 -> Success
   5666          *	@retval -1 -> Error
   5667          *
   5668          *
   5669          */
   5670          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_low_g_mode(u8 *low_g_mode_u8)
   5671          {
   5672          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5673          	/*  Variable used to return value of
   5674          	communication routine*/
   5675          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5676              
   5677          	if (p_bma2x2 == BMA2x2_NULL) {
   5678          		/* Check the struct p_bma2x2 is empty */
   5679          		return E_BMA2x2_NULL_PTR;
   5680              } else {
   5681                  /* read the low-g mode*/
   5682                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5683          			(p_bma2x2->dev_addr, BMA2x2_LOW_G_INTR_MODE_REG,
   5684                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5685                  *low_g_mode_u8 = BMA2x2_GET_BITSLICE(data_u8,
   5686                                                       BMA2x2_LOW_G_INTR_MODE);
   5687              }
   5688          	return com_rslt;
   5689          }
   5690          /*!
   5691          *	@brief This API is used to set
   5692          *	low_g  mode in the registers 0x24 bit 2
   5693          *
   5694          *
   5695          *	@param low_g_mode_u8: The value of Low_G mode
   5696          *    low_g_mode_u8   |    result
   5697          *  --------------------|----------------------------
   5698          *     0x00             | LOW_G_SINGLE_AXIS_MODE
   5699          *     0x01             | LOW_G_SUMMING_MODE
   5700          *
   5701          *
   5702          *	@return results of bus communication function
   5703          *	@retval 0 -> Success
   5704          *	@retval -1 -> Error
   5705          *
   5706          *
   5707          */
   5708          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_low_g_mode(u8 low_g_mode_u8)
   5709          {
   5710          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5711          	/*  Variable used to return value of
   5712          	communication routine*/
   5713          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5714              
   5715          	if (p_bma2x2 == BMA2x2_NULL) {
   5716          		/* Check the struct p_bma2x2 is empty */
   5717          		return E_BMA2x2_NULL_PTR;
   5718              } else {
   5719                  /* write the low-g mode*/
   5720                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5721          			(p_bma2x2->dev_addr,
   5722                       BMA2x2_LOW_G_INTR_MODE_REG, &data_u8,
   5723                       BMA2x2_GEN_READ_WRITE_LENGTH);
   5724                  data_u8 = BMA2x2_SET_BITSLICE
   5725          			(data_u8, BMA2x2_LOW_G_INTR_MODE, low_g_mode_u8);
   5726                  com_rslt += bma2x2_write_reg(
   5727                                               BMA2x2_LOW_G_INTR_MODE_REG,
   5728                                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5729              }
   5730          	return com_rslt;
   5731          }
   5732          /*!
   5733          *	@brief This API is used to get
   5734          *	the tap duration in the register 0x2A bit form 0 to 2
   5735          *
   5736          *
   5737          *	@param tap_durn_u8: The value of tap duration
   5738          *    tap_durn_u8     |    result
   5739          *  --------------------|----------------------------
   5740          *     0x00             | TAP_DURN_50_MS
   5741          *     0x01             | TAP_DURN_100_MS
   5742          *     0x02             | TAP_DURN_150_MS
   5743          *     0x03             | TAP_DURN_200_MS
   5744          *     0x04             | TAP_DURN_250_MS
   5745          *     0x05             | TAP_DURN_375_MS
   5746          *     0x06             | TAP_DURN_500_MS
   5747          *     0x07             | TAP_DURN_700_MS
   5748          *
   5749          *
   5750          *
   5751          *	@return results of bus communication function
   5752          *	@retval 0 -> Success
   5753          *	@retval -1 -> Error
   5754          *
   5755          *
   5756          */
   5757          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_tap_durn(u8 *tap_durn_u8)
   5758          {
   5759          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5760          	/*  Variable used to return value of
   5761          	communication routine*/
   5762          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5763              
   5764          	if (p_bma2x2 == BMA2x2_NULL) {
   5765          		/* Check the struct p_bma2x2 is empty */
   5766          		return E_BMA2x2_NULL_PTR;
   5767              } else {
   5768                  /* read the tap duration*/
   5769                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5770          			(p_bma2x2->dev_addr,
   5771                       BMA2x2_TAP_DURN_REG, &data_u8,
   5772                       BMA2x2_GEN_READ_WRITE_LENGTH);
   5773                  *tap_durn_u8 = BMA2x2_GET_BITSLICE
   5774          			(data_u8, BMA2x2_TAP_DURN);
   5775              }
   5776          	return com_rslt;
   5777          }
   5778          /*!
   5779          *	@brief This API is used to set
   5780          *	the tap duration in the register 0x2A bit form 0 to 2
   5781          *
   5782          *
   5783          *	@param tap_durn_u8: The value of tap duration
   5784          *    tap_durn_u8     |    result
   5785          *  --------------------|----------------------
   5786          *     0x00             | TAP_DURN_50_MS
   5787          *     0x01             | TAP_DURN_100_MS
   5788          *     0x02             | TAP_DURN_150_MS
   5789          *     0x03             | TAP_DURN_200_MS
   5790          *     0x04             | TAP_DURN_250_MS
   5791          *     0x05             | TAP_DURN_375_MS
   5792          *     0x06             | TAP_DURN_500_MS
   5793          *     0x07             | TAP_DURN_700_MS
   5794          *
   5795          *
   5796          *
   5797          *	@return results of bus communication function
   5798          *	@retval 0 -> Success
   5799          *	@retval -1 -> Error
   5800          *
   5801          *
   5802          */
   5803          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_tap_durn(u8 tap_durn_u8)
   5804          {
   5805          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5806          	/*  Variable used to return value of
   5807          	communication routine*/
   5808          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5809              
   5810          	if (p_bma2x2 == BMA2x2_NULL) {
   5811          		/* Check the struct p_bma2x2 is empty */
   5812          		return E_BMA2x2_NULL_PTR;
   5813              } else {
   5814                  /* write the tap duration */
   5815                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   5816                                                            p_bma2x2->dev_addr,
   5817                                                            BMA2x2_TAP_DURN_REG, &data_u8,
   5818                                                            BMA2x2_GEN_READ_WRITE_LENGTH);
   5819                  data_u8 = BMA2x2_SET_BITSLICE
   5820          			(data_u8, BMA2x2_TAP_DURN, tap_durn_u8);
   5821                  com_rslt += bma2x2_write_reg(
   5822                                               BMA2x2_TAP_DURN_REG, &data_u8,
   5823                                               BMA2x2_GEN_READ_WRITE_LENGTH);
   5824              }
   5825          	return com_rslt;
   5826          }
   5827          /*!
   5828          *	@brief This API is used to get
   5829          *	the tap shock form the register 0x2A bit 6
   5830          *
   5831          *
   5832          *
   5833          *	@param tap_shock_u8: The value of tap shock
   5834          *    tap_shock_u8    |    result
   5835          *  --------------------|----------------------
   5836          *     0x00             | TAP_SHOCK_50_MS
   5837          *     0x01             | TAP_SHOCK_75_MS
   5838          *
   5839          *
   5840          *	@return results of bus communication function
   5841          *	@retval 0 -> Success
   5842          *	@retval -1 -> Error
   5843          *
   5844          *
   5845          */
   5846          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_tap_shock(u8 *tap_shock_u8)
   5847          {
   5848          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5849          	/*  Variable used to return value of
   5850          	communication routine*/
   5851          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5852              
   5853          	if (p_bma2x2 == BMA2x2_NULL) {
   5854          		/* Check the struct p_bma2x2 is empty */
   5855          		return E_BMA2x2_NULL_PTR;
   5856              } else {
   5857                  /* read tap shock value */
   5858                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5859          			(p_bma2x2->dev_addr,
   5860                       BMA2x2_TAP_SHOCK_DURN_REG,
   5861                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5862                  *tap_shock_u8 = BMA2x2_GET_BITSLICE(data_u8,
   5863                                                      BMA2x2_TAP_SHOCK_DURN);
   5864              }
   5865          	return com_rslt;
   5866          }
   5867          /*!
   5868          *	@brief This API is used to set
   5869          *	the tap shock form the register 0x2A bit 6
   5870          *
   5871          *
   5872          *
   5873          *	@param tap_shock_u8: The value of tap shock
   5874          *    tap_shock_u8    |    result
   5875          *  --------------------|----------------------
   5876          *     0x00             | TAP_SHOCK_50_MS
   5877          *     0x01             | TAP_SHOCK_75_MS
   5878          *
   5879          *
   5880          *	@return results of bus communication function
   5881          *	@retval 0 -> Success
   5882          *	@retval -1 -> Error
   5883          *
   5884          *
   5885          */
   5886          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_tap_shock(u8 tap_shock_u8)
   5887          {
   5888          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5889          	/*  Variable used to return value of
   5890          	communication routine*/
   5891          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5892              
   5893          	if (p_bma2x2 == BMA2x2_NULL) {
   5894          		/* Check the struct p_bma2x2 is empty */
   5895          		return E_BMA2x2_NULL_PTR;
   5896              } else {
   5897                  /* write tap shock value*/
   5898                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5899          			(p_bma2x2->dev_addr,
   5900                       BMA2x2_TAP_SHOCK_DURN_REG, &data_u8,
   5901                       BMA2x2_GEN_READ_WRITE_LENGTH);
   5902                  data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   5903                                                BMA2x2_TAP_SHOCK_DURN, tap_shock_u8);
   5904                  com_rslt += bma2x2_write_reg(
   5905                                               BMA2x2_TAP_SHOCK_DURN_REG, &data_u8,
   5906                                               BMA2x2_GEN_READ_WRITE_LENGTH);
   5907              }
   5908          	return com_rslt;
   5909          }
   5910          /*!
   5911          *	@brief This API is used to get
   5912          *	the tap quiet in the register 0x2A bit 7
   5913          *
   5914          *
   5915          *
   5916          *  @param  tap_quiet_u8 : The value of tap quiet
   5917          *    tap_quiet_u8    |    result
   5918          *  --------------------|----------------------
   5919          *     0x00             | TAP_QUIET_30_MS
   5920          *     0x01             | TAP_QUIET_20_MS
   5921          *
   5922          *	@return results of bus communication function
   5923          *	@retval 0 -> Success
   5924          *	@retval -1 -> Error
   5925          *
   5926          *
   5927          */
   5928          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_tap_quiet(u8 *tap_quiet_u8)
   5929          {
   5930          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5931              /*  Variable used to return value of
   5932          	communication routine*/
   5933          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5934              
   5935          	if (p_bma2x2 == BMA2x2_NULL) {
   5936          		/* Check the struct p_bma2x2 is empty */
   5937          		return E_BMA2x2_NULL_PTR;
   5938              } else {
   5939                  /* read the tap quiet value*/
   5940                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5941          			(p_bma2x2->dev_addr,
   5942                       BMA2x2_TAP_QUIET_DURN_REG, &data_u8,
   5943                       BMA2x2_GEN_READ_WRITE_LENGTH);
   5944                  *tap_quiet_u8 = BMA2x2_GET_BITSLICE
   5945          			(data_u8, BMA2x2_TAP_QUIET_DURN);
   5946              }
   5947          	return com_rslt;
   5948          }
   5949          /*!
   5950          *	@brief This API is used to set
   5951          *	the tap quiet in the register 0x2A bit 7
   5952          *
   5953          *
   5954          *
   5955          *  @param  tap_quiet_u8 : The value of tap quiet
   5956          *    tap_quiet_u8    |    result
   5957          *  --------------------|----------------------
   5958          *     0x00             | TAP_QUIET_30_MS
   5959          *     0x01             | TAP_QUIET_20_MS
   5960          *
   5961          *	@return results of bus communication function
   5962          *	@retval 0 -> Success
   5963          *	@retval -1 -> Error
   5964          *
   5965          *
   5966          */
   5967          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_tap_quiet(u8 tap_quiet_u8)
   5968          {
   5969          	u8 data_u8 = BMA2x2_INIT_VALUE;
   5970              /*  Variable used to return value of
   5971          	communication routine*/
   5972          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   5973              
   5974          	if (p_bma2x2 == BMA2x2_NULL) {
   5975          		/* Check the struct p_bma2x2 is empty */
   5976          		return E_BMA2x2_NULL_PTR;
   5977              } else {
   5978                  /* write the tap quiet value*/
   5979                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   5980          			(p_bma2x2->dev_addr,
   5981                       BMA2x2_TAP_QUIET_DURN_REG,
   5982                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5983                  data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   5984                                                BMA2x2_TAP_QUIET_DURN, tap_quiet_u8);
   5985                  com_rslt += bma2x2_write_reg(
   5986                                               BMA2x2_TAP_QUIET_DURN_REG,
   5987                                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   5988              }
   5989          	return com_rslt;
   5990          }
   5991          /*!
   5992          *	@brief This API is used to get
   5993          *	the tap threshold in the register 0x2B bit from 0 to 4
   5994          *
   5995          *
   5996          *
   5997          *  @param tap_thres_u8 : The value of tap threshold
   5998          *  @note Tap threshold of single and double tap corresponding
   5999          *     to accel range
   6000          *     range            |    Tap threshold
   6001          *  --------------------|----------------------
   6002          *     2g               | (tap_thres_u8 * 62.5)mg
   6003          *     4g               | (tap_thres_u8 * 125)mg
   6004          *     8g               | (tap_thres_u8 * 250)mg
   6005          *     16g              | (tap_thres_u8 * 500)mg
   6006          *
   6007          *
   6008          *	@return results of bus communication function
   6009          *	@retval 0 -> Success
   6010          *	@retval -1 -> Error
   6011          *
   6012          *
   6013          */
   6014          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_tap_thres(u8 *tap_thres_u8)
   6015          {
   6016          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6017          	/*  Variable used to return value of
   6018          	communication routine*/
   6019          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6020              
   6021          	if (p_bma2x2 == BMA2x2_NULL) {
   6022          		/* Check the struct p_bma2x2 is empty */
   6023          		return E_BMA2x2_NULL_PTR;
   6024              } else {
   6025                  /* read the tap threshold*/
   6026                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6027          			(p_bma2x2->dev_addr,
   6028                       BMA2x2_TAP_THRES_REG,
   6029                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6030                  *tap_thres_u8 = BMA2x2_GET_BITSLICE
   6031          			(data_u8, BMA2x2_TAP_THRES);
   6032              }
   6033          	return com_rslt;
   6034          }
   6035          /*!
   6036          *	@brief This API is used to set
   6037          *	the tap threshold in the register 0x2B bit from 0 to 4
   6038          *
   6039          *
   6040          *
   6041          *  @param tap_thres_u8 : The value of tap threshold
   6042          *	@note Tap threshold of single and double tap corresponding to accel range
   6043          *     range            |    Tap threshold
   6044          *  --------------------|----------------------
   6045          *     2g               | (tap_thres_u8 * 62.5)mg
   6046          *     4g               | (tap_thres_u8 * 125)mg
   6047          *     8g               | (tap_thres_u8 * 250)mg
   6048          *     16g              | (tap_thres_u8 * 500)mg
   6049          *
   6050          *
   6051          *	@return results of bus communication function
   6052          *	@retval 0 -> Success
   6053          *	@retval -1 -> Error
   6054          *
   6055          *
   6056          */
   6057          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_tap_thres(u8 tap_thres_u8)
   6058          {
   6059          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6060          	/*  Variable used to return value of
   6061          	communication routine*/
   6062          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6063              
   6064          	if (p_bma2x2 == BMA2x2_NULL) {
   6065          		/* Check the struct p_bma2x2 is empty */
   6066          		return E_BMA2x2_NULL_PTR;
   6067              } else {
   6068                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6069          			(p_bma2x2->dev_addr,
   6070                       BMA2x2_TAP_THRES_REG, &data_u8,
   6071                       BMA2x2_GEN_READ_WRITE_LENGTH);
   6072                  data_u8 = BMA2x2_SET_BITSLICE
   6073          			(data_u8, BMA2x2_TAP_THRES, tap_thres_u8);
   6074                  com_rslt += bma2x2_write_reg(
   6075                                               BMA2x2_TAP_THRES_REG, &data_u8,
   6076                                               BMA2x2_GEN_READ_WRITE_LENGTH);
   6077              }
   6078          	return com_rslt;
   6079          }
   6080          /*!
   6081          *	@brief This API is used to get
   6082          *	the tap sample in the register 0x2B bit 6 and 7
   6083          *
   6084          *
   6085          *
   6086          *  @param   *tap_sample_u8 : The value of tap sample
   6087          *     tap_sample_u8  |    result
   6088          *  --------------------|----------------------
   6089          *     0x00             | 2 samples
   6090          *     0x01             | 4 samples
   6091          *     0x02             | 8 samples
   6092          *     0x03             | 16 samples
   6093          *
   6094          *
   6095          *	@return results of bus communication function
   6096          *	@retval 0 -> Success
   6097          *	@retval -1 -> Error
   6098          *
   6099          *
   6100          */
   6101          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_tap_sample(u8 *tap_sample_u8)
   6102          {
   6103          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6104              /*  Variable used to return value of
   6105          	communication routine*/
   6106          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6107              
   6108          	if (p_bma2x2 == BMA2x2_NULL) {
   6109          		/* Check the struct p_bma2x2 is empty */
   6110          		return E_BMA2x2_NULL_PTR;
   6111              } else {
   6112                  /* read tap samples */
   6113                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6114          			(p_bma2x2->dev_addr,
   6115                       BMA2x2_TAP_SAMPLES_REG, &data_u8,
   6116                       BMA2x2_GEN_READ_WRITE_LENGTH);
   6117                  *tap_sample_u8 = BMA2x2_GET_BITSLICE
   6118          			(data_u8, BMA2x2_TAP_SAMPLES);
   6119              }
   6120          	return com_rslt;
   6121          }
   6122          /*!
   6123          *	@brief This API is used to set
   6124          *	the tap sample in the register 0x2B bit 6 and 7
   6125          *
   6126          *
   6127          *
   6128          *  @param   *tap_sample_u8 : The value of tap sample
   6129          *     tap_sample_u8  |    result
   6130          *  --------------------|----------------------
   6131          *     0x00             | 2 samples
   6132          *     0x01             | 4 samples
   6133          *     0x02             | 8 samples
   6134          *     0x03             | 16 samples
   6135          *
   6136          *
   6137          *	@return results of bus communication function
   6138          *	@retval 0 -> Success
   6139          *	@retval -1 -> Error
   6140          *
   6141          *
   6142          */
   6143          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_tap_sample(u8 tap_sample_u8)
   6144          {
   6145          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6146          	/*  Variable used to return value of
   6147          	communication routine*/
   6148          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6149              
   6150          	if (p_bma2x2 == BMA2x2_NULL) {
   6151          		/* Check the struct p_bma2x2 is empty */
   6152          		return E_BMA2x2_NULL_PTR;
   6153              } else {
   6154                  /* write tap samples */
   6155                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6156          			(p_bma2x2->dev_addr, BMA2x2_TAP_SAMPLES_REG,
   6157                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6158                  data_u8 = BMA2x2_SET_BITSLICE
   6159          			(data_u8, BMA2x2_TAP_SAMPLES, tap_sample_u8);
   6160                  com_rslt += bma2x2_write_reg(
   6161                                               BMA2x2_TAP_SAMPLES_REG, &data_u8,
   6162                                               BMA2x2_GEN_READ_WRITE_LENGTH);
   6163              }
   6164          	return com_rslt;
   6165          }
   6166          /*!
   6167          *	@brief This API is used to get
   6168          *	the orient mode in the register 0x2C bit 0 and 1
   6169          *
   6170          *
   6171          *
   6172          *  @param orient_mode_u8 : The value of orient mode
   6173          *     orient_mode_u8 |    result
   6174          *  --------------------|------------------
   6175          *     0x00             | symmetrical
   6176          *     0x01             | high asymmetrical
   6177          *     0x02             | low asymmetrical
   6178          *     0x03             | symmetrical
   6179          *
   6180          *
   6181          *
   6182          *	@return results of bus communication function
   6183          *	@retval 0 -> Success
   6184          *	@retval -1 -> Error
   6185          *
   6186          *
   6187          */
   6188          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_orient_mode(u8 *orient_mode_u8)
   6189          {
   6190          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6191          	/*  Variable used to return value of
   6192          	communication routine*/
   6193          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6194              
   6195          	if (p_bma2x2 == BMA2x2_NULL) {
   6196          		/* Check the struct p_bma2x2 is empty */
   6197          		return E_BMA2x2_NULL_PTR;
   6198              } else {
   6199                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   6200                                                            p_bma2x2->dev_addr,
   6201                                                            BMA2x2_ORIENT_MODE_REG, &data_u8,
   6202                                                            BMA2x2_GEN_READ_WRITE_LENGTH);
   6203                  *orient_mode_u8 = BMA2x2_GET_BITSLICE(
   6204                                                        data_u8, BMA2x2_ORIENT_MODE);
   6205              }
   6206          	return com_rslt;
   6207          }
   6208          /*!
   6209          *	@brief This API is used to set
   6210          *	the orient mode in the register 0x2C bit 0 and 1
   6211          *
   6212          *
   6213          *
   6214          *  @param orient_mode_u8 : The value of orient mode
   6215          *     orient_mode_u8 |    result
   6216          *  --------------------|------------------
   6217          *     0x00             | symmetrical
   6218          *     0x01             | high asymmetrical
   6219          *     0x02             | low asymmetrical
   6220          *     0x03             | symmetrical
   6221          *
   6222          *
   6223          *
   6224          *	@return results of bus communication function
   6225          *	@retval 0 -> Success
   6226          *	@retval -1 -> Error
   6227          *
   6228          *
   6229          */
   6230          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_orient_mode(u8 orient_mode_u8)
   6231          {
   6232          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6233          	/*  Variable used to return value of
   6234          	communication routine*/
   6235          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6236              
   6237          	if (p_bma2x2 == BMA2x2_NULL) {
   6238          		/* Check the struct p_bma2x2 is empty */
   6239          		return E_BMA2x2_NULL_PTR;
   6240              } else {
   6241                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6242          			(p_bma2x2->dev_addr,
   6243                       BMA2x2_ORIENT_MODE_REG, &data_u8,
   6244                       BMA2x2_GEN_READ_WRITE_LENGTH);
   6245                  data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   6246                                                BMA2x2_ORIENT_MODE, orient_mode_u8);
   6247                  com_rslt += bma2x2_write_reg(
   6248                                               BMA2x2_ORIENT_MODE_REG, &data_u8,
   6249                                               BMA2x2_GEN_READ_WRITE_LENGTH);
   6250              }
   6251          	return com_rslt;
   6252          }
   6253          /*!
   6254          *	@brief This API is used to get
   6255          *	the orient block in the register 0x2C bit 2 and 3
   6256          *
   6257          *
   6258          *
   6259          *	@param orient_block_u8 : The value of orient block
   6260          *     orient_mode_u8 |    result
   6261          *  --------------------|------------------
   6262          *     0x00             | no blocking
   6263          *     0x01             | theta blocking or
   6264          *                      | acceleration slope in any axis > 1.5g
   6265          *     0x02             | theta blocking or
   6266          *                      | acceleration slope in any axis > 0.2g
   6267          *                      | acceleration in any axis > 1.5g
   6268          *     0x03             | theta blocking or
   6269          *                      | acceleration slope in any axis > 0.4g
   6270          *                      | acceleration in any axis > 1.5g
   6271          *                      | value of orient is not stable for at lease 100ms
   6272          *
   6273          *
   6274          *	@return results of bus communication function
   6275          *	@retval 0 -> Success
   6276          *	@retval -1 -> Error
   6277          *
   6278          *
   6279          */
   6280          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_orient_block(
   6281                                                              u8 *orient_block_u8)
   6282          {
   6283          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6284              /*  Variable used to return value of
   6285          	communication routine*/
   6286          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6287              
   6288          	if (p_bma2x2 == BMA2x2_NULL) {
   6289          		/* Check the struct p_bma2x2 is empty */
   6290          		return E_BMA2x2_NULL_PTR;
   6291              } else {
   6292                  /* Read the orient block data */
   6293                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6294          			(p_bma2x2->dev_addr,
   6295                       BMA2x2_ORIENT_BLOCK_REG, &data_u8,
   6296                       BMA2x2_GEN_READ_WRITE_LENGTH);
   6297                  *orient_block_u8 = BMA2x2_GET_BITSLICE
   6298          			(data_u8, BMA2x2_ORIENT_BLOCK);
   6299              }
   6300          	return com_rslt;
   6301          }
   6302          /*!
   6303          *	@brief This API is used to set
   6304          *	the orient block in the register 0x2C bit 2 and 3
   6305          *
   6306          *
   6307          *
   6308          *	@param orient_block_u8 : The value of orient block
   6309          *     orient_mode_u8 |    result
   6310          *  --------------------|------------------
   6311          *     0x00             | no blocking
   6312          *     0x01             | theta blocking or
   6313          *                      | acceleration slope in any axis > 1.5g
   6314          *     0x02             | theta blocking or
   6315          *                      | acceleration slope in any axis > 0.2g
   6316          *                      | acceleration in any axis > 1.5g
   6317          *     0x03             | theta blocking or
   6318          *                      | acceleration slope in any axis > 0.4g
   6319          *                      | acceleration in any axis > 1.5g
   6320          *                      | value of orient is not stable for at lease 100ms
   6321          *
   6322          *
   6323          *	@return results of bus communication function
   6324          *	@retval 0 -> Success
   6325          *	@retval -1 -> Error
   6326          *
   6327          *
   6328          */
   6329          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_orient_block(u8 orient_block_u8)
   6330          {
   6331          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6332          	/*  Variable used to return value of
   6333          	communication routine*/
   6334          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6335              
   6336          	if (p_bma2x2 == BMA2x2_NULL) {
   6337          		/* Check the struct p_bma2x2 is empty */
   6338          		return E_BMA2x2_NULL_PTR;
   6339              } else {
   6340                  /* write the orient block data */
   6341                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6342          			(p_bma2x2->dev_addr,
   6343                       BMA2x2_ORIENT_BLOCK_REG, &data_u8,
   6344                       BMA2x2_GEN_READ_WRITE_LENGTH);
   6345                  data_u8 = BMA2x2_SET_BITSLICE
   6346          			(data_u8, BMA2x2_ORIENT_BLOCK, orient_block_u8);
   6347                  com_rslt += bma2x2_write_reg(
   6348                                               BMA2x2_ORIENT_BLOCK_REG, &data_u8,
   6349                                               BMA2x2_GEN_READ_WRITE_LENGTH);
   6350              }
   6351          	return com_rslt;
   6352          }
   6353          /*!
   6354          *	@brief This API is used to get
   6355          *	the orient hysteresis in the register 0x2C bit 4 to 6
   6356          *
   6357          *
   6358          *
   6359          *  @param orient_hyst_u8 : The value of orient hysteresis
   6360          *
   6361          *
   6362          *
   6363          *	@return results of bus communication function
   6364          *	@retval 0 -> Success
   6365          *	@retval -1 -> Error
   6366          *
   6367          *
   6368          */
   6369          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_orient_hyst(u8 *orient_hyst_u8)
   6370          {
   6371          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6372          	/*  Variable used to return value of
   6373          	communication routine*/
   6374          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6375              
   6376          	if (p_bma2x2 == BMA2x2_NULL) {
   6377          		/* Check the struct p_bma2x2 is empty */
   6378          		return E_BMA2x2_NULL_PTR;
   6379              } else {
   6380                  /* read the orient hysteresis data*/
   6381                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6382          			(p_bma2x2->dev_addr,
   6383                       BMA2x2_ORIENT_HYST_REG, &data_u8,
   6384                       BMA2x2_GEN_READ_WRITE_LENGTH);
   6385                  *orient_hyst_u8 = BMA2x2_GET_BITSLICE
   6386          			(data_u8, BMA2x2_ORIENT_HYST);
   6387              }
   6388          	return com_rslt;
   6389          }
   6390          /*!
   6391          *	@brief This API is used to set
   6392          *	the orient hysteresis in the register 0x2C bit 4 to 6
   6393          *
   6394          *
   6395          *
   6396          *  @param orient_hyst_u8 : The value of orient hysteresis
   6397          *
   6398          *
   6399          *
   6400          *	@return results of bus communication function
   6401          *	@retval 0 -> Success
   6402          *	@retval -1 -> Error
   6403          *
   6404          *
   6405          */
   6406          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_orient_hyst(u8 orient_hyst_u8)
   6407          {
   6408          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6409          	/*  Variable used to return value of
   6410          	communication routine*/
   6411          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6412              
   6413          	if (p_bma2x2 == BMA2x2_NULL) {
   6414          		/* Check the struct p_bma2x2 is empty */
   6415          		return E_BMA2x2_NULL_PTR;
   6416              } else {
   6417                  /* write the orient hysteresis data */
   6418                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6419          			(p_bma2x2->dev_addr,
   6420                       BMA2x2_ORIENT_HYST_REG, &data_u8,
   6421                       BMA2x2_GEN_READ_WRITE_LENGTH);
   6422                  data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   6423                                                BMA2x2_ORIENT_HYST, orient_hyst_u8);
   6424                  com_rslt += bma2x2_write_reg(
   6425                                               BMA2x2_ORIENT_HYST_REG,
   6426                                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6427              }
   6428          	return com_rslt;
   6429          }
   6430          /*!
   6431          *	@brief  This API is used to get
   6432          *	the theta value of orient and flat interrupts
   6433          *	@note ORIENT_THETA -> register 0x2D bit 0 to 5
   6434          *	@note FLAT_THETA   -> register 0x2E bit 0 to 5
   6435          *
   6436          *  @param channel_u8: The value of theta selection
   6437          *     channel_u8     |    result
   6438          *  --------------------|------------------
   6439          *     0x00             | BMA2x2_ACCEL_ORIENT_THETA
   6440          *     0x01             | BMA2x2_ACCEL_FLAT_THETA
   6441          * @note
   6442          * @note FLAT_THETA : Defines a blocking angle between 0 deg to 44.8 deg
   6443          * @note ORIENT_THETA : Defines threshold for detection of flat position
   6444          *                in range from 0 deg to 44.8 deg
   6445          *
   6446          *  @param theta_u8: The value of theta
   6447          *
   6448          *	@return results of bus communication function
   6449          *	@retval 0 -> Success
   6450          *	@retval -1 -> Error
   6451          *
   6452          *
   6453          */
   6454          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_theta(u8 channel_u8,
   6455                                                       u8 *theta_u8)
   6456          {
   6457          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6458          	/*  Variable used to return value of
   6459          	communication routine*/
   6460          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6461              
   6462          	if (p_bma2x2 == BMA2x2_NULL) {
   6463          		/* Check the struct p_bma2x2 is empty */
   6464          		return E_BMA2x2_NULL_PTR;
   6465              } else {
   6466          		switch (channel_u8) {
   6467                      /* write theta value*/
   6468                    case BMA2x2_ORIENT_THETA:
   6469          			/*ORIENT THETA*/
   6470          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6471                          (p_bma2x2->dev_addr,
   6472                           BMA2x2_THETA_BLOCK_REG, &data_u8,
   6473                           BMA2x2_GEN_READ_WRITE_LENGTH);
   6474          			*theta_u8 = BMA2x2_GET_BITSLICE
   6475                          (data_u8, BMA2x2_THETA_BLOCK);
   6476                      break;
   6477                    case BMA2x2_FLAT_THETA:
   6478          			/*FLAT THETA*/
   6479          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6480                          (p_bma2x2->dev_addr,
   6481                           BMA2x2_THETA_FLAT_REG,
   6482                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6483          			*theta_u8 = data_u8;
   6484                      break;
   6485                    default:
   6486          			com_rslt = E_OUT_OF_RANGE;
   6487                      break;
   6488          		}
   6489          	}
   6490          	return com_rslt;
   6491          }
   6492          /*!
   6493          *	@brief  This API is used to set
   6494          *	the theta value of orient and flat interrupts
   6495          *	@note ORIENT_THETA -> register 0x2D bit 0 to 5
   6496          *	@note FLAT_THETA   -> register 0x2E bit 0 to 5
   6497          *
   6498          *  @param channel_u8: The value of theta selection
   6499          *     channel_u8     |    result
   6500          *  --------------------|------------------
   6501          *     0x00             | BMA2x2_ACCEL_ORIENT_THETA
   6502          *     0x01             | BMA2x2_ACCEL_FLAT_THETA
   6503          * @note
   6504          * @note FLAT_THETA : Defines a blocking angle between 0 deg to 44.8 deg
   6505          * @note ORIENT_THETA : Defines threshold for detection of flat position
   6506          *                in range from 0 deg to 44.8 deg
   6507          *
   6508          *  @param theta_u8: The value of theta
   6509          *
   6510          *	@return results of bus communication function
   6511          *	@retval 0 -> Success
   6512          *	@retval -1 -> Error
   6513          *
   6514          *
   6515          */
   6516          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_theta(u8 channel_u8,
   6517                                                       u8 theta_u8)
   6518          {
   6519          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6520          	/*  Variable used to return value of
   6521          	communication routine*/
   6522          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6523              
   6524          	if (p_bma2x2 == BMA2x2_NULL) {
   6525          		/* Check the struct p_bma2x2 is empty */
   6526          		return E_BMA2x2_NULL_PTR;
   6527              } else {
   6528          		switch (channel_u8) {
   6529                      /* write flat value */
   6530                    case BMA2x2_ORIENT_THETA:
   6531          			/*ORIENT THETA*/
   6532          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6533                          (p_bma2x2->dev_addr,
   6534                           BMA2x2_THETA_BLOCK_REG, &data_u8,
   6535                           BMA2x2_GEN_READ_WRITE_LENGTH);
   6536          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   6537                                                    BMA2x2_THETA_BLOCK, theta_u8);
   6538          			com_rslt += bma2x2_write_reg(
   6539                                                   BMA2x2_THETA_BLOCK_REG,
   6540                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6541                      break;
   6542                    case BMA2x2_FLAT_THETA:
   6543          			/*FLAT THETA*/
   6544          			data_u8 = theta_u8;
   6545          			com_rslt = bma2x2_write_reg(
   6546                                                  BMA2x2_THETA_FLAT_REG,
   6547                                                  &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6548                      break;
   6549                    default:
   6550          			com_rslt = E_OUT_OF_RANGE;
   6551                      break;
   6552          		}
   6553          	}
   6554          	return com_rslt;
   6555          }
   6556          /*!
   6557          *	@brief This API is used to get
   6558          *  the interrupt enable of orient ud_enable in the register 0x2D bit 6
   6559          *
   6560          *
   6561          *  @param orient_enable_u8 : The value of orient ud_enable
   6562          *     orient_enable_u8     |    result
   6563          *  ------------------------- |------------------
   6564          *     0x00                   | Generates Interrupt
   6565          *     0x01                   | Do not generate interrupt
   6566          *
   6567          *
   6568          *
   6569          *	@return results of bus communication function
   6570          *	@retval 0 -> Success
   6571          *	@retval -1 -> Error
   6572          *
   6573          *
   6574          */
   6575          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_orient_enable(u8 *orient_enable_u8)
   6576          {
   6577          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6578          	/*  Variable used to return value of
   6579          	communication routine*/
   6580          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6581              
   6582          	if (p_bma2x2 == BMA2x2_NULL) {
   6583          		/* Check the struct p_bma2x2 is empty */
   6584          		return E_BMA2x2_NULL_PTR;
   6585              } else {
   6586                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6587          			(p_bma2x2->dev_addr,
   6588                       BMA2x2_ORIENT_UD_ENABLE_REG,
   6589                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6590                  *orient_enable_u8 = BMA2x2_GET_BITSLICE
   6591          			(data_u8, BMA2x2_ORIENT_UD_ENABLE);
   6592              }
   6593          	return com_rslt;
   6594          }
   6595          /*!
   6596          *	@brief This API is used to set
   6597          *  the interrupt enable of orient ud_enable in the register 0x2D bit 6
   6598          *
   6599          *
   6600          *  @param orient_enable_u8 : The value of orient ud_enable
   6601          *     orient_enable_u8     |    result
   6602          *  ------------------------- |------------------
   6603          *     0x00                   | Generates Interrupt
   6604          *     0x01                   | Do not generate interrupt
   6605          *
   6606          *
   6607          *
   6608          *	@return results of bus communication function
   6609          *	@retval 0 -> Success
   6610          *	@retval -1 -> Error
   6611          *
   6612          *
   6613          */
   6614          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_orient_enable(u8 orient_enable_u8)
   6615          {
   6616          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6617          	/*  Variable used to return value of
   6618          	communication routine*/
   6619          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6620              
   6621          	if (p_bma2x2 == BMA2x2_NULL) {
   6622          		/* Check the struct p_bma2x2 is empty */
   6623          		return E_BMA2x2_NULL_PTR;
   6624              } else {
   6625                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6626          			(p_bma2x2->dev_addr,
   6627                       BMA2x2_ORIENT_UD_ENABLE_REG,
   6628                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6629                  data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   6630                                                BMA2x2_ORIENT_UD_ENABLE, orient_enable_u8);
   6631                  com_rslt += bma2x2_write_reg(
   6632                                               BMA2x2_ORIENT_UD_ENABLE_REG,
   6633                                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6634              }
   6635          	return com_rslt;
   6636          }
   6637          /*!
   6638          *	@brief This API is used to get
   6639          *	the interrupt enable of flat hysteresis("flat_hy)
   6640          *	in the register 0x2F bit 0 to 2
   6641          *
   6642          *
   6643          *
   6644          *
   6645          *  @param flat_hyst_u8 : The value of flat hysteresis
   6646          *
   6647          *
   6648          *
   6649          *	@return results of bus communication function
   6650          *	@retval 0 -> Success
   6651          *	@retval -1 -> Error
   6652          *
   6653          *
   6654          */
   6655          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_flat_hyst(u8 *flat_hyst_u8)
   6656          {
   6657          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6658          	/*  Variable used to return value of
   6659          	communication routine*/
   6660          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6661              
   6662          	if (p_bma2x2 == BMA2x2_NULL) {
   6663          		/* Check the struct p_bma2x2 is empty */
   6664          		return E_BMA2x2_NULL_PTR;
   6665              } else {
   6666                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6667          			(p_bma2x2->dev_addr,
   6668                       BMA2x2_FLAT_HYST_REG, &data_u8,
   6669                       BMA2x2_GEN_READ_WRITE_LENGTH);
   6670                  *flat_hyst_u8 = BMA2x2_GET_BITSLICE
   6671          			(data_u8, BMA2x2_FLAT_HYST);
   6672              }
   6673          	return com_rslt;
   6674          }
   6675          /*!
   6676          *	@brief This API is used to set
   6677          *	the interrupt enable of flat hysteresis("flat_hy)
   6678          *	in the register 0x2F bit 0 to 2
   6679          *
   6680          *
   6681          *
   6682          *
   6683          *  @param flat_hyst_u8 : The value of flat hysteresis
   6684          *
   6685          *
   6686          *
   6687          *	@return results of bus communication function
   6688          *	@retval 0 -> Success
   6689          *	@retval -1 -> Error
   6690          *
   6691          *
   6692          */
   6693          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_flat_hyst(u8 flat_hyst_u8)
   6694          {
   6695          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6696          	/*  Variable used to return value of
   6697          	communication routine*/
   6698          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6699              
   6700          	if (p_bma2x2 == BMA2x2_NULL) {
   6701          		/* Check the struct p_bma2x2 is empty */
   6702          		return E_BMA2x2_NULL_PTR;
   6703              } else {
   6704                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   6705                                                            p_bma2x2->dev_addr,
   6706                                                            BMA2x2_FLAT_HYST_REG,
   6707                                                            &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6708                  data_u8 = BMA2x2_SET_BITSLICE
   6709          			(data_u8, BMA2x2_FLAT_HYST, flat_hyst_u8);
   6710                  com_rslt += bma2x2_write_reg(
   6711                                               BMA2x2_FLAT_HYST_REG, &data_u8,
   6712                                               BMA2x2_GEN_READ_WRITE_LENGTH);
   6713              }
   6714          	return com_rslt;
   6715          }
   6716          /*!
   6717          *	@brief This API is used to get
   6718          *  the interrupt enable of flat hold time(flat_hold_time)
   6719          *	in the register 0x2F bit 4 and 5
   6720          *
   6721          *
   6722          *  @param  flat_hold_time_u8 : The value of flat hold time
   6723          *     flat_hold_time_u8    |    result
   6724          *  ------------------------- |------------------
   6725          *     0x00                   | 0ms
   6726          *     0x01                   | 512ms
   6727          *     0x02                   | 1024ms
   6728          *     0x03                   | 2048ms
   6729          *
   6730          *
   6731          *
   6732          *	@return results of bus communication function
   6733          *	@retval 0 -> Success
   6734          *	@retval -1 -> Error
   6735          *
   6736          *
   6737          */
   6738          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_flat_hold_time(
   6739                                                                u8 *flat_hold_time_u8)
   6740          {
   6741          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6742          	/*  Variable used to return value of
   6743          	communication routine*/
   6744          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6745              
   6746          	if (p_bma2x2 == BMA2x2_NULL) {
   6747          		/* Check the struct p_bma2x2 is empty */
   6748          		return E_BMA2x2_NULL_PTR;
   6749              } else {
   6750                  /* read the flat hold time */
   6751                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6752          			(p_bma2x2->dev_addr,
   6753                       BMA2x2_FLAT_HOLD_TIME_REG,
   6754                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6755                  *flat_hold_time_u8 = BMA2x2_GET_BITSLICE
   6756          			(data_u8, BMA2x2_FLAT_HOLD_TIME);
   6757              }
   6758          	return com_rslt;
   6759          }
   6760          /*!
   6761          *	@brief This API is used to set
   6762          *  the interrupt enable of flat hold time(flat_hold_time)
   6763          *	in the register 0x2F bit 4 and 5
   6764          *
   6765          *
   6766          *  @param  flat_hold_time_u8 : The value of flat hold time
   6767          *     flat_hold_time_u8    |    result
   6768          *  ------------------------- |------------------
   6769          *     0x00                   | 0ms
   6770          *     0x01                   | 512ms
   6771          *     0x02                   | 1024ms
   6772          *     0x03                   | 2048ms
   6773          *
   6774          *
   6775          *
   6776          *	@return results of bus communication function
   6777          *	@retval 0 -> Success
   6778          *	@retval -1 -> Error
   6779          *
   6780          *
   6781          */
   6782          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_flat_hold_time(
   6783                                                                u8 flat_hold_time_u8)
   6784          {
   6785          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6786          	/*  Variable used to return value of
   6787          	communication routine*/
   6788          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6789              
   6790          	if (p_bma2x2 == BMA2x2_NULL) {
   6791          		/* Check the struct p_bma2x2 is empty */
   6792          		return E_BMA2x2_NULL_PTR;
   6793              } else {
   6794                  /* write the flat hold time */
   6795                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6796          			(p_bma2x2->dev_addr,
   6797                       BMA2x2_FLAT_HOLD_TIME_REG, &data_u8,
   6798                       BMA2x2_GEN_READ_WRITE_LENGTH);
   6799                  data_u8 = BMA2x2_SET_BITSLICE
   6800          			(data_u8, BMA2x2_FLAT_HOLD_TIME, flat_hold_time_u8);
   6801                  com_rslt += bma2x2_write_reg(
   6802                                               BMA2x2_FLAT_HOLD_TIME_REG, &data_u8,
   6803                                               BMA2x2_GEN_READ_WRITE_LENGTH);
   6804              }
   6805          	return com_rslt;
   6806          }
   6807          /*!
   6808          *	@brief This API is used to get
   6809          *	the fifo water mark level trigger in the register 0x30 bit from 0 to 5
   6810          *
   6811          *
   6812          *
   6813          *
   6814          *  @param fifo_wml_trig: The value of fifo watermark trigger level
   6815          *
   6816          *
   6817          *
   6818          *	@return results of bus communication function
   6819          *	@retval 0 -> Success
   6820          *	@retval -1 -> Error
   6821          *
   6822          *
   6823          */
   6824          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_fifo_wml_trig(
   6825                                                               u8 *fifo_wml_trig)
   6826          {
   6827          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6828          	/*  Variable used to return value of
   6829          	communication routine*/
   6830          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6831              
   6832          	if (p_bma2x2 == BMA2x2_NULL) {
   6833          		/* Check the struct p_bma2x2 is empty */
   6834          		return E_BMA2x2_NULL_PTR;
   6835              } else {
   6836                  /* read the fifo water mark trigger */
   6837                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6838          			(p_bma2x2->dev_addr,
   6839                       BMA2x2_FIFO_WML_TRIG_RETAIN_REG,
   6840                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6841                  *fifo_wml_trig = BMA2x2_GET_BITSLICE
   6842          			(data_u8, BMA2x2_FIFO_WML_TRIG_RETAIN);
   6843              }
   6844          	return com_rslt;
   6845          }
   6846          /*!
   6847          *	@brief This API is used to set
   6848          *	the fifo water mark level trigger in the register 0x30 bit from 0 to 5
   6849          *
   6850          *
   6851          *
   6852          *
   6853          *  @param fifo_wml_trig: The value of fifo watermark trigger level
   6854          *
   6855          *
   6856          *
   6857          *	@return results of bus communication function
   6858          *	@retval 0 -> Success
   6859          *	@retval -1 -> Error
   6860          *
   6861          *
   6862          */
   6863          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_fifo_wml_trig(
   6864                                                               u8 fifo_wml_trig)
   6865          {
   6866          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6867          	u8 power_mode = BMA2x2_INIT_VALUE;
   6868          	/*  Variable used to return value of
   6869          	communication routine*/
   6870          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6871              
   6872          	if (p_bma2x2 == BMA2x2_NULL) {
   6873          		/* Check the struct p_bma2x2 is empty */
   6874          		return E_BMA2x2_NULL_PTR;
   6875              } else {
   6876          		if (fifo_wml_trig < BMA2x2_FIFO_WML_RANGE) {
   6877          			/* write the fifo watermark trigger*/
   6878          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6879                          (p_bma2x2->dev_addr,
   6880                           BMA2x2_FIFO_WML_TRIG_RETAIN_REG,
   6881                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6882          			data_u8 = BMA2x2_SET_BITSLICE
   6883                          (data_u8, BMA2x2_FIFO_WML_TRIG_RETAIN,
   6884                           fifo_wml_trig);
   6885          			com_rslt += bma2x2_get_power_mode(&power_mode);
   6886          			com_rslt += bma2x2_set_power_mode(BMA2x2_MODE_STANDBY);
   6887          			com_rslt += bma2x2_write_reg(
   6888                                                   BMA2x2_FIFO_WML_TRIG_RETAIN_REG,
   6889                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6890          			com_rslt += bma2x2_set_power_mode(power_mode);
   6891          		} else {
   6892                      com_rslt = E_OUT_OF_RANGE;
   6893          		}
   6894          	}
   6895          	return com_rslt;
   6896          }
   6897          /*!
   6898          *	@brief This API is for to get
   6899          *	the self test axis(self_test_axis) in the register ox32 bit 0 to 2
   6900          *
   6901          *
   6902          *
   6903          *  @param selftest_axis_u8 : The value of selftest axis
   6904          *     selftest_axis_u8     |    result
   6905          *  ------------------------- |------------------
   6906          *     0x00                   | self test disable
   6907          *     0x01                   | x-axis
   6908          *     0x02                   | y-axis
   6909          *     0x03                   | z-axis
   6910          *
   6911          *
   6912          *	@return results of bus communication function
   6913          *	@retval 0 -> Success
   6914          *	@retval -1 -> Error
   6915          *
   6916          *
   6917          */
   6918          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_selftest_axis(
   6919                                                               u8 *selftest_axis_u8)
   6920          {
   6921          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6922          	/*  Variable used to return value of
   6923          	communication routine*/
   6924          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6925              
   6926          	if (p_bma2x2 == BMA2x2_NULL) {
   6927          		/* Check the struct p_bma2x2 is empty */
   6928          		return E_BMA2x2_NULL_PTR;
   6929              } else {
   6930                  /* read the self test axis*/
   6931                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6932          			(p_bma2x2->dev_addr,
   6933                       BMA2x2_ENABLE_SELFTEST_REG,
   6934                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6935                  *selftest_axis_u8 = BMA2x2_GET_BITSLICE
   6936          			(data_u8, BMA2x2_ENABLE_SELFTEST);
   6937              }
   6938          	return com_rslt;
   6939          }
   6940          /*!
   6941          *	@brief This API is for to set
   6942          *	the self test axis(self_test_axis) in the register ox32 bit 0 to 2
   6943          *
   6944          *
   6945          *
   6946          *  @param selftest_axis_u8 : The value of selftest axis
   6947          *     selftest_axis_u8     |    result
   6948          *  ------------------------- |------------------
   6949          *     0x00                   | self test disable
   6950          *     0x01                   | x-axis
   6951          *     0x02                   | y-axis
   6952          *     0x03                   | z-axis
   6953          *
   6954          *
   6955          *	@return results of bus communication function
   6956          *	@retval 0 -> Success
   6957          *	@retval -1 -> Error
   6958          *
   6959          *
   6960          */
   6961          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_selftest_axis(
   6962                                                               u8 selftest_axis_u8)
   6963          {
   6964          	u8 data_u8 = BMA2x2_INIT_VALUE;
   6965          	/*  Variable used to return value of
   6966          	communication routine*/
   6967          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   6968              
   6969          	if (p_bma2x2 == BMA2x2_NULL) {
   6970          		/* Check the struct p_bma2x2 is empty */
   6971          		return E_BMA2x2_NULL_PTR;
   6972              } else {
   6973          		if (selftest_axis_u8 < BMA2x2_SELF_TEST_AXIS_RANGE) {
   6974          			/* write the self test axis*/
   6975          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   6976                          (p_bma2x2->dev_addr,
   6977                           BMA2x2_ENABLE_SELFTEST_REG,
   6978                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6979          			data_u8 = BMA2x2_SET_BITSLICE
   6980                          (data_u8, BMA2x2_ENABLE_SELFTEST, selftest_axis_u8);
   6981          			com_rslt += bma2x2_write_reg(
   6982                                                   BMA2x2_ENABLE_SELFTEST_REG,
   6983                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   6984                  } else {
   6985                      com_rslt = E_OUT_OF_RANGE;
   6986          		}
   6987          	}
   6988          	return com_rslt;
   6989          }
   6990          /*!
   6991          *	@brief This API is for to get
   6992          *	the Self Test sign(selftest_sign) in the register 0x32 bit 2
   6993          *
   6994          *
   6995          *
   6996          *  @param selftest_sign_u8 : The value of self test sign
   6997          *     selftest_sign_u8     |    result
   6998          *  ------------------------- |------------------
   6999          *     0x00                   | negative sign
   7000          *     0x01                   | positive sign
   7001          *
   7002          *
   7003          *	@return results of bus communication function
   7004          *	@retval 0 -> Success
   7005          *	@retval -1 -> Error
   7006          *
   7007          *
   7008          */
   7009          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_selftest_sign(
   7010                                                               u8 *selftest_sign_u8)
   7011          {
   7012          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7013          	/*  Variable used to return value of
   7014          	communication routine*/
   7015          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7016              
   7017          	if (p_bma2x2 == BMA2x2_NULL) {
   7018          		/* Check the struct p_bma2x2 is empty */
   7019          		return E_BMA2x2_NULL_PTR;
   7020              } else {
   7021                  /* read self test sign */
   7022                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7023          			(p_bma2x2->dev_addr,
   7024                       BMA2x2_NEG_SELFTEST_REG,
   7025                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7026                  *selftest_sign_u8 = BMA2x2_GET_BITSLICE
   7027          			(data_u8, BMA2x2_NEG_SELFTEST);
   7028              }
   7029          	return com_rslt;
   7030          }
   7031          /*!
   7032          *	@brief This API is for to set
   7033          *	the Self Test sign(selftest_sign) in the register 0x32 bit 2
   7034          *
   7035          *
   7036          *
   7037          *  @param selftest_sign_u8 : The value of self test sign
   7038          *     selftest_sign_u8     |    result
   7039          *  ------------------------- |------------------
   7040          *     0x00                   | negative sign
   7041          *     0x01                   | positive sign
   7042          *
   7043          *
   7044          *	@return results of bus communication function
   7045          *	@retval 0 -> Success
   7046          *	@retval -1 -> Error
   7047          *
   7048          *
   7049          */
   7050          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_selftest_sign(
   7051                                                               u8 selftest_sign_u8)
   7052          {
   7053          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7054          	/*  Variable used to return value of
   7055          	communication routine*/
   7056          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7057              
   7058          	if (p_bma2x2 == BMA2x2_NULL) {
   7059          		/* Check the struct p_bma2x2 is empty */
   7060          		return E_BMA2x2_NULL_PTR;
   7061              } else {
   7062          		if (selftest_sign_u8 <
   7063                      BMA2x2_SELF_TEST_SIGN_RANGE) {
   7064                          /* write self test sign */
   7065                          com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7066                              (p_bma2x2->dev_addr,
   7067                               BMA2x2_NEG_SELFTEST_REG,
   7068                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7069                          data_u8 = BMA2x2_SET_BITSLICE
   7070                              (data_u8, BMA2x2_NEG_SELFTEST, selftest_sign_u8);
   7071                          com_rslt += bma2x2_write_reg(
   7072                                                       BMA2x2_NEG_SELFTEST_REG,
   7073                                                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7074                      } else {
   7075                          com_rslt = E_OUT_OF_RANGE;
   7076                      }
   7077          	}
   7078          	return com_rslt;
   7079          }
   7080          /*!
   7081          * @brief This API is used to get
   7082          * the nvm program mode(nvm_prog_mode)in the register 0x33 bit 0
   7083          *
   7084          *
   7085          *  @param  nvmprog_mode_u8 : The value of nvm program mode
   7086          *     nvmprog_mode_u8      |    result
   7087          *  ------------------------- |------------------
   7088          *     0x00                   | Disable program mode
   7089          *     0x01                   | Enable program mode
   7090          *
   7091          *	@return results of bus communication function
   7092          *	@retval 0 -> Success
   7093          *	@retval -1 -> Error
   7094          *
   7095          *
   7096          */
   7097          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_nvmprog_mode(
   7098                                                              u8 *nvmprog_mode_u8)
   7099          {
   7100          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7101          	/*  Variable used to return value of
   7102          	communication routine*/
   7103          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7104              
   7105          	if (p_bma2x2 == BMA2x2_NULL) {
   7106          		com_rslt = E_BMA2x2_NULL_PTR;
   7107          	} else {
   7108          		/* read the nvm program mode*/
   7109          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7110                      (p_bma2x2->dev_addr,
   7111                       BMA2x2_UNLOCK_EE_PROG_MODE_REG,
   7112                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7113          		*nvmprog_mode_u8 = BMA2x2_GET_BITSLICE
   7114                      (data_u8, BMA2x2_UNLOCK_EE_PROG_MODE);
   7115          	}
   7116          	return com_rslt;
   7117          }
   7118          /*!
   7119          * @brief This API is used to set
   7120          * the nvm program mode(nvm_prog_mode)in the register 0x33 bit 0
   7121          *
   7122          *
   7123          *  @param  nvmprog_mode_u8 : The value of nvm program mode
   7124          *     nvmprog_mode_u8      |    result
   7125          *  ------------------------- |------------------
   7126          *     0x00                   | Disable program mode
   7127          *     0x01                   | Enable program mode
   7128          *
   7129          *	@return results of bus communication function
   7130          *	@retval 0 -> Success
   7131          *	@retval -1 -> Error
   7132          *
   7133          *
   7134          */
   7135          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_nvmprog_mode(u8 nvmprog_mode_u8)
   7136          {
   7137          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7138          	/*  Variable used to return value of
   7139          	communication routine*/
   7140          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7141              
   7142          	if (p_bma2x2 == BMA2x2_NULL) {
   7143          		/* Check the struct p_bma2x2 is empty */
   7144          		com_rslt = E_BMA2x2_NULL_PTR;
   7145          	} else {
   7146          		/* write the nvm program mode*/
   7147          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7148                      (p_bma2x2->dev_addr,
   7149                       BMA2x2_UNLOCK_EE_PROG_MODE_REG,
   7150                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7151          		data_u8 = BMA2x2_SET_BITSLICE
   7152                      (data_u8, BMA2x2_UNLOCK_EE_PROG_MODE, nvmprog_mode_u8);
   7153          		com_rslt += bma2x2_write_reg
   7154                      (BMA2x2_UNLOCK_EE_PROG_MODE_REG,
   7155                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7156          	}
   7157          	return com_rslt;
   7158          }
   7159          /*!
   7160          *	@brief This API is used to set
   7161          *	the value of nvm program trig in the register 0x33 bit 1
   7162          *
   7163          *
   7164          *
   7165          *
   7166          *  @param nvprog_trig_u8: The value of nvm program trig
   7167          *     nvprog_trig_u8       |    result
   7168          *  ------------------------- |------------------
   7169          *     0x00                   | Do not trigger nvm program
   7170          *     0x01                   | Trigger nvm program
   7171          *
   7172          *
   7173          *	@return results of bus communication function
   7174          *	@retval 0 -> Success
   7175          *	@retval -1 -> Error
   7176          *
   7177          *
   7178          */
   7179          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_nvprog_trig(u8 nvprog_trig_u8)
   7180          {
   7181          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7182          	/*  Variable used to return value of
   7183          	communication routine*/
   7184          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7185              
   7186          	if (p_bma2x2 == BMA2x2_NULL) {
   7187          		/* Check the struct p_bma2x2 is empty */
   7188          		com_rslt = E_BMA2x2_NULL_PTR;
   7189          	} else {
   7190          		/* set the nvm program trigger */
   7191          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7192                      (p_bma2x2->dev_addr,
   7193                       BMA2x2_START_EE_PROG_TRIG_REG,
   7194                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7195          		data_u8 = BMA2x2_SET_BITSLICE
   7196                      (data_u8, BMA2x2_START_EE_PROG_TRIG, nvprog_trig_u8);
   7197          		com_rslt += bma2x2_write_reg
   7198                      (BMA2x2_START_EE_PROG_TRIG_REG,
   7199                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7200          	}
   7201          	return com_rslt;
   7202          }
   7203          /*!
   7204          * @brief This API is used to get
   7205          * the nvm program ready in the register bit 2
   7206          *
   7207          *
   7208          *  @param nvprog_ready_u8: The value of nvm program ready
   7209          *     nvprog_ready_u8      |    result
   7210          *  ------------------------- |------------------
   7211          *     0x00                   | nvm write/update operation is in progress
   7212          *     0x01                   | nvm is ready to accept a new write
   7213          *
   7214          *
   7215          *
   7216          *	@return results of bus communication function
   7217          *	@retval 0 -> Success
   7218          *	@retval -1 -> Error
   7219          *
   7220          *
   7221          */
   7222          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_nvmprog_ready(u8 *nvprog_ready_u8)
   7223          {
   7224          	/*  Variable used to return value of
   7225          	communication routine*/
   7226          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7227          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7228              
   7229          	if (p_bma2x2 == BMA2x2_NULL) {
   7230          		/* Check the struct p_bma2x2 is empty */
   7231          		com_rslt = E_BMA2x2_NULL_PTR;
   7232          	} else {
   7233          		/* read the nvm program ready*/
   7234          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7235                      (p_bma2x2->dev_addr,
   7236                       BMA2x2_EE_PROG_READY_REG,
   7237                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7238          		*nvprog_ready_u8 = BMA2x2_GET_BITSLICE
   7239                      (data_u8, BMA2x2_EE_PROG_READY);
   7240          	}
   7241          	return com_rslt;
   7242          }
   7243          /*!
   7244          * @brief This API is used to set
   7245          * the nvm program ready in the register bit 2
   7246          *
   7247          *
   7248          *  @param nvprog_remain_u8: The value of nvm program ready
   7249          *     nvprog_remain_u8     |    result
   7250          *  ------------------------- |------------------
   7251          *     0x00                   | nvm write/update operation is in progress
   7252          *     0x01                   | nvm is ready to accept a new write
   7253          *
   7254          *
   7255          *
   7256          *	@return results of bus communication function
   7257          *	@retval 0 -> Success
   7258          *	@retval -1 -> Error
   7259          *
   7260          *
   7261          */
   7262          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_nvmprog_remain(u8 *nvprog_remain_u8)
   7263          {
   7264          	/*  Variable used to return value of
   7265          	communication routine*/
   7266          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7267          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7268          	/* Check the struct p_bma2x2 is empty */
   7269          	if (BMA2x2_NULL == p_bma2x2) {
   7270          		com_rslt = E_BMA2x2_NULL_PTR;
   7271          	} else {
   7272          		/* write the nvm program ready*/
   7273          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7274                      (p_bma2x2->dev_addr,
   7275                       BMA2x2_EE_REMAIN_REG, &data_u8,
   7276                       BMA2x2_GEN_READ_WRITE_LENGTH);
   7277          		*nvprog_remain_u8 = BMA2x2_GET_BITSLICE
   7278                      (data_u8, BMA2x2_EE_REMAIN);
   7279          	}
   7280          	return com_rslt;
   7281          }
   7282          /*!
   7283          *	@brief This API is used to get the enable status of spi3
   7284          *	in the register 0x34 bit 0
   7285          *
   7286          *
   7287          *
   7288          *  @param  spi3_u8 : The value of SPI 3 or 4 wire enable
   7289          *     spi3_u8              |    result
   7290          *  ------------------------- |------------------
   7291          *     0x00                   |     spi4
   7292          *     0x01                   |     spi3
   7293          *
   7294          *
   7295          *
   7296          *	@return results of bus communication function
   7297          *	@retval 0 -> Success
   7298          *	@retval -1 -> Error
   7299          *
   7300          *
   7301          */
   7302          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_spi3(u8 *spi3_u8)
   7303          {
   7304          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7305          	/*  Variable used to return value of
   7306          	communication routine*/
   7307          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7308              
   7309          	if (p_bma2x2 == BMA2x2_NULL) {
   7310          		/* Check the struct p_bma2x2 is empty */
   7311          		return E_BMA2x2_NULL_PTR;
   7312              } else {
   7313                  /* read the spi status*/
   7314                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7315          			(p_bma2x2->dev_addr,
   7316                       BMA2x2_ENABLE_SPI_MODE_3_REG,
   7317                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7318                  *spi3_u8 = BMA2x2_GET_BITSLICE
   7319          			(data_u8, BMA2x2_ENABLE_SPI_MODE_3);
   7320              }
   7321          	return com_rslt;
   7322          }
   7323          /*!
   7324          *	@brief This API is used to set the enable status of spi3
   7325          *	in the register 0x34 bit 0
   7326          *
   7327          *
   7328          *
   7329          *  @param  spi3_u8 : The value of SPI 3 or 4 wire enable
   7330          *     spi3_u8              |    result
   7331          *  ------------------------- |------------------
   7332          *     0x00                   |     spi4
   7333          *     0x01                   |     spi3
   7334          *
   7335          *
   7336          *
   7337          *	@return results of bus communication function
   7338          *	@retval 0 -> Success
   7339          *	@retval -1 -> Error
   7340          *
   7341          *
   7342          */
   7343          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_spi3(u8 spi3_u8)
   7344          {
   7345          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7346          	/*  Variable used to return value of
   7347          	communication routine*/
   7348          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7349              
   7350          	if (p_bma2x2 == BMA2x2_NULL) {
   7351          		/* Check the struct p_bma2x2 is empty */
   7352          		return E_BMA2x2_NULL_PTR;
   7353              } else {
   7354                  /* write the spi status*/
   7355                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7356          			(p_bma2x2->dev_addr,
   7357                       BMA2x2_ENABLE_SPI_MODE_3_REG,
   7358                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7359                  data_u8 = BMA2x2_SET_BITSLICE
   7360          			(data_u8, BMA2x2_ENABLE_SPI_MODE_3, spi3_u8);
   7361                  com_rslt += bma2x2_write_reg(
   7362                                               BMA2x2_ENABLE_SPI_MODE_3_REG,
   7363                                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7364              }
   7365          	return com_rslt;
   7366          }
   7367          /*!
   7368          *	@brief This API is used to get the i2c
   7369          *	watch dog timer period and I2C interface mode is selected
   7370          *	in the register 0x34 bit 1 and 2
   7371          *
   7372          *
   7373          *  @param channel_u8: The i2c option selection
   7374          *     channel_u8           |    result
   7375          *  ------------------------- |------------------
   7376          *        0                   |   BMA2x2_ACCEL_I2C_SELECT
   7377          *        1                   |   BMA2x2_ACCEL_I2C_ENABLE
   7378          *
   7379          *  @param i2c_wdt_u8: watch dog timer period
   7380          *	and I2C interface mode is selected
   7381          *     BMA2x2_ACCEL_I2C_SELECT|    result
   7382          *  ------------------------- |------------------
   7383          *     0x00                   | Disable the watchdog at SDI pin
   7384          *     0x01                   | Enable watchdog
   7385          *
   7386          *     BMA2x2_I2C_ENABLE      |    result
   7387          *  ------------------------- |------------------
   7388          *     0x00                   | 1ms
   7389          *     0x01                   | 50ms
   7390          *
   7391          *
   7392          *	@return results of bus communication function
   7393          *	@retval 0 -> Success
   7394          *	@retval -1 -> Error
   7395          *
   7396          *
   7397          */
   7398          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_i2c_wdt(u8 channel_u8,
   7399                                                         u8 *i2c_wdt_u8)
   7400          {
   7401          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7402              /*  Variable used to return value of
   7403          	communication routine*/
   7404          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7405              
   7406          	if (p_bma2x2 == BMA2x2_NULL) {
   7407          		/* Check the struct p_bma2x2 is empty */
   7408          		return E_BMA2x2_NULL_PTR;
   7409              } else {
   7410          		switch (channel_u8) {
   7411                    case BMA2x2_I2C_SELECT:
   7412          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7413                          (p_bma2x2->dev_addr,
   7414                           BMA2x2_I2C_WDT_PERIOD_REG,
   7415                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7416          			*i2c_wdt_u8 = BMA2x2_GET_BITSLICE(data_u8,
   7417                                                        BMA2x2_I2C_WDT_PERIOD);
   7418                      break;
   7419                    case BMA2x2_I2C_ENABLE:
   7420          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7421                          (p_bma2x2->dev_addr,
   7422                           BMA2x2_ENABLE_I2C_WDT_REG,
   7423                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7424          			*i2c_wdt_u8 = BMA2x2_GET_BITSLICE
   7425                          (data_u8, BMA2x2_ENABLE_I2C_WDT);
   7426                      break;
   7427                    default:
   7428                      com_rslt = E_OUT_OF_RANGE;
   7429                      break;
   7430          		}
   7431          	}
   7432          	return com_rslt;
   7433          }
   7434          /*!
   7435          *	@brief This API is used to set the i2c
   7436          *	watch dog timer period and I2C interface mode is selected
   7437          *	in the register 0x34 bit 1 and 2
   7438          *
   7439          *
   7440          *  @param channel_u8: The i2c option selection
   7441          *     channel_u8           |    result
   7442          *  ------------------------- |------------------
   7443          *        0                   |   BMA2x2_ACCEL_I2C_SELECT
   7444          *        1                   |   BMA2x2_ACCEL_I2C_ENABLE
   7445          *
   7446          *  @param i2c_wdt_u8: watch dog timer period
   7447          *	and I2C interface mode is selected
   7448          *     BMA2x2_ACCEL_I2C_SELECT|    result
   7449          *  ------------------------- |------------------
   7450          *     0x00                   | Disable the watchdog at SDI pin
   7451          *     0x01                   | Enable watchdog
   7452          *
   7453          *     BMA2x2_I2C_ENABLE      |    result
   7454          *  ------------------------- |------------------
   7455          *     0x00                   | 1ms
   7456          *     0x01                   | 50ms
   7457          *
   7458          *
   7459          *	@return results of bus communication function
   7460          *	@retval 0 -> Success
   7461          *	@retval -1 -> Error
   7462          *
   7463          *
   7464          */
   7465          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_i2c_wdt(u8 channel_u8,
   7466                                                         u8 i2c_wdt_u8)
   7467          {
   7468          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7469          	/*  Variable used to return value of
   7470          	communication routine*/
   7471          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7472              
   7473          	if (p_bma2x2 == BMA2x2_NULL) {
   7474          		/* Check the struct p_bma2x2 is empty */
   7475          		return E_BMA2x2_NULL_PTR;
   7476              } else {
   7477          		switch (channel_u8) {
   7478                    case BMA2x2_I2C_SELECT:
   7479          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7480                          (p_bma2x2->dev_addr,
   7481                           BMA2x2_I2C_WDT_PERIOD_REG,
   7482                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7483          			data_u8 = BMA2x2_SET_BITSLICE
   7484                          (data_u8,
   7485                           BMA2x2_I2C_WDT_PERIOD, i2c_wdt_u8);
   7486          			com_rslt += bma2x2_write_reg(
   7487                                                   BMA2x2_I2C_WDT_PERIOD_REG,
   7488                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7489                      break;
   7490                    case BMA2x2_I2C_ENABLE:
   7491          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7492                          (p_bma2x2->dev_addr,
   7493                           BMA2x2_ENABLE_I2C_WDT_REG,
   7494                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7495          			data_u8 = BMA2x2_SET_BITSLICE
   7496                          (data_u8,
   7497                           BMA2x2_ENABLE_I2C_WDT, i2c_wdt_u8);
   7498          			com_rslt += bma2x2_write_reg(
   7499                                                   BMA2x2_ENABLE_I2C_WDT_REG,
   7500                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7501                      break;
   7502                    default:
   7503          			com_rslt = E_OUT_OF_RANGE;
   7504                      break;
   7505          		}
   7506          	}
   7507          	return com_rslt;
   7508          }
   7509          /*!
   7510          *	@brief This API is used to get
   7511          *	slow compensation(hp_x_enable, hp_y_enable and hp_z_enable) enable
   7512          *	in the register 0x36 bit 0 to 2
   7513          *	@note SLOW_COMP_X -> bit 0
   7514          *	@note SLOW_COMP_Y -> bit 1
   7515          *	@note SLOW_COMP_Z -> bit 2
   7516          *
   7517          *
   7518          *	@param channel_u8: The value of slow compensation selection
   7519          *     channel_u8           |    result
   7520          *  ------------------------- |------------------
   7521          *        0                   |   BMA2x2_ACCEL_SLOW_COMP_X
   7522          *        1                   |   BMA2x2_ACCEL_SLOW_COMP_Y
   7523          *        2                   |   BMA2x2_ACCEL_SLOW_COMP_Z
   7524          *
   7525          *  @param slow_comp_u8: The value of slow compensation enable
   7526          *     slow_comp_u8         |    result
   7527          *  ------------------------- |------------------
   7528          *         0x00               |    Disable
   7529          *        0x01                |    Enable
   7530          *
   7531          *
   7532          *	@return results of bus communication function
   7533          *	@retval 0 -> Success
   7534          *	@retval -1 -> Error
   7535          *
   7536          *
   7537          */
   7538          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_slow_comp(u8 channel_u8,
   7539                                                           u8 *slow_comp_u8)
   7540          {
   7541          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7542          	/*  Variable used to return value of
   7543          	communication routine*/
   7544          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7545              
   7546          	if (p_bma2x2 == BMA2x2_NULL) {
   7547          		/* Check the struct p_bma2x2 is empty */
   7548          		return E_BMA2x2_NULL_PTR;
   7549              } else {
   7550          		switch (channel_u8) {
   7551                    case BMA2x2_SLOW_COMP_X:
   7552          			/*SLOW COMP X*/
   7553          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7554                          (p_bma2x2->dev_addr,
   7555                           BMA2x2_ENABLE_SLOW_COMP_X_REG,
   7556                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7557          			*slow_comp_u8 = BMA2x2_GET_BITSLICE
   7558                          (data_u8, BMA2x2_ENABLE_SLOW_COMP_X);
   7559                      break;
   7560                    case BMA2x2_SLOW_COMP_Y:
   7561          			/*SLOW COMP Y*/
   7562          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7563                          (p_bma2x2->dev_addr,
   7564                           BMA2x2_ENABLE_SLOW_COMP_Y_REG,
   7565                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7566          			*slow_comp_u8 = BMA2x2_GET_BITSLICE
   7567                          (data_u8, BMA2x2_ENABLE_SLOW_COMP_Y);
   7568                      break;
   7569                    case BMA2x2_SLOW_COMP_Z:
   7570          			/*SLOW COMP Z*/
   7571          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7572                          (p_bma2x2->dev_addr,
   7573                           BMA2x2_ENABLE_SLOW_COMP_Z_REG,
   7574                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7575          			*slow_comp_u8 = BMA2x2_GET_BITSLICE
   7576                          (data_u8, BMA2x2_ENABLE_SLOW_COMP_Z);
   7577                      break;
   7578                    default:
   7579          			com_rslt = E_OUT_OF_RANGE;
   7580                      break;
   7581          		}
   7582          	}
   7583          	return com_rslt;
   7584          }
   7585          /*!
   7586          *	@brief This API is used to set
   7587          *	slow compensation(hp_x_enable, hp_y_enable and hp_z_enable) enable
   7588          *	in the register 0x36 bit 0 to 2
   7589          *	@note SLOW_COMP_X -> bit 0
   7590          *	@note SLOW_COMP_Y -> bit 1
   7591          *	@note SLOW_COMP_Z -> bit 2
   7592          *
   7593          *
   7594          *	@param channel_u8: The value of slow compensation selection
   7595          *     channel_u8           |    result
   7596          *  ------------------------- |------------------
   7597          *        0                   |   BMA2x2_ACCEL_SLOW_COMP_X
   7598          *        1                   |   BMA2x2_ACCEL_SLOW_COMP_Y
   7599          *        2                   |   BMA2x2_ACCEL_SLOW_COMP_Z
   7600          *
   7601          *  @param slow_comp_u8: The value of slow compensation enable
   7602          *     slow_comp_u8         |    result
   7603          *  ------------------------- |------------------
   7604          *         0x00               |    Disable
   7605          *        0x01                |    Enable
   7606          *
   7607          *
   7608          *	@return results of bus communication function
   7609          *	@retval 0 -> Success
   7610          *	@retval -1 -> Error
   7611          *
   7612          *
   7613          */
   7614          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_slow_comp(u8 channel_u8,
   7615                                                           u8 slow_comp_u8)
   7616          {
   7617          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7618              /*  Variable used to return value of
   7619          	communication routine*/
   7620          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7621              
   7622          	if (p_bma2x2 == BMA2x2_NULL) {
   7623          		/* Check the struct p_bma2x2 is empty */
   7624          		return E_BMA2x2_NULL_PTR;
   7625              } else {
   7626          		switch (channel_u8) {
   7627                    case BMA2x2_SLOW_COMP_X:
   7628          			/*SLOW COMP X*/
   7629          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7630                          (p_bma2x2->dev_addr,
   7631                           BMA2x2_ENABLE_SLOW_COMP_X_REG,
   7632                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7633          			data_u8 = BMA2x2_SET_BITSLICE
   7634                          (data_u8,
   7635                           BMA2x2_ENABLE_SLOW_COMP_X, slow_comp_u8);
   7636          			com_rslt += bma2x2_write_reg(
   7637                                                   BMA2x2_ENABLE_SLOW_COMP_X_REG,
   7638                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7639                      break;
   7640                    case BMA2x2_SLOW_COMP_Y:
   7641          			/*SLOW COMP Y*/
   7642          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7643                          (p_bma2x2->dev_addr,
   7644                           BMA2x2_ENABLE_SLOW_COMP_Y_REG,
   7645                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7646          			data_u8 = BMA2x2_SET_BITSLICE
   7647                          (data_u8,
   7648                           BMA2x2_ENABLE_SLOW_COMP_Y, slow_comp_u8);
   7649          			com_rslt += bma2x2_write_reg(
   7650                                                   BMA2x2_ENABLE_SLOW_COMP_Y_REG,
   7651                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7652                      break;
   7653                    case BMA2x2_SLOW_COMP_Z:
   7654          			/*SLOW COMP Z*/
   7655          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7656                          (p_bma2x2->dev_addr,
   7657                           BMA2x2_ENABLE_SLOW_COMP_Z_REG,
   7658                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7659          			data_u8 = BMA2x2_SET_BITSLICE
   7660                          (data_u8,
   7661                           BMA2x2_ENABLE_SLOW_COMP_Z, slow_comp_u8);
   7662          			com_rslt += bma2x2_write_reg(
   7663                                                   BMA2x2_ENABLE_SLOW_COMP_Z_REG,
   7664                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7665                      break;
   7666                    default:
   7667          			com_rslt = E_OUT_OF_RANGE;
   7668                      break;
   7669          		}
   7670          	}
   7671          	return com_rslt;
   7672          }
   7673          /*!
   7674          *	@brief This API is used to get
   7675          *	the status of fast offset compensation(cal_rdy) in the register 0x36
   7676          *	bit 4(Read Only Possible)
   7677          *
   7678          *
   7679          *
   7680          *  @param  cal_rdy_u8: The value of cal_ready
   7681          *
   7682          *
   7683          *
   7684          *
   7685          *	@return results of bus communication function
   7686          *	@retval 0 -> Success
   7687          *	@retval -1 -> Error
   7688          *
   7689          *
   7690          */
   7691          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_cal_rdy(u8 *cal_rdy_u8)
   7692          {
   7693          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7694          	/*  Variable used to return value of
   7695          	communication routine*/
   7696          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7697              
   7698          	if (p_bma2x2 == BMA2x2_NULL) {
   7699          		/* Check the struct p_bma2x2 is empty */
   7700          		return E_BMA2x2_NULL_PTR;
   7701              } else {
   7702          		com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7703                      (p_bma2x2->dev_addr,
   7704                       BMA2x2_FAST_CAL_RDY_STAT_REG,
   7705                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7706          		*cal_rdy_u8 = BMA2x2_GET_BITSLICE(data_u8,
   7707                                                    BMA2x2_FAST_CAL_RDY_STAT);
   7708          	}
   7709          	return com_rslt;
   7710          }
   7711          /*!
   7712          *	@brief This API is used to set
   7713          *	the trigger of fast offset compensation(x/y/z) in the register 0x36
   7714          *	bit 5~6
   7715          *
   7716          *
   7717          *
   7718          *  @param  cal_trigger_u8: The value of trigger axis
   7719          *
   7720          *     cal_trigger_u8         |    result
   7721          *  ------------------------- |------------------
   7722          *         0x00               |    None
   7723          *         0x01               |    BMA2x2_OFFSET_TRIGGER_X
   7724          *         0x02               |    BMA2x2_OFFSET_TRIGGER_Y
   7725          *         0x03               |    BMA2x2_OFFSET_TRIGGER_Z
   7726          *   
   7727          *	@return results of bus communication function
   7728          *	@retval 0 -> Success
   7729          *	@retval -1 -> Error
   7730          *
   7731          *
   7732          */
   7733          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_cal_trigger(u8 cal_trigger_u8)
   7734          {
   7735          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7736          	/*  Variable used to return value of
   7737          	communication routine*/
   7738          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7739              
   7740          	if (p_bma2x2 == BMA2x2_NULL) {
   7741          		/* Check the struct p_bma2x2 is empty */
   7742          		return E_BMA2x2_NULL_PTR;
   7743              } else {
   7744                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7745          			(p_bma2x2->dev_addr,
   7746                       BMA2x2_CAL_TRIGGER_REG, &data_u8,
   7747                       BMA2x2_GEN_READ_WRITE_LENGTH);
   7748                  data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   7749                                                BMA2x2_CAL_TRIGGER, cal_trigger_u8);
   7750                  com_rslt += bma2x2_write_reg(
   7751                                               BMA2x2_CAL_TRIGGER_REG,
   7752                                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7753              }
   7754          	return com_rslt;
   7755          }
   7756          /*!
   7757          *	@brief This API is used to set
   7758          *	the offset reset(offset_reset) in the register 0x36
   7759          *	bit 7(Write only possible)
   7760          *
   7761          *
   7762          *
   7763          *  @param  offset_rst_u8: The offset reset value
   7764          *
   7765          *
   7766          *
   7767          *	@return results of bus communication function
   7768          *	@retval 0 -> Success
   7769          *	@retval -1 -> Error
   7770          *
   7771          *
   7772          */
   7773          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_offset_rst(u8 offset_rst_u8)
   7774          {
   7775          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7776          	/*  Variable used to return value of
   7777          	communication routine*/
   7778          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7779              
   7780          	if (p_bma2x2 == BMA2x2_NULL) {
   7781          		/* Check the struct p_bma2x2 is empty */
   7782          		return E_BMA2x2_NULL_PTR;
   7783              } else {
   7784                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7785          			(p_bma2x2->dev_addr,
   7786                       BMA2x2_RST_OFFSET_REG,
   7787                       &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7788                  data_u8 = BMA2x2_SET_BITSLICE
   7789          			(data_u8, BMA2x2_RST_OFFSET,
   7790                       offset_rst_u8);
   7791                  com_rslt += bma2x2_write_reg(
   7792                                               BMA2x2_RST_OFFSET_REG,
   7793                                               &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7794              }
   7795          	return com_rslt;
   7796          }
   7797          /*!
   7798          *	@brief This API is used to get
   7799          *	the status of offset target axis(offset_target_x, offset_target_y and
   7800          *	offset_target_z) and cut_off in the register 0x37
   7801          *	@note CUT_OFF -> bit 0
   7802          *	@note OFFSET_TRIGGER_X -> bit 1 and 2
   7803          *	@note OFFSET_TRIGGER_Y -> bit 3 and 4
   7804          *	@note OFFSET_TRIGGER_Z -> bit 5 and 6
   7805          *
   7806          *
   7807          *  @param channel_u8: The value of offset axis selection
   7808          *     channel_u8           |    result
   7809          *  ------------------------- |------------------
   7810          *        0                   |   BMA2x2_ACCEL_CUT_OFF
   7811          *        1                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_X
   7812          *        2                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_Y
   7813          *        2                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_Z
   7814          *
   7815          *  @param  offset_u8: The offset target value
   7816          *     CUT_OFF                |    result
   7817          *  ------------------------- |------------------
   7818          *        0                   |   1Hz
   7819          *        1                   |   10Hz
   7820          *
   7821          *
   7822          *     OFFSET_TRIGGER         |    result
   7823          *  ------------------------- |------------------
   7824          *        0x00                |   0g
   7825          *        0x01                |   +1g
   7826          *        0x02                |   -1g
   7827          *        0x03                |   0g
   7828          *
   7829          *	@return results of bus communication function
   7830          *	@retval 0 -> Success
   7831          *	@retval -1 -> Error
   7832          *
   7833          *
   7834          */
   7835          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_offset_target(u8 channel_u8,
   7836                                                               u8 *offset_u8)
   7837          {
   7838          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7839          	/*  Variable used to return value of
   7840          	communication routine*/
   7841          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7842              
   7843          	if (p_bma2x2 == BMA2x2_NULL) {
   7844          		/* Check the struct p_bma2x2 is empty */
   7845          		return E_BMA2x2_NULL_PTR;
   7846              } else {
   7847          		switch (channel_u8) {
   7848                    case BMA2x2_CUT_OFF:
   7849          			/*CUT-OFF*/
   7850          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7851                          (p_bma2x2->dev_addr,
   7852                           BMA2x2_COMP_CUTOFF_REG, &data_u8,
   7853                           BMA2x2_GEN_READ_WRITE_LENGTH);
   7854          			*offset_u8 = BMA2x2_GET_BITSLICE(data_u8,
   7855                                                       BMA2x2_COMP_CUTOFF);
   7856                      break;
   7857                    case BMA2x2_OFFSET_TRIGGER_X:
   7858          			/*OFFSET TRIGGER X*/
   7859          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7860                          (p_bma2x2->dev_addr,
   7861                           BMA2x2_COMP_TARGET_OFFSET_X_REG,
   7862                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7863          			*offset_u8 = BMA2x2_GET_BITSLICE(data_u8,
   7864                                                       BMA2x2_COMP_TARGET_OFFSET_X);
   7865                      break;
   7866                    case BMA2x2_OFFSET_TRIGGER_Y:
   7867          			/*OFFSET TRIGGER Y*/
   7868          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7869                          (p_bma2x2->dev_addr,
   7870                           BMA2x2_COMP_TARGET_OFFSET_Y_REG,
   7871                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7872          			*offset_u8 = BMA2x2_GET_BITSLICE(data_u8,
   7873                                                       BMA2x2_COMP_TARGET_OFFSET_Y);
   7874                      break;
   7875                    case BMA2x2_OFFSET_TRIGGER_Z:
   7876          			/*OFFSET TRIGGER Z*/
   7877          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7878                          (p_bma2x2->dev_addr,
   7879                           BMA2x2_COMP_TARGET_OFFSET_Z_REG,
   7880                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7881          			*offset_u8 = BMA2x2_GET_BITSLICE
   7882                          (data_u8, BMA2x2_COMP_TARGET_OFFSET_Z);
   7883                      break;
   7884                    default:
   7885          			com_rslt = E_OUT_OF_RANGE;
   7886                      break;
   7887          		}
   7888          	}
   7889          	return com_rslt;
   7890          }
   7891          /*!
   7892          *	@brief This API is used to set
   7893          *	the status of offset target axis(offset_target_x, offset_target_y and
   7894          *	offset_target_z) and cut_off in the register 0x37
   7895          *	@note CUT_OFF -> bit 0
   7896          *	@note OFFSET_TRIGGER_X -> bit 1 and 2
   7897          *	@note OFFSET_TRIGGER_Y -> bit 3 and 4
   7898          *	@note OFFSET_TRIGGER_Z -> bit 5 and 6
   7899          *
   7900          *
   7901          *  @param channel_u8: The value of offset axis selection
   7902          *     channel_u8           |    result
   7903          *  ------------------------- |------------------
   7904          *        0                   |   BMA2x2_ACCEL_CUT_OFF
   7905          *        1                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_X
   7906          *        2                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_Y
   7907          *        3                   |   BMA2x2_ACCEL_OFFSET_TRIGGER_Z
   7908          *
   7909          *  @param  offset_u8: The offset target value
   7910          *     CUT_OFF                |    result
   7911          *  ------------------------- |------------------
   7912          *        0                   |   1Hz
   7913          *        1                   |   10Hz
   7914          *
   7915          *
   7916          *     OFFSET_TRIGGER         |    result
   7917          *  ------------------------- |------------------
   7918          *        0x00                |   0g
   7919          *        0x01                |   +1g
   7920          *        0x02                |   -1g
   7921          *        0x03                |   0g
   7922          *
   7923          *	@return results of bus communication function
   7924          *	@retval 0 -> Success
   7925          *	@retval -1 -> Error
   7926          *
   7927          *
   7928          */
   7929          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_offset_target(u8 channel_u8,
   7930                                                               u8 offset_u8)
   7931          {
   7932          	u8 data_u8 = BMA2x2_INIT_VALUE;
   7933          	/*  Variable used to return value of
   7934          	communication routine*/
   7935          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   7936              
   7937          	if (p_bma2x2 == BMA2x2_NULL) {
   7938          		/* Check the struct p_bma2x2 is empty */
   7939          		return E_BMA2x2_NULL_PTR;
   7940              } else {
   7941          		switch (channel_u8) {
   7942                    case BMA2x2_CUT_OFF:
   7943          			/*CUT-OFF*/
   7944          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7945                          (p_bma2x2->dev_addr,
   7946                           BMA2x2_COMP_CUTOFF_REG,
   7947                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7948          			data_u8 = BMA2x2_SET_BITSLICE
   7949                          (data_u8, BMA2x2_COMP_CUTOFF, offset_u8);
   7950          			com_rslt += bma2x2_write_reg(
   7951                                                   BMA2x2_COMP_CUTOFF_REG,
   7952                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7953                      break;
   7954                    case BMA2x2_OFFSET_TRIGGER_X:
   7955          			/*OFFSET TARGET X*/
   7956          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7957                          (p_bma2x2->dev_addr,
   7958                           BMA2x2_COMP_TARGET_OFFSET_X_REG,
   7959                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7960          			data_u8 = BMA2x2_SET_BITSLICE
   7961                          (data_u8, BMA2x2_COMP_TARGET_OFFSET_X, offset_u8);
   7962          			com_rslt += bma2x2_write_reg(
   7963                                                   BMA2x2_COMP_TARGET_OFFSET_X_REG,
   7964                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7965                      break;
   7966                    case BMA2x2_OFFSET_TRIGGER_Y:
   7967          			/*OFFSET TARGET Y*/
   7968          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7969                          (p_bma2x2->dev_addr,
   7970                           BMA2x2_COMP_TARGET_OFFSET_Y_REG,
   7971                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7972          			data_u8 = BMA2x2_SET_BITSLICE
   7973                          (data_u8, BMA2x2_COMP_TARGET_OFFSET_Y, offset_u8);
   7974          			com_rslt += bma2x2_write_reg(
   7975                                                   BMA2x2_COMP_TARGET_OFFSET_Y_REG,
   7976                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7977                      break;
   7978                    case BMA2x2_OFFSET_TRIGGER_Z:
   7979          			/*OFFSET TARGET Z*/
   7980          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   7981                          (p_bma2x2->dev_addr,
   7982                           BMA2x2_COMP_TARGET_OFFSET_Z_REG,
   7983                           &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7984          			data_u8 = BMA2x2_SET_BITSLICE
   7985                          (data_u8, BMA2x2_COMP_TARGET_OFFSET_Z, offset_u8);
   7986          			com_rslt += bma2x2_write_reg(
   7987                                                   BMA2x2_COMP_TARGET_OFFSET_Z_REG,
   7988                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   7989                      break;
   7990                    default:
   7991          			com_rslt = E_OUT_OF_RANGE;
   7992                      break;
   7993          		}
   7994          	}
   7995          	return com_rslt;
   7996          }
   7997          /*!
   7998          *	@brief This API is used to get the status of offset
   7999          *	(offset_x, offset_y and offset_z) in the registers 0x38,0x39 and 0x3A
   8000          *	@note offset_x -> register 0x38 bit 0 to 7
   8001          *	@note offset_y -> register 0x39 bit 0 to 7
   8002          *	@note offset_z -> register 0x3A bit 0 to 7
   8003          *
   8004          *
   8005          *  @param channel_u8: The value of offset selection
   8006          *     channel_u8           |    result
   8007          *  ------------------------- |------------------
   8008          *        0                   |   BMA2x2_ACCEL_X_AXIS
   8009          *        1                   |   BMA2x2_ACCEL_Y_AXIS
   8010          *        2                   |   BMA2x2_ACCEL_Z_AXIS
   8011          *
   8012          *  @param offset_u8: The value of offset
   8013          *
   8014          *
   8015          *
   8016          *	@return results of bus communication function
   8017          *	@retval 0 -> Success
   8018          *	@retval -1 -> Error
   8019          *
   8020          *
   8021          */
   8022          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_offset(u8 channel_u8,
   8023                                                        s8 *offset_u8)
   8024          {
   8025          	u8 data_u8 = BMA2x2_INIT_VALUE;
   8026          	/*  Variable used to return value of
   8027          	communication routine*/
   8028          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8029              
   8030          	if (p_bma2x2 == BMA2x2_NULL) {
   8031          		/* Check the struct p_bma2x2 is empty */
   8032          		return E_BMA2x2_NULL_PTR;
   8033              } else {
   8034          		switch (channel_u8) {
   8035                    case BMA2x2_X_AXIS:
   8036          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8037                          (p_bma2x2->dev_addr,
   8038                           BMA2x2_OFFSET_X_AXIS_ADDR, &data_u8,
   8039                           BMA2x2_GEN_READ_WRITE_LENGTH);
   8040          			*offset_u8 = (s8)data_u8;
   8041                      break;
   8042                    case BMA2x2_Y_AXIS:
   8043          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8044                          (p_bma2x2->dev_addr,
   8045                           BMA2x2_OFFSET_Y_AXIS_ADDR, &data_u8,
   8046                           BMA2x2_GEN_READ_WRITE_LENGTH);
   8047          			*offset_u8 = (s8)data_u8;
   8048                      break;
   8049                    case BMA2x2_Z_AXIS:
   8050          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8051                          (p_bma2x2->dev_addr,
   8052                           BMA2x2_OFFSET_Z_AXIS_ADDR, &data_u8,
   8053                           BMA2x2_GEN_READ_WRITE_LENGTH);
   8054          			*offset_u8 = (s8)data_u8;
   8055                      break;
   8056                    default:
   8057          			com_rslt = E_OUT_OF_RANGE;
   8058                      break;
   8059          		}
   8060          	}
   8061          	return com_rslt;
   8062          }
   8063          /*!
   8064          *	@brief This API is used to set the status of offset
   8065          *	(offset_x, offset_y and offset_z) in the registers 0x38,0x39 and 0x3A
   8066          *	@note offset_x -> register 0x38 bit 0 to 7
   8067          *	@note offset_y -> register 0x39 bit 0 to 7
   8068          *	@note offset_z -> register 0x3A bit 0 to 7
   8069          *
   8070          *
   8071          *  @param channel_u8: The value of offset selection
   8072          *     channel_u8           |    result
   8073          *  ------------------------- |------------------
   8074          *        0                   |   BMA2x2_ACCEL_X_AXIS
   8075          *        1                   |   BMA2x2_ACCEL_Y_AXIS
   8076          *        2                   |   BMA2x2_ACCEL_Z_AXIS
   8077          *
   8078          *  @param offset_u8: The value of offset
   8079          *
   8080          *
   8081          *
   8082          *	@return results of bus communication function
   8083          *	@retval 0 -> Success
   8084          *	@retval -1 -> Error
   8085          *
   8086          *
   8087          */
   8088          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_offset(u8 channel_u8,
   8089                                                        s8 offset_u8)
   8090          {
   8091          	u8 data_u8 = BMA2x2_INIT_VALUE;
   8092          	/*  Variable used to return value of
   8093          	communication routine*/
   8094          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8095              
   8096          	if (p_bma2x2 == BMA2x2_NULL) {
   8097          		/* Check the struct p_bma2x2 is empty */
   8098          		return E_BMA2x2_NULL_PTR;
   8099              } else {
   8100          		switch (channel_u8) {
   8101                    case BMA2x2_X_AXIS:
   8102          			data_u8 = offset_u8;
   8103          			com_rslt = bma2x2_write_reg(
   8104                                                  BMA2x2_OFFSET_X_AXIS_ADDR, &data_u8,
   8105                                                  BMA2x2_GEN_READ_WRITE_LENGTH);
   8106                      break;
   8107                    case BMA2x2_Y_AXIS:
   8108          			data_u8 = offset_u8;
   8109          			com_rslt = bma2x2_write_reg(
   8110                                                  BMA2x2_OFFSET_Y_AXIS_ADDR, &data_u8,
   8111                                                  BMA2x2_GEN_READ_WRITE_LENGTH);
   8112                      break;
   8113                    case BMA2x2_Z_AXIS:
   8114          			data_u8 = offset_u8;
   8115          			com_rslt = bma2x2_write_reg(
   8116                                                  BMA2x2_OFFSET_Z_AXIS_ADDR, &data_u8,
   8117                                                  BMA2x2_GEN_READ_WRITE_LENGTH);
   8118                      break;
   8119                    default:
   8120          			com_rslt = E_OUT_OF_RANGE;
   8121                      break;
   8122          		}
   8123          	}
   8124          	return com_rslt;
   8125          }
   8126          /*!
   8127          *	@brief This API is used to get
   8128          *	the status of fifo (fifo_mode) in the register 0x3E bit 6 and 7
   8129          *
   8130          *
   8131          *  @param fifo_mode_u8 : The value of fifo mode
   8132          *     fifo_mode_u8         |    result
   8133          *  ------------------------- |------------------
   8134          *        0x00                |   BYPASS
   8135          *        0x01                |   FIFO
   8136          *        0x02                |   STREAM
   8137          *        0x03                |   RESERVED
   8138          *
   8139          *
   8140          *
   8141          *	@return results of bus communication function
   8142          *	@retval 0 -> Success
   8143          *	@retval -1 -> Error
   8144          *
   8145          *
   8146          */
   8147          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_fifo_mode(u8 *fifo_mode_u8)
   8148          {
   8149          	/*  Variable used to return value of
   8150          	communication routine*/
   8151          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8152          	u8 data_u8 = BMA2x2_INIT_VALUE;
   8153              
   8154          	if (p_bma2x2 == BMA2x2_NULL) {
   8155          		/* Check the struct p_bma2x2 is empty */
   8156          		return E_BMA2x2_NULL_PTR;
   8157              } else {
   8158                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   8159                                                            p_bma2x2->dev_addr,
   8160                                                            BMA2x2_FIFO_MODE_REG, &data_u8,
   8161                                                            BMA2x2_GEN_READ_WRITE_LENGTH);
   8162                  *fifo_mode_u8 = BMA2x2_GET_BITSLICE(data_u8,
   8163                                                      BMA2x2_FIFO_MODE);
   8164              }
   8165          	return com_rslt;
   8166          }
   8167          /*!
   8168          *	@brief This API is used to set
   8169          *	the status of fifo (fifo_mode) in the register 0x3E bit 6 and 7
   8170          *
   8171          *
   8172          *  @param fifo_mode_u8 : The value of fifo mode
   8173          *     fifo_mode_u8         |    result
   8174          *  ------------------------- |------------------
   8175          *        0x00                |   BYPASS
   8176          *        0x01                |   FIFO
   8177          *        0x02                |   STREAM
   8178          *        0x03                |   RESERVED
   8179          *
   8180          *
   8181          *
   8182          *	@return results of bus communication function
   8183          *	@retval 0 -> Success
   8184          *	@retval -1 -> Error
   8185          *	@retval -127 -> Null Pointer Error
   8186          *
   8187          */
   8188          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_fifo_mode(u8 fifo_mode_u8)
   8189          {
   8190          	u8 data_u8 = BMA2x2_INIT_VALUE;
   8191          	u8 power_mode = BMA2x2_INIT_VALUE;
   8192              /*  Variable used to return value of
   8193          	communication routine*/
   8194          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8195              
   8196          	if (p_bma2x2 == BMA2x2_NULL) {
   8197          		/* Check the struct p_bma2x2 is empty */
   8198          		com_rslt = E_BMA2x2_NULL_PTR;
   8199          	} else {
   8200          		if (fifo_mode_u8 < BMA2x2_FIFO_MODE_RANGE) {
   8201          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8202                          (p_bma2x2->dev_addr,
   8203                           BMA2x2_FIFO_MODE_REG, &data_u8,
   8204                           BMA2x2_GEN_READ_WRITE_LENGTH);
   8205          			data_u8 = BMA2x2_SET_BITSLICE(data_u8,
   8206                                                    BMA2x2_FIFO_MODE, fifo_mode_u8);
   8207          			data_u8 |= 0x0C;
   8208          			/*Power mode is switched to Standby power mode*/
   8209          			com_rslt += bma2x2_get_power_mode(&power_mode);
   8210          			com_rslt += bma2x2_set_power_mode(BMA2x2_MODE_STANDBY);
   8211          			/*Configure the mode in FIFO_CONFIG registers*/
   8212          			com_rslt += bma2x2_write_reg(BMA2x2_FIFO_MODE_REG,
   8213                                                   &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   8214          			if (com_rslt == SUCCESS) {
   8215          				/*FIFO config is stored in struct p_bma2x2*/
   8216          				p_bma2x2->fifo_config = data_u8;
   8217          			}
   8218          			/*Power mode is reverted to previously set mode */
   8219          			com_rslt += bma2x2_set_power_mode(power_mode);
   8220                      
   8221          		} else {
   8222          			com_rslt = E_OUT_OF_RANGE;
   8223          		}
   8224          	}
   8225          	return com_rslt;
   8226          }
   8227          /*!
   8228          * @brief This API is used to get
   8229          * the axis enable of fifo data select in the register 0x3E bit 0 and 1
   8230          *
   8231          *
   8232          *  @param fifo_data_select_u8 : The value of FIFO axis data select
   8233          *   fifo_data_select_u8    |    result
   8234          *  ------------------------- |------------------
   8235          *        0x00                |   XYZ
   8236          *        0x01                |   Y
   8237          *        0x02                |   X
   8238          *        0x03                |   Z
   8239          *
   8240          *
   8241          *
   8242          *	@return results of bus communication function
   8243          *	@retval 0 -> Success
   8244          *	@retval -1 -> Error
   8245          *
   8246          *
   8247          */
   8248          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_fifo_data_select(u8 *fifo_data_select_u8)
   8249          {
   8250              /*  Variable used to return value of
   8251          	communication routine*/
   8252          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8253          	u8 data_u8 = BMA2x2_INIT_VALUE;
   8254              
   8255          	if (p_bma2x2 == BMA2x2_NULL) {
   8256          		/* Check the struct p_bma2x2 is empty */
   8257          		return E_BMA2x2_NULL_PTR;
   8258              } else {
   8259                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(p_bma2x2->dev_addr,
   8260                                                            BMA2x2_FIFO_DATA_SELECT_REG,
   8261                                                            &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   8262                  *fifo_data_select_u8 = BMA2x2_GET_BITSLICE(data_u8,
   8263                                                             BMA2x2_FIFO_DATA_SELECT);
   8264              }
   8265          	return com_rslt;
   8266          }
   8267          /*!
   8268          * @brief This API is used to set
   8269          * the axis enable of fifo data select in the register 0x3E bit 0 and 1
   8270          *
   8271          *
   8272          *  @param fifo_data_select_u8 : The value of FIFO axis data select
   8273          *   fifo_data_select_u8      |    result
   8274          *  ------------------------- |------------------
   8275          *        0x00                |   XYZ
   8276          *        0x01                |   Y
   8277          *        0x02                |   X
   8278          *        0x03                |   Z
   8279          *
   8280          *
   8281          *
   8282          *	@return results of bus communication function
   8283          *	@retval 0 -> Success
   8284          *	@retval -1 -> Error
   8285          *	@retval -127 -> Null Pointer Error
   8286          *
   8287          */
   8288          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_set_fifo_data_select(u8 fifo_data_select_u8)
   8289          {
   8290          	u8 data_u8 = BMA2x2_INIT_VALUE;
   8291          	u8 power_mode = BMA2x2_INIT_VALUE;
   8292          	/*  Variable used to return value of
   8293          	communication routine*/
   8294          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8295              
   8296          	if (p_bma2x2 == BMA2x2_NULL) {
   8297          		/* Check the struct p_bma2x2 is empty */
   8298          		com_rslt = E_BMA2x2_NULL_PTR;
   8299          	} else {
   8300          		if (fifo_data_select_u8 < BMA2x2_FIFO_DATA_SELECT_RANGE) {
   8301          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8302                          (p_bma2x2->dev_addr,
   8303                           BMA2x2_FIFO_DATA_SELECT_REG, &data_u8,
   8304                           BMA2x2_GEN_READ_WRITE_LENGTH);
   8305          			data_u8 = BMA2x2_SET_BITSLICE
   8306                          (data_u8,
   8307                           BMA2x2_FIFO_DATA_SELECT, fifo_data_select_u8);
   8308          			data_u8 |= 0x0C;
   8309          			/*Power mode is switched to Standby power mode*/
   8310          			com_rslt += bma2x2_get_power_mode(&power_mode);
   8311          			com_rslt += bma2x2_set_power_mode(BMA2x2_MODE_STANDBY);
   8312          			/* Configure appropriate (X,Y,Z) axes data to be
   8313          			available in FIFO*/
   8314          			com_rslt += bma2x2_write_reg(
   8315                                                   BMA2x2_FIFO_DATA_SELECT_REG, &data_u8, 1);
   8316          			if (com_rslt == SUCCESS) {
   8317          				/*FIFO config is stored in struct p_bma2x2*/
   8318          				p_bma2x2->fifo_config = data_u8;
   8319          			}
   8320          			/*Power mode is reverted to previously set mode */
   8321          			com_rslt += bma2x2_set_power_mode(power_mode);
   8322          		} else {
   8323          			com_rslt = E_OUT_OF_RANGE;
   8324          		}
   8325          	}
   8326          	return com_rslt;
   8327          }
   8328          
   8329          /*!
   8330          *  @brief This API reads the FIFO data from the register 0x3F
   8331          *  and store the data in the user defined buffer mapped to the member
   8332          *  of structure "fifo_configuration"
   8333          *
   8334          *  @note Before calling this API user must map the following FIFO settings
   8335          *  required to read the FIFO data to the structure "fifo_configuration"
   8336          *    - Data buffer to store the FIFO data is mapped to
   8337          *      the structure member "fifo_data"
   8338          *    - Number of bytes to be read from FIFO is mapped to
   8339          *      the structure member "fifo_length"
   8340          *
   8341          *  @note The number of bytes to be read from the FIFO is specified in the
   8342          *  member "fifo_length" of the structure "fifo_configuration"
   8343          *
   8344          *  @param[in,out] fifo_conf : Structure containing the FIFO configurations
   8345          *  is passed as input and FIFO data of specified length is obtained as output
   8346          *
   8347          *  @return results of bus communication function
   8348          *  @retval 0 -> Success
   8349          *  @retval -1 -> Error
   8350          *  @retval -127 -> Null Pointer Error
   8351          *
   8352          */
   8353          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_fifo_data(struct fifo_configuration *fifo_conf)
   8354          {
   8355          	u8 fifo_frame_count = 0;
   8356          	u8 fifo_data_bytes = 0;
   8357          	u8 fifo_data_select = 0;
   8358          	/*  Variable used to return value of
   8359          	communication routine*/
   8360          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8361              
   8362          	if (p_bma2x2 == BMA2x2_NULL || fifo_conf->fifo_data == BMA2x2_NULL) {
   8363          		/* Check the struct p_bma2x2 is empty */
   8364          		com_rslt = E_BMA2x2_NULL_PTR;
   8365          	} else {
   8366          		/*Resetting the FIFO data byte index*/
   8367          		fifo_conf->accel_byte_start_index = 0;
   8368          		/*Frames in FIFO is stored */
   8369          		com_rslt = bma2x2_get_fifo_frame_count(&fifo_frame_count);
   8370          		/*FIFO data select value is stored*/
   8371          		com_rslt += bma2x2_get_fifo_data_select(&fifo_data_select);
   8372          		/*Number of bytes in FIFO is calculated*/
   8373          		if (fifo_data_select == BMA2x2_FIFO_XYZ_DATA_ENABLED) {
   8374          			/*Number of bytes in FIFO when XYZ data are enabled*/
   8375          			fifo_data_bytes = fifo_frame_count *
   8376                          BMA2x2_FIFO_XYZ_AXES_FRAME_SIZE;
   8377          		} else {
   8378          			/*No of bytes in FIFO when single axis data enabled*/
   8379          			fifo_data_bytes = fifo_frame_count *
   8380                          BMA2x2_FIFO_SINGLE_AXIS_FRAME_SIZE;
   8381          		}
   8382          		/*Handled the case where user requests to read more FIFO
   8383          		length than available FIFO data*/
   8384          		if (fifo_conf->fifo_length > fifo_data_bytes) {
   8385          			/*Number of bytes in FIFO is read entirely when user
   8386          			reads more FIFO data than available*/
   8387          			fifo_conf->fifo_length = fifo_data_bytes;
   8388          		}
   8389          		/*Read the FIFO data*/
   8390          		com_rslt += p_bma2x2->BMA2x2_BUS_READ_FUNC(p_bma2x2->dev_addr,
   8391                                                             BMA2x2_FIFO_DATA_OUTPUT_ADDR, fifo_conf->fifo_data,
   8392                                                             fifo_conf->fifo_length);
   8393          	}
   8394          	return com_rslt;
   8395          }
   8396          
   8397          /*!
   8398          *  @brief This API extracts the accel data from the FIFO frames
   8399          *
   8400          *  @note The bma2x2_extract_accel() API should be called only after reading
   8401          *  the FIFO data by calling the bma2x2_read_fifo_data() API
   8402          *
   8403          *  @param[in,out] accel_frame      : Instance of the union where accel data
   8404          *                                    in FIFO is parsed and stored
   8405          *
   8406          *  @param[in,out] accel_frame_count: Number of Accel frames requested by user
   8407          *                                    is got as input and number of
   8408          *                                    accel frames parsed and stored is
   8409          *                                    returned as output to user
   8410          *
   8411          *  @param[in, out] fifo_conf       : FIFO configuration structure.
   8412          *                                    It provides the following as input
   8413          *                                        - user defined buffer
   8414          *                                        - length of FIFO data read
   8415          *                                    It returns the accel_byte_start_index
   8416          *                                    (index of accel bytes parsed from FIFO)
   8417          *
   8418          *  @return results of API execution status
   8419          *  @retval 0 -> Success
   8420          *  @retval -127 -> Error
   8421          *
   8422          */
   8423          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_extract_accel(union fifo_frame *accel_frame,
   8424                                                           u8 *accel_frame_count, struct fifo_configuration *fifo_conf)
   8425          {
   8426          	u8 data_index = 0;
   8427          	u8 accel_index = 0;
   8428          	u8 data_read_length = 0;
   8429          	u8 fifo_data_select = 0;
   8430          	/*  Variable used to return value of communication routine*/
   8431          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = 0;
   8432              
   8433          	if (p_bma2x2 == BMA2x2_NULL || fifo_conf->fifo_data == BMA2x2_NULL) {
   8434          		/* Check the struct p_bma2x2 is empty and FIFO data buffer
   8435          		not being mapped to  fifo_configuration structure */
   8436          		com_rslt = E_BMA2x2_NULL_PTR;
   8437          	} else {
   8438          		/* FIFO data enable value is stored in fifo_data_select*/
   8439          		fifo_data_select = p_bma2x2->fifo_config &
   8440                      BMA2x2_FIFO_DATA_ENABLED_MASK;
   8441          		/* FIFO bytes available for parsing is obtained in
   8442          		data_read_length*/
   8443          		get_accel_len_to_parse(&data_index, &data_read_length,
   8444                                         *accel_frame_count, fifo_data_select, fifo_conf);
   8445          		/*Parse the FIFO data from accel byte start index to
   8446          		data_read_length*/
   8447          		for (; data_index < data_read_length; ) {
   8448          			unpack_accel_frame(accel_frame, &data_index,
   8449                                         &accel_index, fifo_data_select, fifo_conf);
   8450          		}
   8451          		/* update number of accel data read*/
   8452          		*accel_frame_count = accel_index;
   8453          		/*update the accel byte index*/
   8454          		fifo_conf->accel_byte_start_index = data_index;
   8455          	}
   8456          	return com_rslt;
   8457          }
   8458          
   8459          /*!
   8460          *  @brief This API computes the number of bytes of accel FIFO data
   8461          *  which is to be parsed.
   8462          */
   8463          static void get_accel_len_to_parse(u8 *data_index, u8 *data_read_length,
   8464                                             u8 accel_frame_count, u8 fifo_data_select,
   8465                                             struct fifo_configuration *fifo_conf)
   8466          {
   8467          	/*Current data index is set to accel_byte_start_index*/
   8468          	*data_index = fifo_conf->accel_byte_start_index;
   8469          	/* FIFO bytes corresponding to the requested FIFO frames is obtained*/
   8470          	if (fifo_data_select == BMA2x2_FIFO_XYZ_DATA_ENABLED) {
   8471          		/*Number of bytes in FIFO when XYZ data are enabled*/
   8472          		*data_read_length = accel_frame_count *
   8473                      BMA2x2_FIFO_XYZ_AXES_FRAME_SIZE;
   8474          	} else {
   8475          		/*No of bytes in FIFO when single axis data enabled*/
   8476          		*data_read_length = accel_frame_count *
   8477                      BMA2x2_FIFO_SINGLE_AXIS_FRAME_SIZE;
   8478          	}
   8479          	if ((*data_read_length) > fifo_conf->fifo_length) {
   8480          		/*Handling the case where more FIFO frame is requested
   8481          		than available*/
   8482          		*data_read_length = fifo_conf->fifo_length;
   8483          	}
   8484          }
   8485          
   8486          /*!
   8487          *  @brief This API is used to parse the accelerometer frame from the
   8488          *  user defined FIFO data buffer mapped to the structure fifo_conf and store
   8489          *  it in the union fifo_frame
   8490          *
   8491          *  @note It update the data_index value which is used to store the index of
   8492          *  the current data byte which is parsed.
   8493          *
   8494          *  @note The parsed accel frames stored in the union fifo_conf contains data
   8495          *  in accordance with the enabled data axes to be stored in FIFO
   8496          *  (XYZ axes or individual axis)
   8497          */
   8498          static void unpack_accel_frame(union fifo_frame *accel_frame, u8 *data_index,
   8499                                         u8 *accel_index, u8 fifo_data_select,
   8500                                         struct fifo_configuration *fifo_conf)
   8501          {
   8502          	u16 data_lsb = 0;
   8503          	u16 data_msb = 0;
   8504              
   8505          	switch (fifo_data_select) {
   8506                  
   8507                case BMA2x2_FIFO_XYZ_DATA_ENABLED:
   8508          		unpack_accel_xyz(&accel_frame[*accel_index], data_index,
   8509                                   fifo_conf);
   8510          		/* Accel index is updated*/
   8511          		(*accel_index)++;
   8512                  break;
   8513                  
   8514                case BMA2x2_FIFO_X_DATA_ENABLED:
   8515          		/* Accel raw x data */
   8516          		data_lsb = fifo_conf->fifo_data[(*data_index)++];
   8517          		data_msb = fifo_conf->fifo_data[(*data_index)++];
   8518          		accel_frame[*accel_index].x = (u16)((data_msb << 8) | data_lsb);
   8519                  
   8520          		/* Resolution based data from FIFO is updated */
   8521          		if (V_BMA2x2RESOLUTION_U8 == BMA2x2_12_RESOLUTION) {
   8522          			accel_frame[*accel_index].x =
   8523                          (accel_frame[*accel_index].x >> 4);
   8524          		} else if (V_BMA2x2RESOLUTION_U8 == BMA2x2_14_RESOLUTION) {
   8525          			accel_frame[*accel_index].x =
   8526                          (accel_frame[*accel_index].x >> 2);
   8527          		} else if (V_BMA2x2RESOLUTION_U8 == BMA2x2_10_RESOLUTION) {
   8528          			accel_frame[*accel_index].x =
   8529                          (accel_frame[*accel_index].x >> 6);
   8530          		}
   8531          		/* Accel index is updated*/
   8532          		(*accel_index)++;
   8533                  break;
   8534                  
   8535                case BMA2x2_FIFO_Y_DATA_ENABLED:
   8536          		/* Accel raw y data */
   8537          		data_lsb = fifo_conf->fifo_data[(*data_index)++];
   8538          		data_msb = fifo_conf->fifo_data[(*data_index)++];
   8539          		accel_frame[*accel_index].y = (u16)((data_msb << 8) | data_lsb);
   8540                  
   8541          		/* Resolution based data from FIFO is updated */
   8542          		if (V_BMA2x2RESOLUTION_U8 == BMA2x2_12_RESOLUTION) {
   8543          			accel_frame[*accel_index].y =
   8544                          (accel_frame[*accel_index].y >> 4);
   8545          		} else if (V_BMA2x2RESOLUTION_U8 == BMA2x2_14_RESOLUTION) {
   8546          			accel_frame[*accel_index].y =
   8547                          (accel_frame[*accel_index].y >> 2);
   8548          		} else if (V_BMA2x2RESOLUTION_U8 == BMA2x2_10_RESOLUTION) {
   8549          			accel_frame[*accel_index].y =
   8550                          (accel_frame[*accel_index].y >> 6);
   8551          		}
   8552          		/* Accel index is updated*/
   8553          		(*accel_index)++;
   8554                  break;
   8555                  
   8556                case BMA2x2_FIFO_Z_DATA_ENABLED:
   8557          		/* Accel raw z data */
   8558          		data_lsb = fifo_conf->fifo_data[(*data_index)++];
   8559          		data_msb = fifo_conf->fifo_data[(*data_index)++];
   8560          		accel_frame[*accel_index].z = (u16)((data_msb << 8) | data_lsb);
   8561                  
   8562          		/* Resolution based data from FIFO is updated */
   8563          		if (V_BMA2x2RESOLUTION_U8 == BMA2x2_12_RESOLUTION) {
   8564          			accel_frame[*accel_index].z =
   8565                          (accel_frame[*accel_index].z >> 4);
   8566          		} else if (V_BMA2x2RESOLUTION_U8 == BMA2x2_14_RESOLUTION) {
   8567          			accel_frame[*accel_index].z =
   8568                          (accel_frame[*accel_index].z >> 2);
   8569          		} else if (V_BMA2x2RESOLUTION_U8 == BMA2x2_10_RESOLUTION) {
   8570          			accel_frame[*accel_index].z =
   8571                          (accel_frame[*accel_index].z >> 6);
   8572          		}
   8573          		/* Accel index is updated*/
   8574          		(*accel_index)++;
   8575                  break;
   8576                  
   8577                default:
   8578                  break;
   8579          	}
   8580          }
   8581          
   8582          /*!
   8583          *  @brief This API is used to parse the accelerometer data and
   8584          *  store it in the union fifo_frame
   8585          *  It also updates the data_index value which stores the index of
   8586          *  the current data byte which is parsed
   8587          *
   8588          */
   8589          static void unpack_accel_xyz(union fifo_frame *accel_frame, u8 *data_index,
   8590                                       struct fifo_configuration *fifo_conf)
   8591          {
   8592          	u16 data_lsb = 0;
   8593          	u16 data_msb = 0;
   8594              
   8595          	/* Accel raw x data */
   8596          	data_lsb = fifo_conf->fifo_data[(*data_index)++];
   8597          	data_msb = fifo_conf->fifo_data[(*data_index)++];
   8598          	accel_frame->accel_data.x = (u16)((data_msb << 8) | data_lsb);
   8599              
   8600          	/* Accel raw y data */
   8601          	data_lsb = fifo_conf->fifo_data[(*data_index)++];
   8602          	data_msb = fifo_conf->fifo_data[(*data_index)++];
   8603          	accel_frame->accel_data.y = (u16)((data_msb << 8) | data_lsb);
   8604              
   8605          	/* Accel raw z data */
   8606          	data_lsb = fifo_conf->fifo_data[(*data_index)++];
   8607          	data_msb = fifo_conf->fifo_data[(*data_index)++];
   8608          	accel_frame->accel_data.z = (u16)((data_msb << 8) | data_lsb);
   8609              
   8610          	/* Resolution based data from FIFO is updated */
   8611          	if (V_BMA2x2RESOLUTION_U8 == BMA2x2_12_RESOLUTION) {
   8612          		accel_frame->accel_data.x = (accel_frame->accel_data.x >> 4);
   8613          		accel_frame->accel_data.y = (accel_frame->accel_data.y >> 4);
   8614          		accel_frame->accel_data.z = (accel_frame->accel_data.z >> 4);
   8615          	} else if (V_BMA2x2RESOLUTION_U8 == BMA2x2_14_RESOLUTION) {
   8616          		accel_frame->accel_data.x = (accel_frame->accel_data.x >> 2);
   8617          		accel_frame->accel_data.y = (accel_frame->accel_data.y >> 2);
   8618          		accel_frame->accel_data.z = (accel_frame->accel_data.z >> 2);
   8619          	} else if (V_BMA2x2RESOLUTION_U8 == BMA2x2_10_RESOLUTION) {
   8620          		accel_frame->accel_data.x = (accel_frame->accel_data.x >> 6);
   8621          		accel_frame->accel_data.y = (accel_frame->accel_data.y >> 6);
   8622          		accel_frame->accel_data.z = (accel_frame->accel_data.z >> 6);
   8623          	}
   8624          }
   8625          
   8626          /*!
   8627          * @brief This API is used to read the temp
   8628          * from register 0x08
   8629          *
   8630          *
   8631          *
   8632          *  @param  temp_s8: The value of temperature
   8633          *
   8634          *
   8635          *
   8636          *	@return results of bus communication function
   8637          *	@retval 0 -> Success
   8638          *	@retval -1 -> Error
   8639          *
   8640          *
   8641          */
   8642          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_temp(s8 *temp_s8)
   8643          {
   8644          	u8 data_u8 = BMA2x2_INIT_VALUE;
   8645              /*  Variable used to return value of
   8646          	communication routine*/
   8647          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8648              
   8649          	if (p_bma2x2 == BMA2x2_NULL) {
   8650          		/* Check the struct p_bma2x2 is empty */
   8651          		return E_BMA2x2_NULL_PTR;
   8652              } else {
   8653                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   8654                                                            p_bma2x2->dev_addr,
   8655                                                            BMA2x2_TEMP_ADDR,
   8656                                                            &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   8657                  *temp_s8 = (s8)data_u8;
   8658              }
   8659          	return com_rslt;
   8660          }
   8661          /*!
   8662          * @brief This API reads accelerometer data X,Y,Z values and
   8663          * temperature data from location 02h to 08h
   8664          *
   8665          *
   8666          *
   8667          *
   8668          *  @param accel : The value of accel xyz and temperature data
   8669          *
   8670          *	@return results of bus communication function
   8671          *	@retval 0 -> Success
   8672          *	@retval -1 -> Error
   8673          *
   8674          *
   8675          */
   8676          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_xyzt(
   8677                                                             struct bma2x2_accel_data_temp *accel)
   8678          {
   8679          	/*  Variable used to return value of
   8680          	communication routine*/
   8681          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8682          	u8 data_u8[BMA2x2_ACCEL_XYZ_TEMP_DATA_SIZE] = {
   8683                  BMA2x2_INIT_VALUE, BMA2x2_INIT_VALUE,
   8684                  BMA2x2_INIT_VALUE, BMA2x2_INIT_VALUE,
   8685                  BMA2x2_INIT_VALUE, BMA2x2_INIT_VALUE,
   8686                  BMA2x2_INIT_VALUE};
   8687          	if (p_bma2x2 == BMA2x2_NULL) {
   8688          		/* Check the struct p_bma2x2 is empty */
   8689          		return E_BMA2x2_NULL_PTR;
   8690              } else {
   8691          		switch (V_BMA2x2RESOLUTION_U8) {
   8692                    case BMA2x2_12_RESOLUTION:
   8693          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8694                          (p_bma2x2->dev_addr, BMA2x2_ACCEL_X12_LSB_REG,
   8695                           data_u8, BMA2x2_ACCEL_BW_MIN_RANGE);
   8696                      
   8697          			/* read x data_u8*/
   8698          			accel->x = (s16)((((s32)((s8)
   8699                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_X_MSB]))
   8700                                        << BMA2x2_SHIFT_EIGHT_BITS)|
   8701                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_X_LSB]
   8702                                        & BMA2x2_12_BIT_SHIFT));
   8703          			accel->x = accel->x >> BMA2x2_SHIFT_FOUR_BITS;
   8704                      
   8705          			/* read y data_u8*/
   8706          			accel->y = (s16)((((s32)((s8)
   8707                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_MSB]))
   8708                                        << BMA2x2_SHIFT_EIGHT_BITS)|
   8709                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_LSB]
   8710                                        & BMA2x2_12_BIT_SHIFT));
   8711          			accel->y = accel->y >> BMA2x2_SHIFT_FOUR_BITS;
   8712                      
   8713          			/* read z data_u8*/
   8714          			accel->z = (s16)((((s32)((s8)
   8715                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_MSB]))
   8716                                        << BMA2x2_SHIFT_EIGHT_BITS)|
   8717                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_LSB]
   8718                                        & BMA2x2_12_BIT_SHIFT));
   8719          			accel->z = accel->z >> BMA2x2_SHIFT_FOUR_BITS;
   8720          			/*Accessing the sixth element of array*/
   8721          			accel->temp = (s8)data_u8[BMA2x2_SENSOR_DATA_TEMP];
   8722                      break;
   8723                    case BMA2x2_10_RESOLUTION:
   8724          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8725                          (p_bma2x2->dev_addr, BMA2x2_ACCEL_X10_LSB_REG,
   8726                           data_u8, BMA2x2_ACCEL_BW_MIN_RANGE);
   8727                      
   8728          			/* read x data_u8*/
   8729          			accel->x = (s16)((((s32)((s8)
   8730                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_X_MSB]))<<
   8731                                        BMA2x2_SHIFT_EIGHT_BITS)|
   8732                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_X_LSB]
   8733                                        & BMA2x2_10_BIT_SHIFT));
   8734          			accel->x = accel->x >> BMA2x2_SHIFT_SIX_BITS;
   8735                      
   8736          			/* read y data_u8*/
   8737          			accel->y = (s16)((((s32)((s8)
   8738                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_MSB]))<<
   8739                                        BMA2x2_SHIFT_EIGHT_BITS)|
   8740                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_LSB]
   8741                                        & BMA2x2_10_BIT_SHIFT));
   8742          			accel->y = accel->y >> BMA2x2_SHIFT_SIX_BITS;
   8743                      
   8744          			/* read z data_u8*/
   8745          			accel->z = (s16)((((s32)((s8)
   8746                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_MSB]))<<
   8747                                        BMA2x2_SHIFT_EIGHT_BITS)|
   8748                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_LSB]
   8749                                        & BMA2x2_10_BIT_SHIFT));
   8750          			accel->z = accel->z >> BMA2x2_SHIFT_SIX_BITS;
   8751                      
   8752          			/* read temp_s8 data_u8*/
   8753          			/*Accessing the sixth element of array*/
   8754          			accel->temp = (s8)data_u8[BMA2x2_SENSOR_DATA_TEMP];
   8755                      break;
   8756                    case BMA2x2_14_RESOLUTION:
   8757          			com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8758                          (p_bma2x2->dev_addr, BMA2x2_ACCEL_X14_LSB_REG,
   8759                           data_u8, BMA2x2_ACCEL_BW_MIN_RANGE);
   8760                      
   8761          			/* read x data_u8*/
   8762          			accel->x = (s16)((((s32)((s8)
   8763                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_X_MSB]))<<
   8764                                        BMA2x2_SHIFT_EIGHT_BITS)|
   8765                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_X_LSB]
   8766                                        & BMA2x2_14_BIT_SHIFT));
   8767          			accel->x = accel->x >> BMA2x2_SHIFT_TWO_BITS;
   8768                      
   8769          			/* read y data_u8*/
   8770          			accel->y = (s16)((((s32)((s8)
   8771                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_MSB]))<<
   8772                                        BMA2x2_SHIFT_EIGHT_BITS)|
   8773                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_Y_LSB]
   8774                                        & BMA2x2_14_BIT_SHIFT));
   8775          			accel->y = accel->y >> BMA2x2_SHIFT_TWO_BITS;
   8776                      
   8777          			/* read z data_u8*/
   8778          			accel->z = (s16)((((s32)((s8)
   8779                                               data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_MSB]))<<
   8780                                        BMA2x2_SHIFT_EIGHT_BITS)|
   8781                                       (data_u8[BMA2x2_SENSOR_DATA_XYZ_Z_LSB]
   8782                                        & BMA2x2_14_BIT_SHIFT));
   8783          			accel->z = accel->z >> BMA2x2_SHIFT_TWO_BITS;
   8784          			/* read temp data_u8*/
   8785          			/*Accessing the sixth element of array*/
   8786          			accel->temp = (s8)data_u8[BMA2x2_SENSOR_DATA_TEMP];
   8787                      break;
   8788                    default:
   8789                      break;
   8790          		}
   8791          	}
   8792          	return com_rslt;
   8793          }
   8794          /*!
   8795          * @brief This API reads accelerometer data X,Y,Z values and
   8796          * temperature data from location 0x02 to 0x08
   8797          *
   8798          *
   8799          *
   8800          *
   8801          *  @param accel : The value of accel xyz and temperature data
   8802          *
   8803          *	@return results of bus communication function
   8804          *	@retval 0 -> Success
   8805          *	@retval -1 -> Error
   8806          *
   8807          *
   8808          */
   8809          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_read_accel_eight_resolution_xyzt(
   8810                                                                              struct bma2x2_accel_eight_resolution_temp *accel)
   8811          {
   8812          	/*  Variable used to return value of
   8813          	communication routine*/
   8814          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8815          	u8	data_u8 = BMA2x2_INIT_VALUE;
   8816              
   8817          	if (p_bma2x2 == BMA2x2_NULL) {
   8818          		/* Check the struct p_bma2x2 is empty */
   8819          		return E_BMA2x2_NULL_PTR;
   8820              } else {
   8821                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8822          			(p_bma2x2->dev_addr,
   8823                       BMA2x2_X_AXIS_MSB_ADDR, &data_u8,
   8824                       BMA2x2_GEN_READ_WRITE_LENGTH);
   8825                  accel->x = BMA2x2_GET_BITSLICE(data_u8,
   8826                                                 BMA2x2_ACCEL_X_MSB);
   8827                  
   8828                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8829          			(p_bma2x2->dev_addr,
   8830                       BMA2x2_Y_AXIS_MSB_ADDR, &data_u8,
   8831                       BMA2x2_GEN_READ_WRITE_LENGTH);
   8832                  accel->y = BMA2x2_GET_BITSLICE(data_u8,
   8833                                                 BMA2x2_ACCEL_Y_MSB);
   8834                  
   8835                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC
   8836          			(p_bma2x2->dev_addr,
   8837                       BMA2x2_Z_AXIS_MSB_ADDR, &data_u8,
   8838                       BMA2x2_GEN_READ_WRITE_LENGTH);
   8839                  accel->z = BMA2x2_GET_BITSLICE(data_u8,
   8840                                                 BMA2x2_ACCEL_Z_MSB);
   8841                  
   8842                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(
   8843                                                            p_bma2x2->dev_addr, BMA2x2_TEMP_ADDR, &data_u8,
   8844                                                            BMA2x2_GEN_READ_WRITE_LENGTH);
   8845                  accel->temp = (s8)data_u8;
   8846              }
   8847          	return com_rslt;
   8848          }
   8849          
   8850          /*!
   8851          *	@brief This API is used to get
   8852          *	the fifo data in the register 0x3F bit 0 to 7
   8853          *
   8854          *
   8855          *  @param  output_reg_u8 : The value of fifo data
   8856          *
   8857          *
   8858          *
   8859          *	@return results of bus communication function
   8860          *	@retval 0 -> Success
   8861          *	@retval -1 -> Error
   8862          *
   8863          *
   8864          */
   8865          BMA2x2_RETURN_FUNCTION_TYPE bma2x2_get_fifo_data_output_reg(u8 *output_reg_u8)
   8866          {
   8867          #warning This API is deprecated ,Instead use the \
   8868          	"bma2x2_read_fifo_data" API for reading FIFO data
   8869                  
   8870                  u8 data_u8 = BMA2x2_INIT_VALUE;
   8871          	/*Variable used to return value of
   8872          	communication routine*/
   8873          	BMA2x2_RETURN_FUNCTION_TYPE com_rslt = ERROR;
   8874              
   8875          	if (p_bma2x2 == BMA2x2_NULL) {
   8876          		/* Check the struct p_bma2x2 is empty */
   8877          		return E_BMA2x2_NULL_PTR;
   8878              } else {
   8879                  /*GET FIFO DATA OUTPUT REGISTER*/
   8880                  com_rslt = p_bma2x2->BMA2x2_BUS_READ_FUNC(p_bma2x2->dev_addr,
   8881                                                            BMA2x2_FIFO_DATA_OUTPUT_ADDR,
   8882                                                            &data_u8, BMA2x2_GEN_READ_WRITE_LENGTH);
   8883                  *output_reg_u8 = data_u8;
   8884              }
   8885          	return com_rslt;
   8886          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   bma2x2_burst_read
         8   -- Indirect call
      32   bma2x2_extract_accel
        32   -> get_accel_len_to_parse
        32   -> unpack_accel_frame
      16   bma2x2_get_bw
        16   -- Indirect call
      16   bma2x2_get_cal_rdy
        16   -- Indirect call
      16   bma2x2_get_durn
        16   -- Indirect call
      16   bma2x2_get_fifo_data_output_reg
        16   -- Indirect call
      16   bma2x2_get_fifo_data_select
        16   -- Indirect call
      16   bma2x2_get_fifo_frame_count
        16   -- Indirect call
      16   bma2x2_get_fifo_mode
        16   -- Indirect call
      16   bma2x2_get_fifo_overrun
        16   -- Indirect call
       8   bma2x2_get_fifo_stat
         8   -- Indirect call
      16   bma2x2_get_fifo_wml_trig
        16   -- Indirect call
      16   bma2x2_get_flat_hold_time
        16   -- Indirect call
      16   bma2x2_get_flat_hyst
        16   -- Indirect call
      16   bma2x2_get_high_bw
        16   -- Indirect call
      16   bma2x2_get_i2c_wdt
        16   -- Indirect call
      16   bma2x2_get_intr1_fifo_full
        16   -- Indirect call
      16   bma2x2_get_intr1_fifo_wm
        16   -- Indirect call
      16   bma2x2_get_intr2_fifo_full
        16   -- Indirect call
      16   bma2x2_get_intr2_fifo_wm
        16   -- Indirect call
      16   bma2x2_get_intr_double_tap
        16   -- Indirect call
      16   bma2x2_get_intr_enable
        16   -- Indirect call
      16   bma2x2_get_intr_fifo_full
        16   -- Indirect call
      16   bma2x2_get_intr_fifo_wm
        16   -- Indirect call
      16   bma2x2_get_intr_flat
        16   -- Indirect call
      16   bma2x2_get_intr_high_g
        16   -- Indirect call
      16   bma2x2_get_intr_level
        16   -- Indirect call
      16   bma2x2_get_intr_low_g
        16   -- Indirect call
      16   bma2x2_get_intr_orient
        16   -- Indirect call
       8   bma2x2_get_intr_orient_stat
         8   -- Indirect call
      16   bma2x2_get_intr_output_type
        16   -- Indirect call
      16   bma2x2_get_intr_single_tap
        16   -- Indirect call
      16   bma2x2_get_intr_slope
        16   -- Indirect call
      16   bma2x2_get_intr_slow_no_motion
        16   -- Indirect call
       8   bma2x2_get_intr_stat
         8   -- Indirect call
       8   bma2x2_get_intr_tap_stat
         8   -- Indirect call
      16   bma2x2_get_latch_intr
        16   -- Indirect call
      16   bma2x2_get_low_g_mode
        16   -- Indirect call
      16   bma2x2_get_low_high_g_hyst
        16   -- Indirect call
      16   bma2x2_get_new_data
        16   -- Indirect call
      16   bma2x2_get_nvmprog_mode
        16   -- Indirect call
      16   bma2x2_get_nvmprog_ready
        16   -- Indirect call
      16   bma2x2_get_nvmprog_remain
        16   -- Indirect call
      16   bma2x2_get_offset
        16   -- Indirect call
      16   bma2x2_get_offset_target
        16   -- Indirect call
      16   bma2x2_get_orient_block
        16   -- Indirect call
      16   bma2x2_get_orient_enable
        16   -- Indirect call
      16   bma2x2_get_orient_hyst
        16   -- Indirect call
      16   bma2x2_get_orient_mode
        16   -- Indirect call
      24   bma2x2_get_power_mode
        24   -- Indirect call
      16   bma2x2_get_range
        16   -- Indirect call
      16   bma2x2_get_selftest_axis
        16   -- Indirect call
      16   bma2x2_get_selftest_sign
        16   -- Indirect call
      16   bma2x2_get_shadow_dis
        16   -- Indirect call
      16   bma2x2_get_sleep_durn
        16   -- Indirect call
      16   bma2x2_get_sleep_timer_mode
        16   -- Indirect call
      16   bma2x2_get_slow_comp
        16   -- Indirect call
      16   bma2x2_get_slow_no_motion
        16   -- Indirect call
      16   bma2x2_get_source
        16   -- Indirect call
      16   bma2x2_get_spi3
        16   -- Indirect call
      16   bma2x2_get_tap_durn
        16   -- Indirect call
      16   bma2x2_get_tap_quiet
        16   -- Indirect call
      16   bma2x2_get_tap_sample
        16   -- Indirect call
      16   bma2x2_get_tap_shock
        16   -- Indirect call
      16   bma2x2_get_tap_thres
        16   -- Indirect call
      16   bma2x2_get_theta
        16   -- Indirect call
      16   bma2x2_get_thres
        16   -- Indirect call
      16   bma2x2_init
        16   -- Indirect call
        16   -> bma2x2_read_reg
      16   bma2x2_read_accel_eight_resolution_x
        16   -- Indirect call
      16   bma2x2_read_accel_eight_resolution_xyz
        16   -- Indirect call
      16   bma2x2_read_accel_eight_resolution_xyzt
        16   -- Indirect call
      16   bma2x2_read_accel_eight_resolution_y
        16   -- Indirect call
      16   bma2x2_read_accel_eight_resolution_z
        16   -- Indirect call
      16   bma2x2_read_accel_x
        16   -- Indirect call
      24   bma2x2_read_accel_xyz
        24   -- Indirect call
      24   bma2x2_read_accel_xyzt
        24   -- Indirect call
      16   bma2x2_read_accel_y
        16   -- Indirect call
      16   bma2x2_read_accel_z
        16   -- Indirect call
      16   bma2x2_read_fifo_data
        16   -- Indirect call
        16   -> bma2x2_get_fifo_data_select
        16   -> bma2x2_get_fifo_frame_count
       8   bma2x2_read_reg
         8   -- Indirect call
      16   bma2x2_read_temp
        16   -- Indirect call
      16   bma2x2_rst_intr
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_bw
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_cal_trigger
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_durn
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_fifo_data_select
        16   -- Indirect call
        16   -> bma2x2_get_power_mode
        16   -> bma2x2_set_power_mode
        16   -> bma2x2_write_reg
      16   bma2x2_set_fifo_mode
        16   -- Indirect call
        16   -> bma2x2_get_power_mode
        16   -> bma2x2_set_power_mode
        16   -> bma2x2_write_reg
      16   bma2x2_set_fifo_wml_trig
        16   -- Indirect call
        16   -> bma2x2_get_power_mode
        16   -> bma2x2_set_power_mode
        16   -> bma2x2_write_reg
      16   bma2x2_set_flat_hold_time
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_flat_hyst
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_high_bw
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_i2c_wdt
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_intr1_fifo_full
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_intr1_fifo_wm
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_intr2_fifo_full
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_intr2_fifo_wm
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_intr_double_tap
        16   -- Indirect call
        16   -> bma2x2_write_reg
      24   bma2x2_set_intr_enable
        24   -- Indirect call
        24   -> bma2x2_write_reg
      16   bma2x2_set_intr_fifo_full
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_intr_fifo_wm
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_intr_flat
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_intr_high_g
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_intr_level
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_intr_low_g
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_intr_orient
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_intr_output_type
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_intr_single_tap
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_intr_slope
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_intr_slow_no_motion
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_latch_intr
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_low_g_mode
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_low_high_g_hyst
        16   -- Indirect call
        16   -> bma2x2_write_reg
       0   bma2x2_set_mode_value
      16   bma2x2_set_new_data
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_nvmprog_mode
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_nvprog_trig
        16   -- Indirect call
        16   -> bma2x2_write_reg
       8   bma2x2_set_offset
         8   -> bma2x2_write_reg
      16   bma2x2_set_offset_rst
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_offset_target
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_orient_block
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_orient_enable
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_orient_hyst
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_orient_mode
        16   -- Indirect call
        16   -> bma2x2_write_reg
      24   bma2x2_set_power_mode
        24   -- Indirect call
        24   -> bma2x2_set_mode_value
        24   -> bma2x2_write_reg
      16   bma2x2_set_range
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_selftest_axis
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_selftest_sign
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_shadow_dis
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_sleep_durn
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_sleep_timer_mode
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_slow_comp
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_slow_no_motion
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_source
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_spi3
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_tap_durn
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_tap_quiet
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_tap_sample
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_tap_shock
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_tap_thres
        16   -- Indirect call
        16   -> bma2x2_write_reg
      16   bma2x2_set_theta
        16   -- Indirect call
        16   -> bma2x2_write_reg
       8   bma2x2_set_thres
         8   -> bma2x2_write_reg
       8   bma2x2_soft_rst
         8   -> bma2x2_write_reg
      16   bma2x2_update_image
        16   -- Indirect call
        16   -> bma2x2_write_reg
       8   bma2x2_write_reg
         8   -- Indirect call
       8   get_accel_len_to_parse
      16   unpack_accel_frame
        16   -> unpack_accel_xyz
       8   unpack_accel_xyz


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable106
       4  ??DataTable137
       4  ??DataTable145
       4  ??DataTable145_1
       4  ??DataTable24
       4  ??DataTable27
       4  ??DataTable48
       4  ??DataTable73
       2  ?_0
       2  ?_1
       2  ?_2
       8  ?_3
       8  ?_4
       1  V_BMA2x2RESOLUTION_U8
      54  bma2x2_burst_read
     138  bma2x2_extract_accel
      76  bma2x2_get_bw
      68  bma2x2_get_cal_rdy
     194  bma2x2_get_durn
      58  bma2x2_get_fifo_data_output_reg
      62  bma2x2_get_fifo_data_select
      68  bma2x2_get_fifo_frame_count
      62  bma2x2_get_fifo_mode
      68  bma2x2_get_fifo_overrun
      50  bma2x2_get_fifo_stat
      68  bma2x2_get_fifo_wml_trig
      68  bma2x2_get_flat_hold_time
      62  bma2x2_get_flat_hyst
      68  bma2x2_get_high_bw
     124  bma2x2_get_i2c_wdt
      68  bma2x2_get_intr1_fifo_full
      68  bma2x2_get_intr1_fifo_wm
      68  bma2x2_get_intr2_fifo_full
      68  bma2x2_get_intr2_fifo_wm
     124  bma2x2_get_intr_double_tap
     524  bma2x2_get_intr_enable
      68  bma2x2_get_intr_fifo_full
      68  bma2x2_get_intr_fifo_wm
     124  bma2x2_get_intr_flat
     114  bma2x2_get_intr_high_g
     114  bma2x2_get_intr_level
     114  bma2x2_get_intr_low_g
     124  bma2x2_get_intr_orient
      50  bma2x2_get_intr_orient_stat
     114  bma2x2_get_intr_output_type
     124  bma2x2_get_intr_single_tap
     114  bma2x2_get_intr_slope
     124  bma2x2_get_intr_slow_no_motion
      50  bma2x2_get_intr_stat
      50  bma2x2_get_intr_tap_stat
      68  bma2x2_get_latch_intr
      68  bma2x2_get_low_g_mode
     124  bma2x2_get_low_high_g_hyst
     124  bma2x2_get_new_data
      68  bma2x2_get_nvmprog_mode
      68  bma2x2_get_nvmprog_ready
      68  bma2x2_get_nvmprog_remain
     136  bma2x2_get_offset
     202  bma2x2_get_offset_target
      62  bma2x2_get_orient_block
      62  bma2x2_get_orient_enable
      62  bma2x2_get_orient_hyst
      62  bma2x2_get_orient_mode
     256  bma2x2_get_power_mode
      76  bma2x2_get_range
      68  bma2x2_get_selftest_axis
      68  bma2x2_get_selftest_sign
      68  bma2x2_get_shadow_dis
      68  bma2x2_get_sleep_durn
      68  bma2x2_get_sleep_timer_mode
     162  bma2x2_get_slow_comp
     202  bma2x2_get_slow_no_motion
     268  bma2x2_get_source
      68  bma2x2_get_spi3
      68  bma2x2_get_tap_durn
      68  bma2x2_get_tap_quiet
      68  bma2x2_get_tap_sample
      68  bma2x2_get_tap_shock
      68  bma2x2_get_tap_thres
     110  bma2x2_get_theta
     186  bma2x2_get_thres
     112  bma2x2_init
      64  bma2x2_read_accel_eight_resolution_x
     124  bma2x2_read_accel_eight_resolution_xyz
     136  bma2x2_read_accel_eight_resolution_xyzt
      64  bma2x2_read_accel_eight_resolution_y
      64  bma2x2_read_accel_eight_resolution_z
     214  bma2x2_read_accel_x
     388  bma2x2_read_accel_xyz
     390  bma2x2_read_accel_xyzt
     214  bma2x2_read_accel_y
     214  bma2x2_read_accel_z
     136  bma2x2_read_fifo_data
      56  bma2x2_read_reg
      58  bma2x2_read_temp
      90  bma2x2_rst_intr
     298  bma2x2_set_bw
      86  bma2x2_set_cal_trigger
     202  bma2x2_set_durn
     154  bma2x2_set_fifo_data_select
     158  bma2x2_set_fifo_mode
     132  bma2x2_set_fifo_wml_trig
      86  bma2x2_set_flat_hold_time
      86  bma2x2_set_flat_hyst
      90  bma2x2_set_high_bw
     156  bma2x2_set_i2c_wdt
      98  bma2x2_set_intr1_fifo_full
      98  bma2x2_set_intr1_fifo_wm
      98  bma2x2_set_intr2_fifo_full
      98  bma2x2_set_intr2_fifo_wm
     156  bma2x2_set_intr_double_tap
     346  bma2x2_set_intr_enable
      98  bma2x2_set_intr_fifo_full
      98  bma2x2_set_intr_fifo_wm
     164  bma2x2_set_intr_flat
     146  bma2x2_set_intr_high_g
     156  bma2x2_set_intr_level
     146  bma2x2_set_intr_low_g
     156  bma2x2_set_intr_orient
     146  bma2x2_set_intr_output_type
     156  bma2x2_set_intr_single_tap
     146  bma2x2_set_intr_slope
     156  bma2x2_set_intr_slow_no_motion
     216  bma2x2_set_latch_intr
      86  bma2x2_set_low_g_mode
     160  bma2x2_set_low_high_g_hyst
     156  bma2x2_set_mode_value
     160  bma2x2_set_new_data
      86  bma2x2_set_nvmprog_mode
      86  bma2x2_set_nvprog_trig
     104  bma2x2_set_offset
      90  bma2x2_set_offset_rst
     250  bma2x2_set_offset_target
      80  bma2x2_set_orient_block
      80  bma2x2_set_orient_enable
      80  bma2x2_set_orient_hyst
      80  bma2x2_set_orient_mode
     304  bma2x2_set_power_mode
     196  bma2x2_set_range
      98  bma2x2_set_selftest_axis
      98  bma2x2_set_selftest_sign
      86  bma2x2_set_shadow_dis
     184  bma2x2_set_sleep_durn
      98  bma2x2_set_sleep_timer_mode
     210  bma2x2_set_slow_comp
     262  bma2x2_set_slow_no_motion
     350  bma2x2_set_source
      86  bma2x2_set_spi3
      86  bma2x2_set_tap_durn
      90  bma2x2_set_tap_quiet
      90  bma2x2_set_tap_sample
      86  bma2x2_set_tap_shock
      86  bma2x2_set_tap_thres
     116  bma2x2_set_theta
     120  bma2x2_set_thres
      42  bma2x2_soft_rst
      86  bma2x2_update_image
      82  bma2x2_write_reg
      46  get_accel_len_to_parse
       4  p_bma2x2
     446  unpack_accel_frame
     200  unpack_accel_xyz

 
      4 bytes in section .bss
      1 byte  in section .data
     22 bytes in section .rodata
 18 270 bytes in section .text
 
 18 270 bytes of CODE  memory
     22 bytes of CONST memory
      5 bytes of DATA  memory

Errors: none
Warnings: 1
